# Leetcode

## 1051. Height Checker
```javascript
/**
 * @param {number[]} heights
 * @return {number}
 */
var heightChecker = function(heights) {
    const buckets = Array(101).fill(0)
    for (const height of heights) {
        buckets[height]++
    }
    
    const sortedHeights = []
    for (let i = 0; i < buckets.length; i++) {
        while (buckets[i]--) {
            sortedHeights.push(i)
        }
    }
    
    let diff = 0
    for (let i = 0; i < heights.length; i++) {
        if (sortedHeights[i] !== heights[i])
            diff++
    }
    
    return diff
};
```

## 922. Sort Array By Parity II
```javascript
var sortArrayByParityII = function(A) {
    let i = 0
    for (let j = 1; j < A.length; j += 2) {
        if (A[j] % 2 === 0) {
            while (A[i] % 2 == 0) i += 2
            
            let temp = A[j]
            A[j] = A[i]
            A[i] = temp
        }
    }
    return A
};
```

## 985. Sum of Even Numbers After Queries
```javascript
/**
 * @param {number[]} A
 * @param {number[][]} queries
 * @return {number[]}
 */
const isEven = num => (num & 1) === 0

var sumEvenAfterQueries = function(A, queries) {
  if (!A.length || !queries.length) return []
  
  let sum = A.reduce((result, num) => isEven(num) ? result + num : result, 0)
  
  return queries.reduce((result, [value, index]) => {
      if (isEven(A[index])) 
          sum -= A[index]
      
      A[index] += value
      
      if (isEven(A[index])) 
          sum += A[index]
      
      result.push(sum)
      return result
  }, [])
};
```

## 766. Toeplitz Matrix
```javascript
/**
 * @param {number[][]} matrix
 * @return {boolean}
 */
var isToeplitzMatrix = function(matrix) {
    for (var i = 0; i < matrix.length - 1; i++) {
        for (var j = 0; j < matrix[0].length - 1; j++) {
            if (matrix[i][j] != matrix[i+1][j+1]) {
                return false;
            }   
        }   
    }

    return true;
};

// Follow Up 1
/**
 * @param {number[][]} matrix
 * @return {boolean}
 */
var isToeplitzMatrix = function(matrix) {
    const m = matrix.length
    const n = matrix[0].length
    
    let prevRow = null
    for (let row = 0; row < m; row++) {
        const currRow = matrix[row].slice(1)
        if (prevRow && !equal(prevRow, currRow)) {
            return false
        }
        
        prevRow = matrix[row].slice(0, n - 1) 
    }
    
    return true
}

const equal = (arr1, arr2) => {
    if (arr1.length !== arr2.length) return false
    
    for (let i = 0; i < arr1.lenght; i++) {
        if (arr1[i] !== arr2[i]) return false
    }
    
    return true
}

// Follow Up 2
var isToeplitzMatrix = function(matrix) {
    const m = matrix.length
    const n = matrix[0].length
    
    let prevCol = null
    for (let col = 0; col < n; col++) {
        const currCol = []
        for (let row = 1; row < m; row++) {
            currCol.push(matrix[row][col])
        }
        
        if (prevCol && !equal(prevCol, currCol)) {
            return false
        }
        
        prevCol = []
        for (let row = 0; row < m - 1; row++) {
            prevCol.push(matrix[row][col])
        }
    }
    
    return true
}

const equal = (arr1, arr2) => {
    if (arr1.length !== arr2.length) return false
    
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) return false
    }
    
    return true
}
```

## 1099. Two Sum Less Than K
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var twoSumLessThanK = function(A, K) {
    const counts = Array(1001).fill(0)
    for (let a of A) counts[a]++
    
    const sortedA = []
    for (let i = 0; i < counts.length; i++) {
        while (counts[i] > 0) {
            sortedA.push(i)
            counts[i]--
        }
    }
    
    let left = 0
    let right = sortedA.length - 1
    let max = -1
    
    while (left < right) {
        let sum = sortedA[left] + sortedA[right]
        if (sum >= K) {
            right--
        } else {
            max = Math.max(sum, max)
            left++
        }
    }
    return max
};
```

## 566. Reshape the Matrix
```javascript
/**
 * @param {number[][]} nums
 * @param {number} r
 * @param {number} c
 * @return {number[][]}
 */
var matrixReshape = function(nums, r, c) {
    const m = nums.length
    const n = nums[0].length
    
    if (m * n !== r * c) {
        return nums
    }

    const matrix = Array(r).fill(0).map(a => Array(c).fill(0))
    let currRow = 0
    let currCol = 0
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            matrix[currRow][currCol] = nums[row][col]
            currCol++
            
            if (currCol === c) {
                currCol = 0
                currRow++
            }
        }
    }
    
    return matrix
};
```

## 243. Shortest Word Distance
```javascript
/**
 * @param {string[]} words
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var shortestDistance = function(words, word1, word2) {
    let i1 = -1
    let i2 = -1
    let dist = words.length
    
    for (let i = 0; i < words.length; i++) {
        if (words[i] === word1) i1 = i
        if (words[i] === word2) i2 = i
        if (i1 !== -1 && i2 !== -1) dist = Math.min(Math.abs(i1 - i2), dist)    
    }
    return dist
};
```

## 485. Max Consecutive Ones
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    let count = 0
    let max = 0
    
    for (const num of nums) {
        count += num ? 1 : -count
        max = Math.max(max, count)
    }
    
    return max
};
```

## 448. Find All Numbers Disappeared in an Array
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    for (let i = 0; i < nums.length; i++) {
        const index = Math.abs(nums[i]) - 1
        nums[index] = -1 * Math.abs(nums[index])
    }
    
    const result = []
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) result.push(i + 1)
    }
    
    return result
};
```

## 283. Move Zeroes
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let i = 0
    for (let j = 0; j < nums.length; j++) {
        if (nums[j] !== 0) {
            const temp = nums[i]
            nums[i] = nums[j]
            nums[j] = temp
            i++
        }
    }
};
```

## 169. Majority Element
```javascript
// Boyer-Moore Voting
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    let candidate = nums[0]
    let votes = 1
    
    for (let i = 1; i < nums.length; i++) {
        nums[i] === candidate ? votes++ : votes--
        
        if (votes === 0) {
            candidate = nums[i]
            votes = 1
        }
    }
    
    return candidate
};

// Divide And Conquer
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    const _majorityElement = (nums, low, high) => {
        if (low === high) return nums[low]
        
        const mid = Math.floor((high - low) / 2) + low
        const left = _majorityElement(nums, low, mid)
        const right = _majorityElement(nums, mid + 1, high)
        
        if (left === right)
            return left
        
        const leftCount = countInRange(nums, left, low, high)
        const rightCount = countInRange(nums, right, low, high)
        
        return leftCount > rightCount ? left : right
    }
    
    const countInRange = (nums, ele, low, high) => {
        let count = 0
        for (let i = low; low <= high; low++) {
            if (nums[low] === ele) {
                count++
            }
        }
        return count
    }
    
    return _majorityElement(nums, 0, nums.length - 1)
};
```

## 217. Contains Duplicate
```javascript
var containsDuplicate = function(nums) {
  if (!nums.length) return false
  const unique = new Set(nums)
  return nums.length !== unique.size
};
```

## 268. Missing Number
```javascript
// XOR
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    if (!nums.length) return null

    let missingNum = 0

    for (let num of nums) {
        missingNum ^= num
    }

    for (let i = 0; i <= nums.length; i++) {
        missingNum ^= i
    }
    return missingNum
};

// Gauss' Formula
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    const n = nums.length
    const expectedSum = n * (n + 1) / 2
    
    let actualSum = 0
    for (const num of nums) {
        actualSum += num
    }
    
    return expectedSum - actualSum
};
```

## 830. Positions of Large Groups
```javascript
/**
 * @param {string} S
 * @return {number[][]}
 */
var largeGroupPositions = function(S) {
    const result = []
    
    let start = 0
    for (let i = 1; i <= S.length; i++) {
        if (S[i - 1] === S[i]) continue
        
        if (i - start >= 3) {
            result.push([start, i - 1])
        }
        
        start = i
    }
    
    return result
};
```
## 118. Pascal's Triangle
```javascript
var generate = function(numRows) {
    if (!numRows) return []
    
    let result = [[1]]
    
    for (let i = 1; i < numRows; i++) {
        let curr = []
        let prev = result[i-1]
        
        for (let j = 0; j <= prev.length; j++) {
            if (j <= 0 || j >= prev.length) {
                curr.push(1)
                continue
            }
            curr.push(prev[j] + prev[j-1])
        }
        result.push(curr)
    }
    return result
};
```

## 53. Maximum Subarray
```javascript
// Kadane's Algorithm
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let globalMax = nums[0]
    let localMax = nums[0]
    
    for (let i = 1; i < nums.length; i++) {
        localMax = Math.max(nums[i], localMax + nums[i])
        globalMax = Math.max(localMax, globalMax)
    }
    return globalMax
};

// Divide And Conquer
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    const _maxSubArray = (left, right) => {
        if (left === right) return nums[left]
        
        const mid = Math.floor((right - left) / 2) + left
        const leftMax = _maxSubArray(left, mid)
        const rightMax = _maxSubArray(mid + 1, right)
        const crossMax = _maxCrossing(left, right, mid)
        
        return Math.max(leftMax, rightMax, crossMax)
    }
    
    const _maxCrossing = (left, right, mid) => {
        if (left === right) return nums[left]
        
        let leftSum = -Infinity
        let currSum = 0
        for (let i = mid; i >= left; i--) {
            currSum += nums[i]
            leftSum = Math.max(leftSum, currSum)
        }

        let rightSum = -Infinity
        currSum = 0
        for (let i = mid + 1; i <= right; i++) {
            currSum += nums[i]
            rightSum = Math.max(rightSum, currSum)
        }

        return leftSum + rightSum
    }
    
    return _maxSubArray(0, nums.length - 1)
};
```

## 1128. Number of Equivalent Domino Pairs
```javascript
/**
 * @param {number[][]} dominoes
 * @return {number}
 */
var numEquivDominoPairs = function(dominoes) {
    const map = {}
    let count = 0
    for (let i = 0; i < dominoes.length; i++) {
        const [a, b] = dominoes[i]
        
        count += (map[`${a}-${b}`] || 0)
        if (a !== b) {
            count += (map[`${b}-${a}`] || 0)
        }
        
        
        map[`${a}-${b}`] = 1 + (map[`${a}-${b}`] || 0)
    }
    
    return count
};

/**
 * @param {number[][]} dominoes
 * @return {number}
 */
var numEquivDominoPairs = function(dominoes) {
  if (!dominoes.length) return 0

  const seen = Array(100).fill(0)
  let pairCount = 0

  for (let [a, b] of dominoes) {
    let min = Math.min(a, b)
    let max = Math.max(a, b)
    let val = min * 10 + max
    
    if (seen[val] > 0) {
        pairCount += seen[val]  
        seen[val]++
        continue
    }
    
    seen[val] = 1
  }
  return pairCount
};

/**
 * @param {number[][]} dominoes
 * @return {number}
 */
var numEquivDominoPairs = function(dominoes) {
    const seen = {}
    
    for (let i = 0; i < dominoes.length; i++) {
        const [a, b] = dominoes[i]
        const key = `${Math.min(a, b)}-${Math.max(a, b)}`
        
        if (!seen[key]) seen[key] = []
        seen[key].push(i)
    }
    
    let count = 0
    for (const [key, val] of Object.entries(seen)) {
        count += val.length * (val.length - 1) / 2
    }
    
    return count
};
```

## 674. Longest Continuous Increasing Subsequence
```javascript
var findLengthOfLCIS = function(nums) {
  if (!nums.length) return 0
  
  let globalMax = 1
  let localMax = 1
  
  for (let i = 1; i < nums.length; i++) {    
    if (nums[i] > nums[i-1]) {
      localMax++
      globalMax = Math.max(localMax, globalMax)
      continue
    }
      
    localMax = 1
  }
  return globalMax
};
```

## 66. Plus One
```javascript
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    const result = []
    let carry = 1
    
    for (let i = digits.length - 1; i >= 0; i--) {
        const sum = digits[i] + carry
        result.push(sum % 10)
        carry = Math.floor(sum / 10)
    }
    
    if (carry > 0) {
        result.push(carry)
    }
    
    result.reverse()
    return result
};
```

## 532. K-diff Pairs in an Array
```javascript
var findPairs = function(nums, k) {
  if (k < 0) return 0

  const counts = {}
  for (let num of nums) {
    counts[num] = 1 + (counts[num] || 0)
  }  

  let pairs = 0
  for (let [num, count] of Object.entries(counts)) {
    if (k === 0) {
      if (counts[num] > 1) pairs++
      continue
    }

    if (counts[+num + k]) pairs++
  }

  return pairs
};
```

## 747. Largest Number At Least Twice of Others
```javascript
var dominantIndex = function(nums) {
  let max = 0
  let maxIndex = 0
  let secondMax = 0
  
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max) {
      secondMax = max
      max = nums[i]
      maxIndex = i
      continue
    }
    
    if (nums[i] > secondMax) {
      secondMax = nums[i]
    }  
  }
  
  return max >= secondMax * 2 ? maxIndex : -1
};
```

## 26. Remove Duplicates from Sorted Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let i = 0
    for (let j = 1; j < nums.length; j++) {
        if (nums[i] !== nums[j]) {
            i++
            nums[i] = nums[j]
        }
    }
    
    return i + 1
};
```

## 724. Find Pivot Index
```javascript
var pivotIndex = function(nums) {
    let sum = nums.reduce((result, num) => result + num, 0)
    let leftSum = 0
    for (let i = 0; i < nums.length; i++) {
        if (leftSum === sum - leftSum - nums[i]) return i
        leftSum += nums[i]
    }
    return -1
};
```

## 643. Maximum Average Subarray I
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findMaxAverage = function(nums, k) {
    let maxAvg = 0
    let currSum = 0
    
    for (let i = 0; i < k; i++) currSum += nums[i]
    maxAvg = currSum / k
    
    for (let i = k; i < nums.length; i++) {
        currSum -= nums[i - k]
        currSum += nums[i]
        maxAvg = Math.max(currSum / k, maxAvg)
    }
    return maxAvg
};

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findMaxAverage = function(nums, k) {
    let maxAvg = -Infinity
    let sum = 0
    
    for (let i = 0; i < nums.length; i++) {
        sum += nums[i]
        
        if (i < k - 1) continue
        
        sum -= nums[i - k] || 0
        maxAvg = Math.max(maxAvg, sum / k)
    }
    
    return maxAvg
};
```

## 34. Find First and Last Position of Element in Sorted Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
    const firstIndex = binarySearch(nums, target)
    if (nums[firstIndex] !== target) {
        return [-1, -1]
    }
    
    const lastIndex = binarySearch(nums, target + 1) - 1
    return [firstIndex, lastIndex]
};

const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        if (arr[mid] < target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left
}
```

## 1150. Check If a Number Is Majority Element in a Sorted Array
```javascript
// Two Binary Searches
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {boolean}
 */
var isMajorityElement = function(nums, target) {
    const firstIndex = binarySearch(nums, target)
    
    if (nums[firstIndex] !== target) 
        return false
    
    const lastIndex = binarySearch(nums, target + 1)
    return (lastIndex - firstIndex) + 1 > nums.length / 2
};

const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid] < target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left
}

// One Binary Search
const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length
    
    while (left < right) {
       let mid = Math.floor((right - left) / 2) + left

       if (arr[mid] < target) {
           left = mid + 1
       } else {
           right = mid
       }
    }
    
    return arr[left] === target ? left : -1
}

var isMajorityElement = function(nums, target) {
    const start = binarySearch(nums, target)
    if (start === -1) return false
    return (nums[start] === nums[start + Math.floor(nums.length / 2)])
};
```

## 1122. Relative Sort Array
```javascript
// Counting
var relativeSortArray = function(arr1, arr2) {
    const result = []
    const counts = Array(1001).fill(0)
    
    for (const num of arr1)
        counts[num]++
    
    for (const num of arr2)
        while (counts[num]--)
            result.push(num)
    
    for (let i = 0; i < counts.length; i++)
        while(counts[i]-- > 0)
            result.push(i)
    
    return result
};
```

## 1002. Find Common Characters
```javascript
/**
 * @param {string[]} A
 * @return {string[]}
 */
const charCounts = word => {
    return word.split('').reduce((result, char) => {
        result[char] = 1 + (result[char] || 0)
        return result
    }, {})
}

const merge = (map1, map2) => {
    let result = {}
    
    for (let [key, value] of Object.entries(map1)) {
        if (map1[key] && map2[key]) {
            result[key] = Math.min(map1[key], map2[key])
        }
    }
    return result
}

var commonChars = function(A) {
    if (!A.length) return []
    
    let counts = charCounts(A[0])
    for (let i = 1; i < A.length; i++) {
        counts = merge(charCounts(A[i]), counts)
    }
    
    return Object.entries(counts).reduce((result, [key, value]) => {
        return result.concat(Array(value).fill(key))
    }, [])
};

/**
 * @param {string[]} A
 * @return {string[]}
 */
var commonChars = function(A) {
    const counts = count(A[0])
    
    for (let i = 1; i < A.length; i++) {
        const wordCounts = count(A[i])
        merge(counts, wordCounts)
    }
    
    const result = []
    
    for (let i = 0; i < counts.length; i++) {
        while (counts[i]--) {
            result.push(charFromIndex(i))
        }
    }
    
    return result
};

const count = str => {
    const counts = Array(26).fill(0)
    
    for (const char of str) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        counts[index]++
    }
    
    return counts
}

const merge = (counts, wordCounts) => {
    for (let j = 0; j < wordCounts.length; j++) {
        counts[j] = Math.min(counts[j], wordCounts[j])
    }
}

const charFromIndex = i => String.fromCharCode(i + 'a'.charCodeAt(0))
```

## 1170. Compare Strings by Frequency of the Smallest Character
```javascript
const f = str => {
    let min = str[0]
    for (let i = 1; i < str.length; i++)
        min = str[i] < min ? str[i] : min
    
    let count = 0
    for (const char of str)
        if (char === min) count++
    
    return count
}

var numSmallerByFrequency = function(queries, words) {
    const wordsNum = words.map(ele => f(ele))
    
    const buckets = Array(12).fill(0)
    for (w of wordsNum)
        buckets[w]++
    
    for (let i = buckets.length - 1; i >= 1; i--)
        buckets[i - 1] = buckets[i - 1] + buckets[i]
    
    const result = []
    
    for (const q of queries)
        result.push(buckets[f(q) + 1])
    
    return result
};
```

## 27. Remove Element
```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let i = 0
    for (let j = 0; j < nums.length; j++) {
        if (nums[j] !== val) {
            nums[i++] = nums[j]
        }
    }
    
    return i
};
```

## 35. Search Insert Position
```javascript
var searchInsert = function(nums, target) {
    let left = 0
    let right = nums.length
    
    while (left < right) {
        let mid = Math.floor((right - left) / 2) + left
        
        if (nums[mid] < target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
};
```

## 121. Best Time to Buy and Sell Stock
```javascript
// DP
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let minPrice = Infinity
    let maxProfit = 0
    
    for (const price of prices) {
        minPrice = Math.min(minPrice, price)
        maxProfit = Math.max(maxProfit, price - minPrice)
    }
    
    return maxProfit
};

// Kadane's
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    if (!prices.length) return 0
    
    let maxGlobal = 0
    let maxLocal = 0
    
    for (let i = 1; i < prices.length; i++) {
        maxLocal = Math.max(0, maxLocal + prices[i] - prices[i - 1])
        maxGlobal = Math.max(maxLocal, maxGlobal)
    }
    return maxGlobal
};
```

## 122. Best Time to Buy and Sell Stock II
```javascript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let profit = 0
    for (let day = 1; day < prices.length; day++) {
        if (prices[day - 1] < prices[day]) {
            profit += prices[day] - prices[day - 1]
        }
    }
    
    return profit
};
```

## 876. Middle of the Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var middleNode = function(head) {
    if (!head) return null
    
    let fast = head
    let slow = head
    
    while (fast && fast.next) {
        fast = fast.next.next
        slow = slow.next
    }
    return slow
};
```

## 206. Reverse Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null
    while (head) {
        const next = head.next
        head.next = prev
        prev = head
        head = next
    }
    
    return prev
};

// Recursive
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if (!head) return null
    if (!head.next) return head
    
    const node = reverseList(head.next)
    head.next.next = head
    head.next = null
    
    return node
};
```

## 237. Delete Node in a Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    node.val = node.next.val
    node.next = node.next.next
};
```

## 21. Merge Two Sorted Lists
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    const dummy = new ListNode(NaN)
    let current = dummy
    
    while (l1 && l2) {
        if (l1.val > l2.val) {
            current.next = l2
            l2 = l2.next
        } else {
            current.next = l1
            l1 = l1.next
        }
        current = current.next
    }
    
    current.next = l1 ? l1 : l2
    return dummy.next
};

// Recursive
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if (!l1) return l2
    if (!l2) return l1

    if (l1.val > l2.val) {
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
    } else {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    }
};
```

## 83. Remove Duplicates from Sorted List
```javascript
var deleteDuplicates = function(head) {
    if (!head || !head.next) return head
    
    let curr = head
    
    while (curr) {
        let runner = curr.next
        while (runner && runner.val == curr.val)
            runner = runner.next
        
        curr.next = runner
        curr = curr.next
    }
           
    return head
};
```

## 141. Linked List Cycle
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let fast = head
    let slow = head
    
    while (fast && fast.next) {
        fast = fast.next.next
        slow = slow.next
        
        if (fast === slow) {
            return true
        }
    }
    
    return false
};
```

## 234. Palindrome Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    if (!head || !head.next) return true
    
    const list1 = firstHalf(head)
    const list2 = reverse(list1.next)

    return equal(head, list2)
};

const equal = (list1, list2) => {
    while (list1 && list2) {
        if (list1.val !== list2.val)
            return false
        
        list1 = list1.next
        list2 = list2.next
    }
    
    return true
}

const reverse = head => {
    let curr = head
    let prev = null
    let next = null
    
    while (curr) {
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    }
    return prev
}

const firstHalf = head => {   
    let fast = head
    let slow = head
    
    while (fast.next && fast.next.next) {
        fast = fast.next.next
        slow = slow.next
    }
    return slow
}

// Recursive
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    const _isPalindrome = node => {
        if (!node) return true
        
        const result = _isPalindrome(node.next)
        
        if (result && head.val === node.val) {
            head = head.next
            return true
        } else {
            return false
        }
        
    }
    
    return _isPalindrome(head)
};
```

## 203. Remove Linked List Elements
```javascript
var removeElements = function(head, val) {
    if (!head) return head
    
    const dummy = new ListNode(NaN)
    dummy.next = head
    let curr = dummy
    
    while (curr.next) {
        if (curr.next.val === val) {
            curr.next = curr.next.next
            continue
        }
        curr = curr.next
    }
    
    return dummy.next
};
```

## 160. Intersection of Two Linked Lists
```javascript
// With Length
const count = list => {
    let count = 0
    
    while (list) {
        count++
        list = list.next
    }
    
    return count
}

var getIntersectionNode = function(headA, headB) {
    if (!headA || !headB) return null
    
    let headACount = count(headA)
    let headBCount = count(headB)
    let diff = Math.abs(headACount - headBCount)
    
    let largerList = headACount > headBCount ? headA : headB
    let shorterList = headACount > headBCount ? headB : headA

    while (diff) {
        largerList = largerList.next
        diff--
    }

    while (largerList && shorterList) {
        if (largerList === shorterList) return largerList
        
        largerList = largerList.next
        shorterList = shorterList.next
    }
    return null
};

// Without Length
var getIntersectionNode = function(headA, headB) {
    if (headA == null || headB == null) return null
    
    let a = headA
    let b = headB
    
    while (a !== b) {
        a = a ? a.next : headB
        b = b ? b.next : headA
    }
    return a
};
```

## 933. Number of Recent Calls
```javascript

var RecentCounter = function() {
    this.queue = []
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
    this.queue.push(t)

    while (this.queue.length && this.queue[0] < t - 3000) {
        this.queue.shift()
    }
    
    return this.queue.length
};

/** 
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
```

## 346. Moving Average from Data Stream
```javascript
/**
 * Initialize your data structure here.
 * @param {number} size
 */
var MovingAverage = function(size) {
    this.windowSize = size
    this.runningSum = 0
    this.window = new Queue()
};

/** 
 * @param {number} val
 * @return {number}
 */
MovingAverage.prototype.next = function(val) {
    this.window.enqueue(val)
    
    if (this.window.length() > this.windowSize) {
        this.runningSum -= this.window.dequeue()
    }
    
    this.runningSum += val
    return this.runningSum / this.window.length()
};

/** 
 * Your MovingAverage object will be instantiated and called as such:
 * var obj = new MovingAverage(size)
 * var param_1 = obj.next(val)
 */

class Queue {
    constructor() {
        this.leftStack = []
        this.rightStack = []
    }
    
    enqueue(val) {
        this.leftStack.push(val)
    }
    
    dequeue() {
        if (!this.rightStack.length) {
            while (this.leftStack.length) {
                this.rightStack.push(this.leftStack.pop())
            }
        }
        
        return this.rightStack.pop()
    }
    
    length() {
        return this.leftStack.length + this.rightStack.length
    }
}

/**
 * Initialize your data structure here.
 * @param {number} size
 */
var MovingAverage = function(size) {
    this.windowSize = size
    this.runningSum = 0
    this.window = new Queue()
};

/** 
 * @param {number} val
 * @return {number}
 */
MovingAverage.prototype.next = function(val) {
    this.window.enqueue(val)
    
    if (this.window.length() > this.windowSize) {
        this.runningSum -= this.window.dequeue()
    }
    
    this.runningSum += val
    return this.runningSum / this.window.length()
};

/** 
 * Your MovingAverage object will be instantiated and called as such:
 * var obj = new MovingAverage(size)
 * var param_1 = obj.next(val)
 */

class Queue {
    constructor() {
        this.elements = new LinkedList()
    }
    
    enqueue(val) {
        this.elements.push(val)
    }
    
    dequeue() {
        return this.elements.popHead().val
    }
    
    length() {
        return this.elements.length
    }
}

class LinkedList {
    constructor() {
        this.head = null
        this.tail = null
        this.length = 0
    }
    
    push(val) {
        const newNode = new Node(val)
        
        if (!this.head) {
            this.head = newNode
            this.tail = this.head
        } else {
            this.tail.next = newNode
            this.tail = this.tail.next
        }
        
        this.length++
    }
    
    popHead() {
        const node = this.head
        this.head = this.head.next
        
        if (!this.head) {
            this.tail = null
        }
        
        this.length--
        return node
    }
}

class Node {
    constructor(val) {
        this.val = val
        this.next = null
    }
}

/**
 * Initialize your data structure here.
 * @param {number} size
 */
var MovingAverage = function(size) {
    this.windowSize = size
    this.runningSum = 0
    this.window = new Queue(size)
};

/** 
 * @param {number} val
 * @return {number}
 */
MovingAverage.prototype.next = function(val) {
    if (this.window.length() >= this.windowSize) {
        this.runningSum -= this.window.dequeue()
    }
    
    this.window.enqueue(val)
    
    this.runningSum += val
    return this.runningSum / this.window.length()
};

/** 
 * Your MovingAverage object will be instantiated and called as such:
 * var obj = new MovingAverage(size)
 * var param_1 = obj.next(val)
 */

class Queue {
    constructor(size) {
        this.elements = new RingBuffer(size)
    }
    
    enqueue(val) {
        this.elements.insert(val)
    }
    
    dequeue() {
        return this.elements.remove()
    }
    
    length() {
        return this.elements.length()
    }
}

class RingBuffer {
    constructor(size) {
        this.elements = Array(size).fill(NaN)
        this.size = size
        this.writeIndex = 0
        this.readIndex = 0
    }
    
    insert(val) {
        if (this.canWrite()) {
            this.elements[this.writeIndex % this.size] = val
            this.writeIndex++
        }
    }
    
    remove() {
        if (this.canRead()) {
            const element = this.elements[this.readIndex % this.size]
            this.readIndex++
            return element
        } else {
            return null
        }
    }
    
    length() {
        return this.writeIndex - this.readIndex
    }
    
    canWrite() {
        return this.writeIndex - this.readIndex < this.size
    }
    
    canRead() {
        return this.readIndex < this.writeIndex
    }
}
```

## 1021. Remove Outermost Parentheses
```javascript
/**
 * @param {string} S
 * @return {string}
 */
var removeOuterParentheses = function(S) {
    const charArr = S.split('')
    const stack = []
    for (let i = 0; i < S.length; i++) {
        if (S[i] === '(') {
            stack.push(i)
            continue
        }
        
        const index = stack.pop()
        if (!stack.length) {
            charArr[index] = ''
            charArr[i] = ''
        }
    }
    
    return charArr.join('')
};
```

## 1047. Remove All Adjacent Duplicates In String
```javascript
/**
 * @param {string} S
 * @return {string}
 */
var removeDuplicates = function(S) {
    const stack = []
    
    for (const char of S) {
        if (stack.length && stack[stack.length - 1] === char) {
            stack.pop()
            continue
        }
        
        stack.push(char)
    }
    
    return stack.join('')
};
```

## 232. Implement Queue using Stacks
```javascript
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
    this.left = []
    this.right = []
};

/**
 * Push element x to the back of queue. 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.left.push(x)
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    if (!this.right.length) this.shift()
    return this.right.pop()
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    if (!this.right.length) this.shift()
    return this.right[this.right.length - 1]
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.left.length === 0 && this.right.length === 0
};

MyQueue.prototype.shift = function() {
    while (this.left.length) {
        this.right.push(this.left.pop())
    }
}

/** 
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

## 225. Implement Stack using Queues
```javascript
/**
 * Initialize your data structure here.
 */
var MyStack = function() {
    this.queueTop = []
    this.queueRest = []
};

/**
 * Push element x onto stack. 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {    
    this.queueTop.push(x)
    this._rebalance()
};

/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */
MyStack.prototype.pop = function() {
    const val = this.queueTop.shift()
    this._rebalance()
    return val
};

/**
 * Get the top element.
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queueTop[0]
};

/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return !this.queueTop.length && !this.queueRest.length
};

MyStack.prototype._rebalance = function() {
    if (this.queueTop.length === 0) {
        const temp = this.queueTop
        this.queueTop = this.queueRest
        this.queueRest = temp
    }
    
    while (this.queueTop.length > 1) {
        this.queueRest.push(this.queueTop.shift())
    }
}

/** 
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */

// Single Queue
/**
 * Initialize your data structure here.
 */
var MyStack = function() {
    this.queue = []
};

/**
 * Push element x onto stack. 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue.push(x)
    
    let size = this.queue.length
    while (size > 1) {
        this.queue.push(this.queue.shift())
        size--
    }
};

/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */
MyStack.prototype.pop = function() {
    return this.queue.shift()
};

/**
 * Get the top element.
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue[0]
};

/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return !this.queue.length
};

/** 
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

## 20. Valid Parentheses
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    const map = { '(': ')', '[': ']', '{': '}' }
    const stack = []
    
    for (const char of s) {
        if (map[char] !== undefined) {
            stack.push(char)
        } else {
            const top = stack.pop()
            const compliment = map[top]
            
            if (char !== compliment) {
                return false
            }
        }
    }
    
    return stack.length === 0
};
```

## 682. Baseball Game
```javascript
var calPoints = function(ops) {
    const stack = [0, 0]
    let result = 0
    
    for (const op of ops) {
        switch (op) {
            case '+':
                const sumVal = stack[stack.length - 1] + stack[stack.length - 2] 
                result += sumVal
                stack.push(sumVal)       
                break
            case 'C':
                const lastVal = stack.pop()
                result -= lastVal
                break
            case 'D':
                const doubleVal = stack[stack.length - 1] * 2
                result += doubleVal
                stack.push(doubleVal)
                break
            default:
                const val = +op
                result += val
                stack.push(val)
        }
    }
    
    return result
};
```

## 155. Min Stack
```javascript
/**
 * initialize your data structure here.
 */
var MinStack = function() {
    this.stack = []
    this.min = []
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    this.stack.push(val)
    
    if (!this.min.length || this.min[this.min.length - 1][0] > val) {
        this.min.push([val, 1])
    } else if (this.min[this.min.length - 1][0] === val) {
        this.min[this.min.length - 1][1]++
    }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    const [minVal, count] = this.min[this.min.length - 1]
    const val = this.stack.pop()
    
    if (minVal === val) {
        if (count - 1 === 0) {
            this.min.pop()
        } else {
            this.min[this.min.length - 1][1]--
        }
    }
    
    return val
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length - 1]
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.min[this.min.length - 1][0]
};

/** 
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

## 1086. High Five
```javascript
var highFive = function(items) {
    items.sort(([idA, scoreA], [idB, scoreB]) => {
        if (idA < idB) return -1
        if (idA > idB) return 1
        return scoreB - scoreA
    })
    
    const scores = items.reduce((result, [key, value]) => {
        if (!result[key]) {
            result[key] = [value]
            return result
        } else if (result[key].length < 5) {
            result[key].push(value)
        } 
        return result
    }, {})
    
    return Object.entries(scores).reduce((result, [key, value]) => {
        let sum = value.reduce((result, score) => result + score)
        result.push([key, Math.floor(sum / value.length)])
        return result
    }, []) 
};

// Counting Sort
/**
 * @param {number[][]} items
 * @return {number[][]}
 */
var highFive = function(items) {
    const map = {}
    
    for (const [id, score] of items) {
        if (!map[id]) map[id] = []
        map[id].push(score)
    }
    
    return Object.entries(map).map(pair => {
        const [id, scores] = pair
        const sortedScores = sort(scores)
        const avg = getAvg(sortedScores.slice(0, 5))
        return [id, avg]
    })
};

const getAvg = scores => {
    let sum = 0
    
    for (const score of scores) {
        sum += score
    }
    
    return Math.floor(sum / scores.length)
}

const sort = scores => {
    const buckets = Array(101).fill(0)
    
    for (const score of scores) {
        buckets[score]++
    }
    
    const result = []
    
    for (let i = buckets.length - 1; i >= 0; i--) {
        while (buckets[i]--) {
            result.push(i)
        }
    }
    
    return result
}

// Quick Select
/**
 * @param {number[][]} items
 * @return {number[][]}
 */
var highFive = function(items) {
    const ids = Array(1001).fill().map(a => [])
    for (const [id, score] of items) {
        ids[id].push(score)
    }
    
    const result = []
    
    for (let i = 1; i < ids.length; i++) {
        if (!ids[i].length) continue
        result.push([i, avgTopK(ids[i], 5)])
    }
    
    return result
};

const avgTopK = (nums, k) => {
    quickSelect(nums, k)
    
    let sum = 0
    for (let i = nums.length - k; i < nums.length; i++) {
        sum += nums[i]
    }
    
    return Math.floor(sum / k)
}

const quickSelect = (arr, k) => {
    const target = arr.length - k
    let left = 0
    let right = arr.length - 1
    
    while (left < right) {
        const randomIndex = random(left, right)
        const temp = arr[randomIndex]
        arr[randomIndex] = arr[right]
        arr[right] = temp
        
        const partitionIndex = partition(arr, left, right)
        if (partitionIndex === target) {
            return partitionIndex
        } else if (partitionIndex < target) {
            left = partitionIndex + 1
        } else {
            right = partitionIndex - 1
        }
    }
    
    return left
}

const random = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min
}

const partition = (arr, left, right) => {
    let i = left - 1
    
    for (let j = left; j < right; j++) {
        if (arr[j] <= arr[right]) {
            i++
            
            const temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
    }
    
    i++
    const temp = arr[i]
    arr[i] = arr[right]
    arr[right] = temp
    return i
}
```

## 349. Intersection of Two Arrays
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    const set1 = new Set(nums1)
    const set2 = new Set(nums2)
    
    const result = []
    for (const num of set1) {
        if (set2.has(num)) {
            result.push(num)
        }
    }
    
    return result
};
```

## 976. Largest Perimeter Triangle
```javascript
var largestPerimeter = function(A) {
    A.sort((a, b) => a - b)
    
    for (let i = A.length - 3; i >= 0; i--) {
        if (A[i] + A[i+1] > A[i+2]) return A[i] + A[i+1] + A[i+2]
    }
    return 0
};
```

## 242. Valid Anagram
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    const sCount = getCount(s)
    const tCount = getCount(t)
    return isEqual(sCount, tCount)
};

const getCount = s => {
    const counts = new Array(26).fill(0)
    for (const char of s) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        counts[index]++
    }
    return counts
}

const isEqual = (arr1, arr2) => {
    if (arr1.length !== arr2.length) {
        return false
    }
    
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false
        }
    }
    
    return true
}
```

## 252. Meeting Rooms
```javascript
/**
 * @param {number[][]} intervals
 * @return {boolean}
 */
var canAttendMeetings = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0])
    
    for (let i = 1; i < intervals.length; i++) {
        const [prevStart, prevEnd] = intervals[i - 1]
        const [currStart, currEnd] = intervals[i]
        
        if (currStart < prevEnd) {
            return false
        }
    }
    
    return true
};
```

## 350. Intersection of Two Arrays II
```javascript
// Hash Map Solution
const counts = arr => {
    return arr.reduce((result, num) => {
        result[num] = 1 + (result[num] || 0)
        return result
    }, {})
}

var intersect = function(nums1, nums2) {
    const long = nums1.length > nums2.length ? nums1 : nums2
    const short = nums1.length > nums2.length ? nums2 : nums1
    const shortCounts = counts(short)
    return long.filter(num => shortCounts[num]-- > 0)
};

// Sort Solution
var intersect = function(nums1, nums2) {
    nums1.sort((a, b) => a - b)
    nums2.sort((a, b) => a - b)
    
    let result = []
    let i = 0
    let j = 0
    
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] === nums2[j]) {
            result.push(nums1[i])
            i++
            j++
            continue
        }
        
        if (nums1[i] > nums2[j]) {
            j++
            continue
        }
        
        i++
    }
    return result
};

// Binary Search
const binarySearch = (arr, target, start) => {
    let left = start || 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid] < target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return arr[left] === target ? left : null
}

var intersect = function(nums1, nums2) {
    nums1.sort((a, b) => a - b)
    nums2.sort((a, b) => a - b)
    
    let result = []
    let start = 0
    
    for (let num of nums1) {
        let index = binarySearch(nums2, num, start)
        if (index !== null) {
            start = index + 1
            result.push(nums2[index])
        }
    }
    return result
};
```

## 344. Reverse String
```javascript
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    let left = 0
    let right = s.length - 1
    
    while (left < right) {
        const temp = s[left]
        s[left] = s[right]
        s[right] = temp
        
        left++
        right--
    }
};
```

## 167. Two Sum II - Input array is sorted
```javascript
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    let left = 0
    let right = numbers.length - 1
    
    while (left < right) {
        const sum = numbers[left] + numbers[right]
        
        if (sum === target) {
            return [left + 1, right + 1]
        }
        
        if (sum < target) {
            left++
        } else {
            right--
        }
    }
};
```

## 925. Long Pressed Name
```javascript
/**
 * @param {string} name
 * @param {string} typed
 * @return {boolean}
 */
var isLongPressedName = function(name, typed) {
    let i = 0
    
    for (let j = 0; j < typed.length; j++) {
        if (typed[j] === name[i]) {
            i++
        } else if (typed[j] !== name[i - 1]){
            return false
        }
    }
    return i === name.length
};
```

## 345. Reverse Vowels of a String
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
    const charArr = s.split('')
    
    let left = 0
    let right = s.length - 1
    
    while (left < right) {
        if (!isVowel(charArr[left])) {
            left++
            continue
        }
        
        if (!isVowel(charArr[right])) {
            right--
            continue
        }
        
        swap(charArr, left, right)
        left++
        right--
    }
    
    return charArr.join('')
};

const isVowel = char => {
    const vowels = new Set('aeiou')
    return vowels.has(char.toLowerCase())
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 88. Merge Sorted Array
```javascript
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let write = nums1.length - 1
    let read1 = m - 1
    let read2 = n - 1
    
    while (read2 >= 0) {
        if (nums1[read1] > nums2[read2]) {
            nums1[write--] = nums1[read1--]
        } else {
            nums1[write--] = nums2[read2--]
        }
    }
};
```

## 28. Implement strStr()
```javascript
// KMP
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    return kmp(haystack, needle)
};

const kmp = (string, pattern) => {
    if (!pattern.length) return 0
    if (!string.length) return -1
    
    const lpsTable = getLPSTable(pattern)
    
    let sIndex = 0
    let pIndex = 0
    while (sIndex < string.length) {
        if (string[sIndex] === pattern[pIndex]) {
            sIndex++
            pIndex++
            
            if (pIndex === pattern.length) {
                return sIndex - pattern.length
            }
            
            continue
        }
        
        if (pIndex === 0) {
            sIndex++
            continue
        }
        
        pIndex = lpsTable[pIndex - 1]
    }
    
    return -1
}

const getLPSTable = pattern => {
    const lpsTable = new Array(pattern.length).fill(0)
    let len = 0
    let i = 1
    
    while (i < pattern.length) {
        if (pattern[len] === pattern[i]) {
            lpsTable[i] = len + 1
            len++
            i++
            continue
        }
        
        if (len === 0) {
            i++
            continue
        }
        
        len = lpsTable[len - 1]
    }
    
    return lpsTable
}

// Rabin-Karp
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (!needle.length) return 0
    return rkSearch(haystack, needle)
};

var rkSearch = function (text, pattern) {
    if (text.length === 0 || pattern.length === 0 || text.length < pattern.length)
        return -1

    const base = 256
    const prime = 101

    let textHash = 0
    let patternHash = 0
    
    let baseToMaxPow = 1
    for (let i = 0; i < pattern.length - 1; i++) {
        baseToMaxPow = (baseToMaxPow * base) % prime
    }
    
    for (let i = 0; i < pattern.length; i++) {
        patternHash *= base
        patternHash += pattern[i].charCodeAt(0)
        patternHash %= prime
        
        textHash *= base
        textHash += text[i].charCodeAt(0)
        textHash %= prime
    }
    
    for (let i = 0; i <= text.length - pattern.length; i++) {
        if (textHash === patternHash && text.substring(i, i + pattern.length) === pattern) {
            return i
        }
        
        if (i < text.length - pattern.length) {
            const prevCode = text[i].charCodeAt(0)
            const nextCode = text[i + pattern.length].charCodeAt(0)
            
            textHash -= prevCode * baseToMaxPow
            textHash %= prime
            
            textHash *= base
            textHash %= prime
            
            textHash += nextCode
            textHash %= prime
            
            if (textHash < 0) textHash += prime 
        }
    }
    
    return -1
}
```

## 125. Valid Palindrome
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    let left = 0
    let right = s.length - 1
    
    while (left < right) {
        const leftChar = s[left]
        const rightChar = s[right]
        
        if (!isAlphaNum(leftChar)) {
            left++
            continue
        }
        
        if (!isAlphaNum(rightChar)) {
            right--
            continue
        }
        
        if (leftChar.toLowerCase() !== rightChar.toLowerCase()) {
            return false
        }
        
        left++
        right--
    }
    
    return true
};

const isAlphaNum = char => {
    // lowercase
    if ('a' <= char && char <= 'z') {
        return true
    }
    
    // upper case
    if ('A' <= char && char <= 'Z') {
        return true
    }
    
    // num
    if ('0' <= char && char <= '9') {
        return true
    }
    
    return false
}
```

## 704. Binary Search
```javascript
// Iterative
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0
    let right = nums.length - 1
    
    while (left <= right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        if (nums[mid] === target) {
            return mid
        }
        
        if (nums[mid] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1
};

// Recursive
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    const _search = (left, right) => {
        if (left > right) return -1
        
        const mid = Math.floor((right - left) / 2) + left
        
        if (nums[mid] === target) {
            return mid
        } else if (nums[mid] < target) {
            return _search(mid + 1, right)
        } else {
            return _search(left, mid - 1)
        }
    }
    
    return _search(0, nums.length - 1)
};
```

## 69. Sqrt(x)
```javascript
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    let left = 0
    let right = Math.ceil(x / 2)
    
    while (left < right) {
        const mid = Math.trunc((right - left + 1) / 2) + left
        const squared = mid ** 2
        
        if (squared > x) {
            right = mid - 1
        } else {
            left = mid
        }
    }
    
    return left
};
```

## 367. Valid Perfect Square
```javascript
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
    const squareRoot = num ** 0.5
    return Math.round(squareRoot) === squareRoot
};

/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
    let left = 1
    let right = Math.ceil(num / 2)
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        const squared = mid * mid
        if (squared === num) {
            return true
        } else if (squared < num) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return false
};
```

## 278. First Bad Version
```javascript
var solution = function(isBadVersion) {
    return function(n) {
        let left = 0
        let right = n
        
        while (left < right) {
            let mid = Math.floor((right - left) / 2) + left
            
            if (isBadVersion(mid)) {
                right = mid
            } else {
                left = mid + 1
            }
            
            
        }
        return left
    };
};
```

## 441. Arranging Coins
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var arrangeCoins = function(n) {
    let left = 0
    let right = n
    
    while (left < right) {
        const mid = Math.trunc((right - left + 1) / 2) + left
        
        const coins = (mid * (mid + 1)) / 2
        if (coins === n) {
            return mid
        }
        
        if (coins < n) {
            left = mid
        } else {
            right = mid - 1
        }
    }
    
    return left
};
```

## 744. Find Smallest Letter Greater Than Target
```javascript
var nextGreatestLetter = function(letters, target) {
    let left = 0
    let right = letters.length
    
    while (left < right) {
        let mid = Math.floor((right - left) / 2) + left
        
        if (letters[mid] > target) {
            right = mid
        } else {
            left = mid + 1
        }
    }
    
    return letters[left % letters.length]
};
```

## 270. Closest Binary Search Tree Value
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {number}
 */
var closestValue = function(root, target) {
    let closest = root.val
    
    while (root) {
        if (Math.abs(closest - target) > Math.abs(root.val - target)) {
            closest = root.val
        }
        
        if (root.val === target) {
            return root.val
        } else if (root.val < target) {
            root = root.right
        } else {
            root = root.left
        }
    }
    
    return closest
};
```

## 852. Peak Index in a Mountain Array
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var peakIndexInMountainArray = function(arr) {
    let left = 1
    let right = arr.length - 2
    
    while (left < right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        if (arr[mid] < arr[mid + 1]) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left
};
```

## 392. Is Subsequence
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    if (!s.length) return true
    if (!t.length) return false
    
    let i = 0
    let j = 0
    
    while (i < s.length && j < t.length) {
        if (s[i] === t[j]) {
            i++
            j++
            continue
        }
        
        j++
    }
    
    return i >= s.length
};

// Follow Up
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
const binarySearch = (arr, target) => {
  let left = 0
  let right = arr.length - 1
  
  while (left < right) {
    let mid = Math.floor((right - left) / 2) + left
    
    if (arr[mid] <= target) {
      left = mid + 1
    } else {
      right = mid
    }
  }
  return arr[left]
}

const indexMap = str => {
    return str.split('').reduce((result, char, i) => {
        if (result[char]) {
            result[char].push(i)
        } else {
            result[char] = [i]
        }
        return result
    }, {})
}

var isSubsequence = function(s, t) {
    const map = indexMap(t)
    
    let lastIndex = -1
    for (let i = 0; i < s.length; i++) {
        if (!map[s[i]]) return false
        
        let currIndex = binarySearch(map[s[i]], lastIndex)
        if (lastIndex >= currIndex) return false  
        lastIndex = currIndex
    }
    return true
};
```

## 1176. Diet Plan Performance
```javascript
const assignPoint = (calories, lower, upper) => {
    if (calories < lower) return -1
    if (calories > upper) return 1
    return 0
}

var dietPlanPerformance = function(calories, k, lower, upper) {
    let total = 0
    let sum = 0
    
    for (let i = 0; i < k; i++) sum += calories[i]
    total += assignPoint(sum, lower, upper)
    
    for (let j = k; j < calories.length; j++) {
        sum += calories[j]
        sum -= calories[j - k]
        total += assignPoint(sum, lower, upper)
    }
    return total
};
```

## 1064. Fixed Point
```javascript
// Linear Scan
var fixedPoint = function(A) {
    if (!A.length) return -1
    
    for (let i = 0; i < A.length; i++) {
        if (A[i] === i) return i
    }
    
    return -1
};

// Binary Search
var fixedPoint = function(A) {
    if (!A.length) return -1
    
    let left = 0
    let right = A.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (A[mid] < mid) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left === A[left] ? left : -1
};
```

## 693. Binary Number with Alternating Bits
```javascript
var hasAlternatingBits = function(n) {
    let curr = n & 1
    n >>= 1
    
    while (n) {
        if ((n & 1) === curr) return false
        curr = n & 1
        n >>= 1
    }
    return true
};
```

## 461. Hamming Distance
```javascript
var hammingDistance = function(x, y) {
    let diff = x ^ y
    let count = 0
    while (diff) {
        count++
        diff &= (diff - 1)
    }
    return count
};
```

## 476. Number Complement
```javascript
var findComplement = function(num) {
    let result = 0
    let pos = 0
    
    while (num) {
        const bit = num & 1
        result |= (!bit << pos++)
        num >>= 1
    }
    
    return result
};
```

## 136. Single Number
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let result = 0
    for (let num of nums) result ^= num
    return result
};
```

## 762. Prime Number of Set Bits in Binary Representation
```javascript
/**
 * @param {number} L
 * @param {number} R
 * @return {number}
 */

const bitMemo = {}
const primeMemo = {}

var countPrimeSetBits = function(L, R) {
    let count = 0
    
    for (let num = L; num <= R; num++) {
        const countOfSetBits = getCount(num)
        count += isPrime(countOfSetBits)
    }
    
    return count
};

const isPrime = num => {
    if (primeMemo[num]) return primeMemo[num]
    
    if (num === 1) return false
    
    for (let i = 2; i <= Math.sqrt(num); i++) {
        if (num % i === 0) {
            primeMemo[num] = false
            return primeMemo[num]
        }
    }
    
    primeMemo[num] = true
    return primeMemo[num]
}

const getCount = num => {
    if (bitMemo[num] !== undefined) 
        return bitMemo[num]
    
    let count = 0
    
    while (num) {
        num &= (num - 1)
        count++
    }
    
    bitMemo[num] = count
    return bitMemo[num]
}
```

## 389. Find the Difference
```javascript
var findTheDifference = function(s, t) {
    let result = 0
    
    for (let i of s) result ^= i.charCodeAt(0)
    for (let j of t) result ^= j.charCodeAt(0)
    
    return String.fromCharCode(result)
};
```

## 191. Number of 1 Bits
```javascript
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let count = 0
    while (n) {
        n &= (n - 1)
        count++
    }
    return count
};
```

## 405. Convert a Number to Hexadecimal
```javascript
var toHex = function(num) {
    if (num === 0) return "0"
    
    let map = '0123456789abcdef'
    let result = ''
    
    while (num) {
        result = map[(num & 15)] + result
        num >>>= 4
    }
    
    return result
};
```

## 342. Power of Four
```javascript
/**
 * @param {number} num
 * @return {boolean}
 */
var isPowerOfFour = function(num) {
    if (num < 1) return false
    return (num & (num - 1)) === 0 && (num & 0x55555555) === num
};

/**
 * @param {number} num
 * @return {boolean}
 */
var isPowerOfFour = function(num) {
    let count = 0
    
    while (num > 0) {
        const digit = num % 4
        count += digit
        num = Math.floor(num / 4)
    }
    
    return count === 1
};

/**
 * @param {number} num
 * @return {boolean}
 */
var isPowerOfFour = function(num) {
    if (num === 0) return false
    const log = Math.round(Math.log(num) / Math.log(4))
    return 4 ** log === num
};
```

## 190. Reverse Bits
```javascript
var reverseBits = function(n) {
    let result = 0
    for (let i = 0; i < 32; i++) {
        result <<= 1
        result |= (n & 1)
        n >>= 1
    }
    return result >>> 0
};
```

## 1119. Remove Vowels from a String
```javascript
// RegEx
var removeVowels = function(S) {
    return S.replace(/[aeiou]/g, "")
};

// Set
var removeVowels = function(S) {
    let vowels = new Set(['a', 'e', 'i', 'o', 'u'])
    return [...S]
            .filter(char => !vowels.has(char))
            .join('')
};
```

## 1108. Defanging an IP Address
```javascript
// RegEx
var defangIPaddr = function(address) {
    return address.replace(/\./g, '[.]')
};

// Reduce
var defangIPaddr = function(address) {
    return [...address].reduce((result, char) => {
        char === '.' ? result.push('[.]') : result.push(char)
        return result
    }, []).join('')
};

// Map
var defangIPaddr = function(address) {
    return address.split('').map(char => {
        return char === '.' ? '[.]' : char
    }).join('')
};
```

## 804. Unique Morse Code Words
```javascript
/**
 * @param {string[]} words
 * @return {number}
 */
var uniqueMorseRepresentations = function(words) {
    const set = new Set()
    
    for (const word of words) {
        set.add(getMorseCode(word))
    }
    
    return set.size
};

const getMorseCode = word => {
    const map = [".-","-...","-.-.","-..",".","..-.","--.","....",
                 "..",".---","-.-",".-..","--","-.","---",".--.",
                 "--.-",".-.","...","-","..-","...-",".--","-..-",
                 "-.--","--.."]
    const result = []
    
    for (const char of word) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        result.push(map[index])
    }
    
    return result.join('')
}
```

## 657. Robot Return to Origin
```javascript
/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
    const pos = [0, 0]
    
    for (const dir of moves) {
        switch (dir) {
            case 'U':
                pos[0] += 1
                break
            case 'D':
                pos[0] -= 1
                break
            case 'L':
                pos[1] -= 1
                break
            case 'R':
                pos[1] += 1
                break
        }
    }
    
    return pos[0] === 0 && pos[1] === 0
};
```

## 929. Unique Email Addresses
```javascript
/**
 * @param {string[]} emails
 * @return {number}
 */
var numUniqueEmails = function(emails) {
    const unique = new Set()
    
    for (const email of emails) {
        const formattedEmail = format(email)
        unique.add(formattedEmail)
    }
    
    return unique.size
};

const format = email => {
    const [local, domain] = email.split('@')
    const formattedLocal = []
    
    for (const char of local) {
        if (char === '.') continue
        if (char === '+') break
        formattedLocal.push(char)
    }

    return [formattedLocal.join(''), domain].join('@')
}
```

## 557. Reverse Words in a String III
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    const charArr = s.split('')
    let start = 0
    for (let end = 0; end <= s.length; end++) {
        if (s[end] === ' ' || end === s.length) {
            reverse(charArr, start, end - 1)
            start = end + 1
        }
    }
    
    return charArr.join('')
};

const reverse = (arr, i, j) => {
    while (i < j) {
        const temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
        i++
        j--
    }
}
```

## 344. Reverse String
```javascript
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
const swap = (arr, i, j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

var reverseString = function(s) {
    if (!s.length) return
    
    let left = 0
    let right = s.length - 1
    
    while (left < right) {
        swap(s, left, right)
        left++
        right--
    }
};
```

## 709. To Lower Case
```javascript
/**
 * @param {string} str
 * @return {string}
 */
var toLowerCase = function(str) {
    let result = []
    for (let char of str) {
        const code = char.charCodeAt(0)
        if (code >= 'A'.charCodeAt(0) && code <= 'Z'.charCodeAt(0)) {
            result.push(String.fromCharCode(code + 32))
            continue
        }
        result.push(char)
    }
    return result.join('')
};

/**
 * @param {string} str
 * @return {string}
 */
var toLowerCase = function(str) {
    const result = []
    
    for (const char of str) {
        if (char < 'A' || char > 'Z') {
            result.push(char)
            continue
        }
        
        const pos = char.charCodeAt(0) - 'A'.charCodeAt(0)
        const code = pos + 'a'.charCodeAt(0)
        result.push(String.fromCharCode(code))
    }
    
    return result.join('')
};
```

## 977. Squares of a Sorted Array
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    const result = new Array(nums.length)
    
    let left = 0
    let right = nums.length - 1
    
    for (let i = nums.length - 1; i >= 0; i--) {
        const leftSquared = nums[left] ** 2
        const rightSquared = nums[right] ** 2
        
        if (leftSquared < rightSquared) {
            result[i] = rightSquared
            right--
        } else {
            result[i] = leftSquared
            left++
        }
    }
    
    return result
};
```

## 844. Backspace String Compare
```javascript
var backspaceCompare = function(S, T) {
    let sSkips = 0
    let tSkips = 0
    
    let sIndex = S.length - 1
    let tIndex = T.length - 1
    
    while (sIndex >= 0 || tIndex >= 0) {
        if (S[sIndex] === '#') {
            sSkips++
            sIndex--
            continue
        }
        
        if (T[tIndex] === '#') {
            tSkips++
            tIndex--
            continue
        }
        
        if (sSkips > 0) {
            sSkips--
            sIndex--
            continue
        }
        
        if (tSkips > 0) {
            tSkips--
            tIndex--
            continue
        }
        
        if (S[sIndex] !== T[tIndex]) return false
        
        sIndex--
        tIndex--
    }
    return true
};
```

## 1085. Sum of Digits in the Minimum Number
```javascript
var sumOfDigits = function(A) {
    let min = Math.min(...A)
    let sum = 0
    while (min) {
        sum += min % 10
        min = Math.floor(min / 10)
    }
    
    return sum & 1 ? 0 : 1
};
```

## 832. Flipping an Image
```javascript
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    for (let row = 0; row < A.length; row++) {
        reverse(A[row])
    }
    
    return A
};

const reverse = arr => {
    let i = 0
    let j = arr.length - 1
    
    while (i < j) {
        if (arr[i] === arr[j]) {
            arr[i] ^= 1
            arr[j] ^= 1
        }
        
        i++
        j--
    }
    
    if (i === j) {
        arr[i] ^= 1
    }
}
```

## 905. Sort Array By Parity
```javascript
// Linear Time and Space
const isEven = num => (num & 1) === 0

var sortArrayByParity = function(A) {
    const evens = []
    const odds = []
    for (let a of A) isEven(a) ? evens.push(a) : odds.push(a)
    return evens.concat(odds)
};

// Two Pointers
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParity = function(A) {
    let i = 0
    let j = A.length - 1
    
    while (i < j) {
        while (i < j && isEven(A[i])) {
            i++
        }
        
        while (j > i && !isEven(A[j])) {
            j--
        }
        
        swap(A, i, j)
        i++
        j--
    }
    
    return A
};

const isEven = num => num % 2 === 0

const swap = (A, i, j) => {
    const temp = A[i]
    A[i] = A[j]
    A[j] = temp
}
```

## 561. Array Partition I
```javascript
var arrayPairSum = function(nums) {
  const arr = Array(20001).fill(0)
  const lim = 10000
  for (let num of nums) arr[num + lim]++
  
  const sortedArr = []
  for (let i = 0; i < arr.length; i++) {
    while (arr[i] > 0) {
      sortedArr.push(i - lim)
      arr[i]--
    }
  }
  
  let sum = 0
  for (let i = 0; i < sortedArr.length; i += 2) {
    sum += sortedArr[i]
  }
  return sum  
};
```

## 1160. Find Words That Can Be Formed by Characters
```javascript
const counts = str => {
    return str.split('').reduce((result, char) => {
        result[char] = 1 + (result[char] || 0)
        return result
    }, {})
}

var countCharacters = function(words, chars) {
    const charsCounts = counts(chars)
    
    let sum = 0
    for (let word of words) {
        let wordCount = counts(word)
        let valid = true
        for (let [char, count] of Object.entries(wordCount)) {
            if (!charsCounts[char] || charsCounts[char] < count) {
                valid = !valid
                break
            }   
        }
        if (valid) sum += word.length
    }
    
    return sum
};

/**
 * @param {string[]} words
 * @param {string} chars
 * @return {number}
 */
var countCharacters = function(words, chars) {
    const map = {}
    for (const char of chars) {
        map[char] = 1 + (map[char] || 0)
    }
    
    let sum = 0
    
    outer : for (const word of words) {
        const wordMap = {}
        for (const char of word) {
            wordMap[char] = 1 + (wordMap[char] || 0)
            
            if (!map[char] || wordMap[char] > map[char]) 
                continue outer
        }
        
        sum += word.length
    }
    
    return sum
};
```

## 1133. Largest Unique Number
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var largestUniqueNumber = function(A) {
    const buckets = Array(1001).fill(0)
    
    for (const a of A) {
        buckets[a]++
    }
    
    for (let num = buckets.length - 1; num >= 0; num--) {
        if (buckets[num] !== 1) continue
        
        return num
    }
    
    return -1
};
```

## 509. Fibonacci Number
```javascript
// Recursion
var fib = function(N) {
    if (N < 2) return N
    return fib(N - 1) + fib(N - 2)
};

// Recursion + Memo
var fib = function(N, memo = {}) {
    if (N < 2) return N
    if (memo[N]) return memo[N]
    
    memo[N] = fib(N - 1, memo) + fib(N - 2, memo)
    return memo[N]
};

// DP O(n) Space
var fib = function(N) {
    const dp = Array(N + 1).fill()
    dp[0] = 0
    dp[1] = 1
    
    for (let i = 2; i < dp.length; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    
    return dp[N]
};

// DP O(1) Space
var fib = function(N) {
    if (N <= 1) return N
    
    let fibs = [0, 1]
    
    for (let i = 2; i <= N; i++) {
        fibs = [fibs[1], fibs[0] + fibs[1]]
    }
    return fibs[1]
};
```

## 867. Transpose Matrix
```javascript
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var transpose = function(A) {
    const rowLen = A.length
    const colLen = A[0].length
    
    const matrix = Array(colLen).fill().map(a => Array(rowLen).fill())
    
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            matrix[col][row] = A[row][col]
        }
    }
    
    return matrix
};
```

## 985. Sum of Even Numbers After Queries
```javascript
const isEven = num => (num & 1) === 0

const sumOfEvens = nums => {
    return nums.reduce((result, num) => isEven(num) ? result + num : result, 0)
}

var sumEvenAfterQueries = function(A, queries) {
    if (!A.length || !queries.length) return []
    
    const result = []
    
    let sum = sumOfEvens(A)
    for (let [val, index] of queries) {
        if (isEven(A[index])) sum -= A[index]
        A[index] += val
        if (isEven(A[index])) sum += A[index]
        result.push(sum)
    }
    return result
};
```

## 1013. Partition Array Into Three Parts With Equal Sum
```javascript
/**
 * @param {number[]} A
 * @return {boolean}
 */
var canThreePartsEqualSum = function(A) {
    const sum = A.reduce((result, num) => result + num, 0)
    if (sum % 3 !== 0) return false
    
    let count = 0
    let currSum = 0
    for (const a of A) {
        currSum += a
        if (currSum === sum / 3) {
            currSum = 0
            count++
        }
    }
    
    return count >= 3
};
```

## 896. Monotonic Array
```javascript
var isMonotonic = function(A) {
  let increasing = true
  let decreasing = true

  for (let i = 0; i < A.length; i++) {
    if (A[i] === A[i + 1]) continue
    if (A[i] > A[i + 1]) increasing = false
    if (A[i] < A[i + 1]) decreasing = false
  }

  return increasing || decreasing;
};
```

## 414. Third Maximum Number
```javascript
var thirdMax = function(nums) {
    let max1 = -Number.MAX_VALUE
    let max2 = -Number.MAX_VALUE
    let max3 = -Number.MAX_VALUE
    
    for (const num of nums) {
        if (num === max1) continue
        if (num > max1) {
            max3 = max2
            max2 = max1
            max1 = num
            continue
        }
        
        if (num === max2) continue
        if (num > max2) {
            max3 = max2
            max2 = num
            continue
        }
        
        if (num > max3) {
            max3 = num
            continue
        }
    }
    
    return max3 !== -Number.MAX_VALUE ? max3 : max1
};
```

## 119. Pascal's Triangle II
```javascript
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let prevRow = [1]
    
    for (let i = 1; i <= rowIndex; i++) {
        const currRow = [1]
        
        for (let j = 1; j < prevRow.length; j++) {
            currRow.push(prevRow[j - 1] + prevRow[j])
        }
        
        currRow.push(1)
        prevRow = currRow
    }
    
    return prevRow
};
```

## 167. Two Sum II - Input array is sorted
```javascript
var twoSum = function(numbers, target) {
    let left = 0
    let right = numbers.length - 1
    
    while (left < right) {
        let sum = numbers[left] + numbers[right]
        
        if (sum === target) return [left + 1, right + 1]
        
        if (sum > target) {
            right--
        } else {
            left++
        }
    }
    return []
};
```

## 717. 1-bit and 2-bit Characters
```javascript
/**
 * @param {number[]} bits
 * @return {boolean}
 */
var isOneBitCharacter = function(bits) {
    let i = 0
    while (i < bits.length - 1) {
        i += bits[i] + 1
    }
    return i === bits.length - 1
};

/**
 * @param {number[]} bits
 * @return {boolean}
 */
var isOneBitCharacter = function(bits) {
    if (bits.length === 1 || bits[bits.length - 2] === 0) 
        return true
    
    let i = 0
    while (i < bits.length) {
        if (bits[i] === 1) {
            i += 2
            continue
        }
        
        if (i === bits.length - 1)
            return true
        
        i++
    }
    
    return false
};
```

## 1. Two Sum
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const map = {}
    
    for (let i = 0; i < nums.length; i++) {
        const diff = target - nums[i]
        
        if (map[diff] !== undefined) {
            return [map[diff], i]
        }
        
        map[nums[i]] = i
    }
};
```

## 989. Add to Array-Form of Integer
```javascript
var addToArrayForm = function(A, K) {
    let carry = K
    let result = []
    
    for (let i = A.length - 1; i >= 0; i--) {
        let sum = A[i] + carry
        carry = Math.floor(sum / 10)
        result.push(sum % 10)
    }
    
    while (carry) {
        result.push(carry % 10)
        carry = Math.floor(carry / 10)
    }
    
    return result.reverse()
};
```

## 189. Rotate Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
    k %= nums.length
    
    reverse(nums, 0, nums.length - 1)
    reverse(nums, 0, k - 1)
    reverse(nums, k, nums.length - 1)
};

const reverse = (arr, left, right) => {
    while (left < right) {
        swap(arr, left, right)
        
        left++
        right--
    }
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 605. Can Place Flowers
```javascript
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
    let count = 0
    
    for (let i = 0; i < flowerbed.length && count < n; i++) {
        if (flowerbed[i] === 1 || 
            flowerbed[i - 1] === 1 || 
            flowerbed[i + 1] === 1) {
            continue
        }
        
        flowerbed[i] = 1
        count++
    }
    
    return count === n
};
```

## 219. Contains Duplicate II
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    const map = {}
    
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i]
        if (map[num] === undefined) {
            map[num] = i
            continue
        }
        
        const j = map[num]
        if (i - j <= k) {
            return true
        }
        
        map[num] = i
    }
    
    return false
};
```

## 914. X of a Kind in a Deck of Cards
```javascript
const gcd = (a, b) => {
    return a === 0 ? b : gcd(b % a, a)
}
var hasGroupsSizeX = function(deck) {
    const counts = deck.reduce((result, card) => {
        result[card] = 1 + (result[card] || 0)
        return result
    }, {})
    
    let g = 0
    for (const value of Object.values(counts)) {
       g = gcd(g, value)
    }
    return g >= 2
};
```

## 941. Valid Mountain Array
```javascript
var validMountainArray = function(A) {
    if (A.length < 3) return false
    
    let i = 0
    while (i+1 < A.length && A[i] < A[i+1]) i++
    
    if (i === 0 || i === A.length - 1) return false
    
    while (i+1 < A.length && A[i] > A[i+1]) i++    
    return i === A.length - 1
};
```

## 697. Degree of an Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findShortestSubArray = function(nums) {
    const map = {}
    let degree = 0
    
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i]
        if (!map[num]) map[num] = [0, i, i]
        map[num][0]++
        map[num][2] = i
        
        degree = Math.max(degree, map[num][0])
    }
    
    let length = Infinity
    for (const [count, start, end] of Object.values(map)) {
        if (count === degree) {
            length = Math.min(length, end - start + 1)
        }
    }
    
    return length
};
```

## 532. K-diff Pairs in an Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findPairs = function(nums, k) {
    if (k < 0) return 0

    const counts = nums.reduce((result, num) => {
        result[num] = 1 + (result[num] || 0)
        return result
    }, {})

    let pairs = 0
    for (const [num, count] of Object.entries(counts)) {
        if (k === 0) {
            if (count >= 2) pairs++
        } else if (counts[+num + k]) {
            pairs++
        }
    }

    return pairs
};
```

## 1185. Day of the Week
```javascript
/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    const days = daysFrom1971(day, month, year)
    const week = ["Thursday", "Friday", "Saturday", "Sunday", "Monday", "Tuesday", "Wednesday"]
    return week[days % 7]
};

const isLeapYear = y => y % 4 === 0 && y % 100 !== 0 || y % 400 === 0

const daysFrom1971 = (d, m, y) => {
    const daysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    let days = 0
    
    for (let currY = 1971; currY < y; currY++) {
        days += isLeapYear(currY) ? 366 : 365    
    }
    
    for (let currM = 1; currM < m; currM++) {
        days += daysOfMonth[currM - 1]
        
        if (isLeapYear(y) && currM === 2)
            days++
    }
    
    return days + d
}
```

## 498. Diagonal Traverse
```javascript
var findDiagonalOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length) return []
    const m = matrix.length
    const n = matrix[0].length
    
    let r = 0
    let c = 0
    const result = []
    
    for (let i = 0; i < m*n; i++) {
        result.push(matrix[r][c])
        
        if ((r + c) % 2 === 0) {
            // going up
            if (c === n - 1) {
                r++
            } else if (r === 0) {
                c++
            } else {
                r--
                c++
            }
        } else {
            // going down
            if (r === m - 1) {
                c++
            } else if (c === 0) {
                r++
            } else {
                r++
                c--
            }
        }
    }
    return result
};
```

## 54. Spiral Matrix
```javascript
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    const m = matrix.length
    const n = matrix[0].length
    
    const result = []
    
    let top = 0
    let bottom = m - 1
    let left = 0
    let right = n - 1
    
    while (true) {
        // top
        for (let col = left; col <= right; col++) {
            result.push(matrix[top][col])
        }
        top++
        
        if (top > bottom) break
        
        // right
        for (let row = top; row <= bottom; row++) {
            result.push(matrix[row][right])
        }
        right--
        
        if (left > right) break
        
        // bottom
        for (let col = right; col >= left; col--) {
            result.push(matrix[bottom][col])
        }
        bottom--
                
        if (top > bottom) break
        
        // left
        for (let row = bottom; row >= top; row--) {
            result.push(matrix[row][left])
        }
        left++
        
        if (left > right) break
    }
    
    return result
};
```

## 67. Add Binary
```javascript
var addBinary = function(a, b) {
    let i = a.length - 1
    let j = b.length - 1
    const result = []
    let carry = 0
    
    while (i >= 0 || j >= 0) {
        let iBin = a[i] ? +a[i] : 0
        let jBin = b[j] ? +b[j] : 0
        
        let sum = iBin + jBin + carry
        carry = Math.floor(sum / 2)
        result.push(sum % 2)
        
        i--
        j--
    }
    
    if (carry > 0) result.push(carry)
    return result.reverse().join('')
};
```

## 14. Longest Common Prefix
```javascript
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (!strs.length) return ''
    
    const commonPrefix = []
    
    let index = 0
    outer : while (true) {
        const char = strs[0][index]
        if (char === undefined) {
            break outer
        }
        
        for (let j = 1; j < strs.length; j++) {
            if (strs[j][index] === undefined || strs[j][index] !== char) { 
                break outer
            }
        }
        
        commonPrefix.push(char)
        index++
    }
    
    return commonPrefix.join('')
};
```

## 209. Minimum Size Subarray Sum
```javascript
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
    let min = Infinity
    let sum = 0
    let left = 0
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right]
        
        while (sum >= target) {
            if (sum >= target) {
                min = Math.min(min, right - left + 1)
            }
            
            sum -= nums[left]
            left++
        }
    }
    
    return min === Infinity ? 0 : min
};
```

## 151. Reverse Words in a String
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    const wordArr = s.split(' ')
    wordArr.reverse()
    
    const result = []
    for (const word of wordArr) {
        if (word === '') continue
        result.push(word)
    }
    
    return result.join(' ')
};
```

## 559. Maximum Depth of N-ary Tree
```javascript
// DFS Iterative
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (!root) return 0
    
    const stack = [root]
    const seen = new Set()
    seen.add(root)
    let maxDepth = 1
    
    outer : while (stack.length) {
        let curr = stack[stack.length - 1]
        for (let child of curr.children) {
            if (!seen.has(child)) {
                stack.push(child)
                seen.add(child)
                maxDepth = Math.max(stack.length, maxDepth)
                continue outer
            }
        }
        stack.pop()
    }
    
    return maxDepth
};

// DFS Recursive
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (!root) return 0
    
    let depth = 1
    
    for (const child of root.children) {
        depth = Math.max(depth, maxDepth(child) + 1)
    }
    
    return depth
};

// BFS
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (!root) return 0
    
    let level = 0
    const queue = [root]
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            for (const child of node.children) {
                queue.push(child)
            }
        }
        level++
    }
    
    return level
};
```

## 429. N-ary Tree Level Order Traversal
```javascript
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return []
    
    const levels = []
    const queue = [root]
    while (queue.length) {
        const level = []
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            level.push(node.val)
            
            queue.push(...node.children)
        }
        levels.push(level)
    }
    
    return levels
};
```

## 111. Minimum Depth of Binary Tree
```javascript
// DFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (!root) return 0
    
    let leftDepth = minDepth(root.left)
    let rightDepth = minDepth(root.right)
    
    if (leftDepth === 0) return rightDepth + 1
    if (rightDepth === 0) return leftDepth + 1
    return Math.min(leftDepth + 1, rightDepth + 1)
};

// BFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (!root) return 0
    
    const queue = [root]
    let level = 0
    while (queue.length) {
        level++
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (!node.left && !node.right) return level
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
    }
    
    return level
};
```

## 107. Binary Tree Level Order Traversal II
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function(root) {
    const dfs = (node, level) => {
        if (!node) return
        
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)
        
        if (!result[level]) result[level] = []
        result[level].push(node.val)
        
    }
    
    const result = []
    dfs(root, 0)
    return result.reverse()
};

// BFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function(root) {
    if (!root) return []
    
    const queue = [root]
    const result = []
    
    while (queue.length) {
        const size = queue.length
        let row = []
        for (let i = 0; i < size; i++) {
            const curr = queue.shift()
            row.push(curr.val)
            if (curr.left) queue.push(curr.left)
            if (curr.right) queue.push(curr.right)
        }
        result.push(row)
    }
    return result.reverse()
};
```

## 101. Symmetric Tree
```javascript
// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    const _isSymmetric = (node1, node2) => {
        if (!node1 && !node2) return true
        if (!node1 || !node2) return false
        
        if (node1.val !== node2.val) return false
        
        return _isSymmetric(node1.left, node2.right) && 
               _isSymmetric(node1.right, node2.left)
    }
    
    return _isSymmetric(root, root)
};

// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if (!root) return true
    
    const queue = []
    queue.push(root.left)
    queue.push(root.right)
    
    while (queue.length) {
        const node1 = queue.shift()
        const node2 = queue.shift()
        
        if (!node1 && !node2) continue
        if (!node1 || !node2) return false
        if (node1.val !== node2.val) return false
        
        queue.push(node1.left)
        queue.push(node2.right)
        
        queue.push(node1.right)
        queue.push(node2.left)
    }
    
    return true
};
```

## 993. Cousins in Binary Tree
```javascript
// DFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
var isCousins = function(root, x, y) {
    const dfs = (node, parent, depth) => {
        if (!node) return
        
        if (node.val === x) {
            xParent = parent
            xDepth = depth
            return
        }
        
        if (node.val === y) {
            yParent = parent
            yDepth = depth
            return
        }
        
        dfs(node.left, node, depth + 1)
        dfs(node.right, node, depth + 1)
    }
    
    let xParent = null
    let xDepth = -1
    let yParent = null
    let yDepth = -1
    
    dfs(root, null, 0)
    return xParent !== yParent && xDepth === yDepth
};

// BFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
var isCousins = function(root, x, y) {
    const queue = [[root, null]]
    
    while (queue.length) {
        const size = queue.length
        let xParent = null
        let yParent = null
        for (let i = 0; i < size; i++) {
            const [node, parent] = queue.shift()
            
            if (node.val === x) {
                xParent = parent
            } else if (node.val === y) {
                yParent = parent
            }
            
            if (xParent && yParent && xParent !== yParent) return true
            
            if (node.left) queue.push([node.left, node])
            if (node.right) queue.push([node.right, node])
        }
    }
    
    return false
};
```

## 690. Employee Importance
```javascript
// BFS 1
function getImportance(employees, id) {
    let map = {};
    let sum = 0;

    employees.forEach(([id, importance, reports]) => {
        map[id] = { importance, reports };
    });

    const currentEmployee = map[id];
    sum += currentEmployee.importance;

    let queue = [...currentEmployee.reports];

    while (queue.length) {
        const curId = queue.shift();
        const {importance, reports} = map[curId];
        sum += importance;
        queue.push(...reports);
    }

    return sum;
}

// BFS 2
/**
 * Definition for Employee.
 * function Employee(id, importance, subordinates) {
 *     this.id = id;
 *     this.importance = importance;
 *     this.subordinates = subordinates;
 * }
 */

/**
 * @param {Employee[]} employees
 * @param {number} id
 * @return {number}
 */
var GetImportance = function(employees, id) {
    const [graph, importanceMap] = buildGraph(employees)
    
    const queue = [id]
    let sum = 0
    
    while (queue.length) {
        const node = queue.shift()
        sum += importanceMap[node]
        
        for (const neighbor of graph[node]) {
            queue.push(neighbor)
        }
    }
    
    return sum
};

const buildGraph = employees => {
    const graph = Array(employees.length + 1).fill()
    const importanceMap = Array(employees.length + 1).fill(0)
    
    for (const { id, importance, subordinates } of employees) {
        graph[id] = subordinates
        importanceMap[id] = importance
    }
    
    return [graph, importanceMap]
}

/**
 * Definition for Employee.
 * function Employee(id, importance, subordinates) {
 *     this.id = id;
 *     this.importance = importance;
 *     this.subordinates = subordinates;
 * }
 */

/**
 * @param {Employee[]} employees
 * @param {number} id
 * @return {number}
 */
var GetImportance = function(employees, id) {
    const tree = {}
    
    for (const {id, importance, subordinates} of employees) {
        tree[id] = {importance, subordinates}
    }
    
    return dfs(tree, id)
};

const dfs = (tree, id) => {
    if (tree[id] === undefined)
        return 0
    
    let sum = tree[id].importance
    for (const subordinate of tree[id].subordinates) {
        sum += dfs(tree, subordinate)
    }
    
    return sum
}
```

## 872. Leaf-Similar Trees
```javascript
// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
    const leaves1 = getLeaves(root1)
    const leaves2 = getLeaves(root2)
    
    let i = 0
    let j = 0
    
    if (leaves1.length !== leaves2.length) return false
    while (i < leaves1.length && j < leaves2.length) {
        if (leaves1[i] !== leaves2[j]) return false
        i++
        j++
    }
    return true
};

const getLeaves = node => {
    const seen = new Set()
    const stack = [node]
    const leaves = []
    
    while (stack.length) {
        let curr = stack[stack.length - 1]
        
        if (!curr.left && !curr.right) {
            leaves.push(curr.val)
            stack.pop()
            continue
        }
        
        if (!seen.has(curr.left) && curr.left) {
            stack.push(curr.left)
            seen.add(curr.left)
            continue
        }
        
        if (!seen.has(curr.right) && curr.right) {
            stack.push(curr.right)
            seen.add(curr.right)
            continue
        }
        
        stack.pop()
    }
    return leaves
}

// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
    const leaves1 = getLeaves(root1)
    const leaves2 = getLeaves(root2)

    let i = 0
    let j = 0
    
    if (leaves1.length !== leaves2.length) return false
    while (i < leaves1.length && j < leaves2.length) {
        if (leaves1[i] !== leaves2[j]) return false
        i++
        j++
    }
    return true
};

const getLeaves = node => {
    const result = []
    _getLeaves(node, result)
    return result
}

const _getLeaves = (node, result) => {
    if (!node) return
    if (!node.left && !node.right) {
        result.push(node.val)
        return
    }
    _getLeaves(node.left, result)
    _getLeaves(node.right, result)
}

// Break early
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
    const dfs = (node) => {
        if (!node) return true
        
        if (!node.left && !node.right) {
            if (i >= l1.length || node.val !== l1[i]) {
                return false
            }
            
            i++
            return true
        }
        
        return dfs(node.left) && dfs(node.right)
    }
    
    
    const l1 = getLeaves(root1)
    let i = 0
    return dfs(root2)
};

const getLeaves = node => {
    const _getLeaves = node => {
        if (!node) return

        if (!node.left && !node.right) {
            leaves.push(node.val)
            return
        }

        _getLeaves(node.left)
        _getLeaves(node.right)
    }
    
    const leaves = []
    _getLeaves(node)
    return leaves
}
```

## 112. Path Sum
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    const _hasPathSum = (node, sum) => {
        if (!node) return false
        
        sum += node.val
        
        if (!node.left && !node.right) {
            return sum === targetSum
        }
        
        return _hasPathSum(node.left, sum) || _hasPathSum(node.right, sum)
    }
    
    return _hasPathSum(root, 0)
};
```

## 257. Binary Tree Paths
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    const _binaryTreePaths = node => {
        if (!node) return
        
        path.push(node.val)
        
        if (!node.left && !node.right) {
            result.push(path.join('->'))
            path.pop()
            return
        }
        
        _binaryTreePaths(node.left)
        _binaryTreePaths(node.right)
        path.pop()
    }
    
    const result = []
    const path = []
    _binaryTreePaths(root)
    return result
};
```

## 100. Same Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if (!p && !q) return true
    if (!p || !q) return false
    
    return p.val === q.val && 
           isSameTree(p.left, q.left) && 
           isSameTree(p.right, q.right)
};
```

## 102. Binary Tree Level Order Traversal
```javascript
// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return []
    
    const result = []
    const queue = [root]
    while (queue.length) {
        const size = queue.length
        const level = []
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            level.push(node.val)
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        result.push(level)
    }
    
    return result
};

// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    const _levelOrder = (node, level) => {
        if (!node) return
        
        if (levels.length === level) {
            levels.push([])
        }

        levels[level].push(node.val)

        if (node.left) _levelOrder(node.left, level + 1)  
        if (node.right) _levelOrder(node.right, level + 1)
    }
    
    if (!root) return []
    
    const levels = []
    _levelOrder(root, 0)
    return levels
};
```

## 144. Binary Tree Preorder Traversal
```javascript
// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const stack = []
    const result = []
    
    while (root || stack.length) {
        if (root) {
            stack.push(root)
            result.push(root.val)
            root = root.left
        } else {
            root = stack.pop()
            root = root.right
        }
    }
    return result  
};
```

## 94. Binary Tree Inorder Traversal
```javascript
// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const stack = []
    const result = []
    
    while (root || stack.length) {
        if (root) {
            stack.push(root)
            root = root.left
        } else {
            root = stack.pop()
            result.push(root.val)
            root = root.right
        }
    }
    return result
};
```

## 145. Binary Tree Postorder Traversal
```javascript
// Iterative
var postorderTraversal = function(root) {
    let stack = []
    let result = []
    
    while (root || stack.length) {
        if (root) {
            stack.push(root)
            root = root.left
        } else {
            let temp = stack[stack.length - 1].right
            
            if (temp) {
                root = temp
            } else {
                while (stack.length && stack[stack.length - 1].right === temp) {
                    temp = stack.pop()
                    result.push(temp.val)
                }
            }
        }
    }
    
    return result
};
```

## 250. Count Univalue Subtrees
```javascript
var count = 0

var countUnivalSubtrees = function(root) {
    if (!root) return 0
    count = 0
    _countUnivalSubtrees(root)
    return count
};

const _countUnivalSubtrees = node => {
    if (!node) return null
    
    let left = _countUnivalSubtrees(node.left)
    let right = _countUnivalSubtrees(node.right)
    
    if ((left === null || node.val === left) && (right === null || node.val === right)) {
        count++
        return node.val
    }
}
```

## 116. Populating Next Right Pointers in Each Node
```javascript
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (!root) return root
    
    let leftmost = root
    while (leftmost.left) {
        let head = leftmost
        while (head) {
            head.left.next = head.right
            
            if (head.next) {
                head.right.next = head.next.left
            }
            
            head = head.next
        }
        
        leftmost = leftmost.left
    }
    
    return root
};
```

## 589. N-ary Tree Preorder Traversal
```javascript
var preorder = function(root) {
    if (!root) return []
    
    const result = []
    const stack = [root]
    
    while (stack.length) {
        const curr = stack.pop()
        result.push(curr.val)
        
        for (let i = curr.children.length - 1; i >= 0; i--)
            stack.push(curr.children[i])
    }
    
    return result
};

/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node} root
 * @return {number[]}
 */
var preorder = function(root) {
    const _preorder = node => {
        if (!node) return

        result.push(node.val)

        for (const child of node.children) {
            _preorder(child)
        }
    }
    
    const result = []
    _preorder(root)
    return result
};
```

## 590. N-ary Tree Postorder Traversal
```javascript
var postorder = function(root) {
    if (!root) return []
    
    const result = []
    const stack = [root]
    
    while (stack.length) {
        const curr = stack.pop()
        result.push(curr.val)
        
        for (const child of curr.children)
            stack.push(child)
    }
    
    return result.reverse()
};

/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node} root
 * @return {number[]}
 */
var postorder = function(root) {
    if (!root) return []
    
    const result = []
    const stack = [root]
    
    while (stack.length) {
        const top = stack.pop()
        result.push(top.val)
        
        for (const child of top.children) {
            stack.push(child)
        }
    }
    
    return result.reverse()
}
```

## 559. Maximum Depth of N-ary Tree
```javascript
var maxDepth = function(root) {
    const _maxDepth = (root, max = 1, level = 1) => {
        max = Math.max(max, level)
        
        for (const child of root.children)
            max = Math.max(_maxDepth(child, max, level + 1), max)
        
        return max
    }
    
    if (!root) return 0
    return _maxDepth(root)
};
```

## 24. Swap Nodes in Pairs
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    if (!head || !head.next) return head

    let next = head.next.next
    let newHead = head.next
    newHead.next = head
    head.next = swapPairs(next)

    return newHead
};
```

## 25. Reverse Nodes in k-Group
```javascript
// Iterative
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    if (k <= 1) return head
    
    const dummy = new ListNode(NaN)
    dummy.next = head
    let curr = dummy
    
    while (curr) {
        let runner = curr.next
        
        let i = 0
        while (i < k && runner) {
            runner = runner.next
            i++
        }
        
        if (i < k) break

        const reversedTail = curr.next
        const reversedHead = reverse(curr.next, runner)
        
        curr.next = reversedHead
        reversedTail.next = runner
        curr = reversedTail
    }
    
    return dummy.next
};

const reverse = (start, end) => {
    let curr = start
    let prev = null
    
    while (curr !== end) {
        const next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    }
    
    return prev
}

// Recursive
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
const reverse = head => {
    let curr = head
    let prev = null
    let next = null
    
    while (curr) {
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    }
    return prev
}

var reverseKGroup = function(head, k) {
    if (!head) return head
    
    let tail = head
    let i = 0
    while (i < k - 1 && tail) {
        tail = tail.next 
        i++
    }
    
    if (!tail || i !== k - 1) return head
    
    let nextHead = tail.next
    tail.next = null
    
    let reverseHead = reverse(head)
    head.next = reverseKGroup(nextHead, k)
    return reverseHead
};
```

## 70. Climbing Stairs
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    const _climbStairs = n => {
        if (n <= 1) return 1
        if (memo[n] !== undefined)
            return memo[n]
        
        memo[n] = _climbStairs(n - 1) + _climbStairs(n - 2)
        return memo[n]
    }
    
    const memo = Array(n + 1).fill()
    return _climbStairs(n)
};

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    const dp = Array(n).fill()
    dp[0] = 1
    dp[1] = 1
    
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    
    return dp[n]
};

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    let dp1 = 1
    let dp2 = 1
    
    for (let i = 2; i <= n; i++) {
        const temp = dp1 + dp2
        dp2 = dp1
        dp1 = temp
    }
    
    return dp1
};
```

## 387. First Unique Character in a String
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    const map = Array(26).fill(0)
    for (const char of s) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        map[index]++
    }
    
    for (let i = 0; i < s.length; i++) {
        const char = s[i]
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        if (map[index] === 1) {
            return i
        } 
    }
    
    return -1
};
```

## 226. Invert Binary Tree
```javascript
// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (!root) return root
    
    const left = invertTree(root.left)
    const right = invertTree(root.right)
    
    root.left = right
    root.right = left
    
    return root
};

// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    const stack = [root]
    
    while (stack.length) {
        const node = stack.pop()
        
        if (!node) continue
        
        const temp = node.left
        node.left = node.right
        node.right = temp
        
        stack.push(node.right)
        stack.push(node.left)
    }   
    
    return root
};
```

## 1165. Single-Row Keyboard
```javascript
var calculateTime = function(keyboard, word) {
    const map = keyboard.split('').reduce((result, char, i) => {
        result[char] = i
        return result
    }, {})
    
    let currIndex = 0
    let time = 0
    
    for (let char of word) {
        let index = map[char]
        let dist = Math.abs(currIndex - index)
        time += dist
        currIndex = index
    }
    
    return time
};
```

## 938. Range Sum of BST
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} low
 * @param {number} high
 * @return {number}
 */
var rangeSumBST = function(root, low, high) {
    if (!root) return 0
    
    if (root.val < low) {
        return rangeSumBST(root.right, low, high)
    }
    
    if (root.val > high) {
        return rangeSumBST(root.left, low, high)
    }
    
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high)
};
```

## 1137. N-th Tribonacci Number
```javascript
// Top Down
const memo = {}

var tribonacci = function(n) {
    if (memo[n]) return memo[n]
    if (n <= 0) return 0
    if (n <= 2) return 1

    memo[n] = tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1)
    return memo[n]
};

// Bottom DP
var tribonacci = function(n) {
    if (n <= 0) return 0
    if (n <= 2) return 1
    
    let dp1 = 0
    let dp2 = 1
    let dp3 = 1
    
    for (let i = 3; i <= n; i++) {
        const next = dp1 + dp2 + dp3
        
        dp1 = dp2
        dp2 = dp3
        dp3 = next
    }
    
    return dp3
};
```

## 783. Minimum Distance Between BST Nodes
```javascript
var minDiffInBST = function(root) {
    let prev = null 
    let min = Number.MAX_VALUE
    
    const _minDiffInBST = root => {
        if (!root) return
        
        _minDiffInBST(root.left)
        
        if (prev) min = Math.min(min, root.val - prev)
        prev = root.val
        
        _minDiffInBST(root.right)
    }
    _minDiffInBST(root)
    return min
};

// Iterative
var minDiffInBST = function(root) {
    if (!root) return 0
    
    let stack = []
    let prev = null 
    let min = Number.MAX_VALUE
  
    while (root || stack.length) {
        if (root) {
            stack.push(root)
            root = root.left
        } else {
            root = stack.pop()
            
            if (prev) min = Math.min(min, root.val - prev)
            prev = root.val  
            
            root = root.right
        }
    }
    
    return min
};
```

## 617. Merge Two Binary Trees
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
    if (!t1) return t2
    if (!t2) return t1

    t1.val += t2.val
    t1.left = mergeTrees(t1.left, t2.left)
    t1.right = mergeTrees(t1.right, t2.right)
    return t1
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
    if (!t1) return t2
    
    const stack = [[t1, t2]]
    
    while (stack.length) {
        const [node1, node2] = stack.pop()
        if (!node1 || !node2) continue
        
        node1.val += node2.val
        
        if (!node1.left) {
            node1.left = node2.left
        } else {
            stack.push([node1.left, node2.left])
        }
        
        if (!node1.right) {
            node1.right = node2.right
        } else {
            stack.push([node1.right, node2.right])
        }
    }
    
    return t1
};
```

## 700. Search in a Binary Search Tree
```javascript
var searchBST = function(root, val) {
    if (!root) return null
    
    if (root.val === val) return root
    if (root.val > val) {
        return searchBST(root.left, val)
    } else {
        return searchBST(root.right, val)
    }
};

// Iterative
var searchBST = function(root, val) {
    while (root) {
        if (root.val === val) return root
        
        if (root.val > val) {
            root = root.left
        } else {
            root = root.right
        }
    }
    return null
};
```

## 965. Univalued Binary Tree
```javascript
var isUnivalTree = function(root) {
    if (!root) return true
    if (!root.left && !root.right) return true
    
    let l = root.left ? root.left.val === root.val : true
    let r = root.right ? root.right.val === root.val : true
    if (!l || !r) return false
    
    let left = isUnivalTree(root.left)
    let right = isUnivalTree(root.right)
    return left && right
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isUnivalTree = function(root) {
    const dfs = (node) => {
        if (!node) return true
        
        if (node.val !== val)
            return false
        
        return dfs(node.left) && dfs(node.right)
    }
    
    let val = root.val
    return dfs(root)
};
```

## 1022. Sum of Root To Leaf Binary Numbers
```javascript
var sumRootToLeaf = function(root) {
    const _sumRootToLeaf = (root, curr) => {
        if (!root) return
        
        curr <<= 1
        curr |= root.val
        
        if (!root.left && !root.right) {
            sum += curr
            return
        }
        
        _sumRootToLeaf(root.left, curr)    
        _sumRootToLeaf(root.right, curr)
    }
    
    let sum = 0
    _sumRootToLeaf(root, 0)
    return sum
};
```

## 637. Average of Levels in Binary Tree
```javascript
var averageOfLevels = function(root) {
    if (!root) return null
    
    const result = []
    const queue = [root]
    
    while (queue.length) {
        const size = queue.length
        let sum = 0
        for (let i = 0; i < size; i++) {
            const curr = queue.shift()
            sum += curr.val
            if (curr.left) queue.push(curr.left)
            if (curr.right) queue.push(curr.right)
        }
        result.push(sum / size)
    }
    return result
};

// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function(root) {
    const dfs = (node, level) => {
        if (!node) return
        
        if (!levels[level]) levels[level] = [0, 0]
        levels[level][0] += node.val
        levels[level][1]++
        
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)
    }
    
    const levels = []
    dfs(root, 0)
    return levels.map(val => val[0] / val[1])
};
```

## 653. Two Sum IV - Input is a BST
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {boolean}
 */
var findTarget = function(root, k) {
    const inOrder = root => {
        if (!root) return
        inOrder(root.left)
        result.push(root.val)
        inOrder(root.right)
    }
        
    if (!root) return false
    
    const result = []
    inOrder(root)
    
    let left = 0
    let right = result.length - 1

    while (left < right) {
        const sum = result[left] + result[right]

        if (sum === k) return true

        if (sum > k) {
            right--
        } else {
            left++
        }
    }
        
    return false
};

// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {boolean}
 */
var findTarget = function(root, k) {
    const _findTarget = (root) => {
        if (!root) return false
        
        if (set.has(k - root.val)) return true
        set.add(root.val)
        return _findTarget(root.left) || _findTarget(root.right)
    }
    
    const set = new Set()
    return _findTarget(root)
};
```

## 530. Minimum Absolute Difference in BST
```javascript
var getMinimumDifference = function(root) {
    const _getMinimumDifference = root => {
        if (!root) return
        
        _getMinimumDifference(root.left)

        if (prev !== null) diff = Math.min(root.val - prev, diff)
        prev = root.val
        
        _getMinimumDifference(root.right)
    }
    
    let prev = null
    let diff = Number.MAX_VALUE
    
    _getMinimumDifference(root)
    return diff
};

// Iterative
var getMinimumDifference = function(root) {
    const _getMinimumDifference = root => {
        if (!root) return
        _getMinimumDifference(root.left)
        result.push(root.val)
        _getMinimumDifference(root.right)
    }
    
    if (!root) return null
    
    const result = []
    _getMinimumDifference(root)
    
    let min = Number.MAX_VALUE
    for (let i = 1; i < result.length; i++) {
        min = Math.min(result[i] - result[i - 1], min)
    }
    return min
};
```

## 671. Second Minimum Node In a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findSecondMinimumValue = function(root) {
    const dfs = node => {
        if (!node) return
        
        if (firstMin < node.val && node.val < secondMin) {
            secondMin = node.val
            return
        }
        
        dfs(node.left)
        dfs(node.right)
    }
    
    let firstMin = root.val
    let secondMin = Infinity
    dfs(root)
    return secondMin === Infinity ? -1 : secondMin
};
```

## 563. Binary Tree Tilt
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findTilt = function(root) {
    const _findTilt = (root) => {
        if (!root) return 0
        
        const left = _findTilt(root.left) 
        const right = _findTilt(root.right) 
        
        sum += Math.abs(left - right)
        return left + right + root.val
    }
    
    let sum = 0
    _findTilt(root)
    return sum
};
```

## 669. Trim a Binary Search Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} L
 * @param {number} R
 * @return {TreeNode}
 */
var trimBST = function(root, L, R) {
    if (!root) return null
    if (root.val > R) return trimBST(root.left, L, R)
    if (root.val < L) return trimBST(root.right, L, R)
    
    root.left = trimBST(root.left, L, R)
    root.right = trimBST(root.right, L, R)
    
    return root
};
```

## 404. Sum of Left Leaves
```javascript
var sumOfLeftLeaves = function(root, isLeft = false) {
    if (!root) return 0
    
    if (!root.left && !root.right && isLeft) 
        return root.val
    
    return sumOfLeftLeaves(root.left, true) + sumOfLeftLeaves(root.right, false)
};
```

## 783. Minimum Distance Between BST Nodes
```javascript
// Approach 1
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDiffInBST = function(root) {
    const inOrder = root => {
        if (!root) return
        
        inOrder(root.left)
        
        if (prev) min = Math.min(min, root.val - prev)
        prev = root.val
        inOrder(root.right)
    }
    
    let prev = null
    let min = Number.MAX_VALUE
    inOrder(root)
    return min
};

// Approach 2
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDiffInBST = function(root) {
    const _minDiffInBST = (node, low, high) => {
        if (!node) return
        
        min = Math.min(min, Math.abs(node.val - low))
        min = Math.min(min, Math.abs(node.val - high))
        
        _minDiffInBST(node.left, low, node.val)
        _minDiffInBST(node.right, node.val, high)
    }
    
    let min = Infinity
    _minDiffInBST(root, Infinity, Infinity)
    return min
};
```

## 110. Balanced Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    const _isBalanced = root => {
        if (!root) return 0

        const left = _isBalanced(root.left) 
        if (left === -1) return -1

        const right = _isBalanced(root.right)
        if (right === -1) return -1

        if (Math.abs(left - right) > 1) return -1
        return Math.max(left, right) + 1
    }
    return _isBalanced(root) !== -1
};
```

## 543. Diameter of Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    const _diameterOfBinaryTree = node => {
        if (!node) return 0
        
        const left = _diameterOfBinaryTree(node.left)
        const right = _diameterOfBinaryTree(node.right)
        
        diameter = Math.max(diameter, left + right)
        return 1 + Math.max(left, right)
    }
    
    let diameter = 0
    _diameterOfBinaryTree(root)
    return diameter
};
```

## 572. Subtree of Another Tree
```javascript
// O(mn)
var isSubtree = function(s, t) {
    const isEqual = (s, t) => {
        if (!s && !t) return true
        if (!s || !t) return false
        return s.val === t.val && 
            isEqual(s.left, t.left) && 
            isEqual(s.right, t.right)
    }
    
    const preOrder = root => {
        if (!root) return false
        if (isEqual(root, t)) return true
        
        let left = preOrder(root.left)
        let right = preOrder(root.right)
        return left || right
    }
    return preOrder(s)
};

// Contains
var isSubtree = function(s, t) {
    const buildString = (root, charArr) => {
        if (!root) {
            charArr.push('#')
            return
        }
        charArr.push(`${root.val}`)
        buildString(root.left, charArr)
        buildString(root.right, charArr)
    }
    
    const contains = (needle, haystack) => {
        let h = 0
        while (h < haystack.length) {
            let currH = h
            let n = 0
            while (n < needle.length) {
                if (needle[n] !== haystack[currH]) break
                currH++
                n++
                if (n >= needle.length) return true
            }
            h++
        }
        return false
    }
    
    const sSeralize = []
    const tSeralize = []
    
    buildString(s, sSeralize)
    buildString(t, tSeralize)
    
    return contains(tSeralize, sSeralize)
};

// KMP
var isSubtree = function(s, t) {
    const buildString = (root, charArr) => {
        if (!root) {
            charArr.push('#')
            return
        }
        
        charArr.push(`${root.val}`)
        buildString(root.left, charArr)
        buildString(root.right, charArr)
    }
    
    const kmp = (needle, haystack) => {
        const table = prefixTable(needle)
        
        let n = 0
        let h = 0
        
        while (h < haystack.length) {
            if (haystack[h] === needle[n]) {
                if (n === needle.length - 1) return true
                h++
                n++
                continue
            }
            
            if (n === 0) {
                h++
                continue
            }
            
            n = table[n - 1]
            
        }
        return false
    }
    
    const prefixTable = needle => {
        const table = [0]
        
        let p = 0
        let s = 1
        
        while (s < needle.length) {
            if (needle[s] === needle[p]) {
                table[s++] = ++p
                continue
            }
            
            if (!p) {
                table[s++] = 0
                continue
            }
            
            p = table[p - 1]
        }
        
        return table
    }
    
    const sSeralize = []
    const tSeralize = []
    
    buildString(s, sSeralize)
    buildString(t, tSeralize)
    
    return kmp(tSeralize, sSeralize)
};

// Merkle Tree
var isSubtree = function(s, t) {
    const merkle = root => {
        if (!root) return 0
        
        let left = merkle(root.left)
        let right = merkle(root.right)
        
        root.merkle = left + root.val + right
        return root.merkle
    }
    
    const dfs = root => {
        if (!root) return false
        return (root.merkle === t.merkle && isEqual(root, t)) || 
            dfs(root.left) || 
            dfs(root.right)
    }
    
    const isEqual = (s, t) => {
        if (!s && !t) return true
        if (!s || !t) return false
        return s.val === t.val && isEqual(s.left, t.left) && isEqual(s.right, t.right)
    }
    
    merkle(s)
    merkle(t)
    return dfs(s)
};
```

## 538. Convert BST to Greater Tree
```javascript
var convertBST = function(root) {
    const reverseInOrder = root => {
        if (!root) return
        reverseInOrder(root.right)
        
        let temp = root.val
        root.val = sum + root.val
        sum += temp
        
        reverseInOrder(root.left)
    }
    
    let sum = 0
    reverseInOrder(root)
    return root
};

// Morris 
var convertBST = function(root) {
    const morris = root => {
        while (root) {
            if (!root.right) {
                let temp = root.val
                root.val = sum + root.val
                sum += temp
                
                root = root.left
            } else {
                let pred = root.right
                
                while (pred.left !== root && pred.left)
                    pred = pred.left
                
                if (!pred.left) {
                    pred.left = root
                    root = root.right
                } else {
                    pred.left = null

                    let temp = root.val
                    root.val = sum + root.val
                    sum += temp
                    
                    root = root.left
                }
            }
        }
    }
    
    let sum = 0
    morris(root)
    return root
};

// Iterative
var convertBST = function(root) {
    const inOrder = root => {
        const stack = []
        
        while (stack.length || root) {
            if (!root) {
                const node = stack.pop()
                
                let temp = node.val
                node.val += sum
                sum += temp
                
                root = node.left
            } else {
                stack.push(root)
                root = root.right
            }
        }
    }
    
    let sum = 0
    inOrder(root)
    return root
};
```

## 501. Find Mode in Binary Search Tree
```javascript
var findMode = function(root) {
    const inOrder = (root, handler) => {
        while (root) {
            if (!root.left) {
                handler(root.val)
                root = root.right
            } else {
                let pred = root.left
                
                while (pred.right !== root && pred.right)
                    pred = pred.right
                
                if (!pred.right) {
                    pred.right = root
                    root = root.left
                } else {
                    handler(root.val)
                    pred.right = null
                    root = root.right
                }
            }
        }
    }
    
    const setMax = val => {
        if (val !== currVal) {
            currVal = val
            curr = 0
        }
        curr++
        max = Math.max(max, curr)
    }
    
    const addModes = val => {
        if (val !== currVal) {
            currVal = val
            curr = 0
        }
        curr++
        
        if (curr === max) result.push(currVal)
    }
    
    let currVal = null
    let curr = 0
    let max = 0
    inOrder(root, setMax)
    
    const result = []
    currVal = null
    curr = 0
    inOrder(root, addModes)
    
    return result
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var findMode = function(root) {
    const inOrder = node => {
        if (!node) return
        
        inOrder(node.left)
        
        if (node.val === currVal) {
            currCount++
        } else {
            currVal = node.val
            currCount = 1
        }
        
        if (maxCount === currCount) {
            result.push(node.val)
        } else if (maxCount < currCount) {
            result = [node.val]
            maxCount = currCount            
        }
        
        inOrder(node.right)
    }
    
    let result = []
    let currVal = null
    let currCount = 0
    let maxCount = 0
    
    inOrder(root)
    return result
};
```

## 687. Longest Univalue Path
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function(root) {
    const _longestUnivaluePath = node => {
        if (!node) return [null, 0]
        
        const [leftVal, leftLen] = _longestUnivaluePath(node.left)
        const [rightVal, rightLen] = _longestUnivaluePath(node.right)
        
        if (leftVal === node.val && rightVal === node.val) {
            max = Math.max(max, leftLen + rightLen)
            return [node.val, Math.max(leftLen, rightLen) + 1]
        } else if (leftVal === node.val) {
            max = Math.max(max, leftLen)
            return [leftVal, leftLen + 1]
        } else if (rightVal === node.val) {
            max = Math.max(max, rightLen)
            return [rightVal, rightLen + 1]
        } else {
            return [node.val, 1]
        }
    }
    
    let max = 0
    _longestUnivaluePath(root)
    return max
};
```

## 606. Construct String from Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} t
 * @return {string}
 */
var tree2str = function(t) {
    const dfs = (node) => {
        if (!node) return
        
        str.push(node.val)
        
        if (!node.left && !node.right) {
            return
        }
        
        str.push('(')
        dfs(node.left)
        str.push(')')
        
        if (node.right) {
            str.push('(')
            dfs(node.right)
            str.push(')')
        }
    }
    
    const str = []
    dfs(t)
    return str.join('')
};
```

## 560. Subarray Sum Equals K
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
    const map = { 0: 1 }
    
    let count = 0
    let sum = 0
    for (let i = 0; i < nums.length; i++) {
        sum += nums[i]
        count += (map[sum - k] || 0)
        map[sum] = 1 + (map[sum] || 0)
    }
    
    return count
};
```

## 437. Path Sum III
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number}
 */
var pathSum = function(root, sum) {
    const _pathSum = (node, currSum) => {
        if (!node) return
        
        currSum += node.val
        const target = currSum - sum
        
        if (map.get(target) !== undefined) {
            count += map.get(target)
        }
        
        map.set(currSum, 1 + (map.get(currSum) || 0))
        
        _pathSum(node.left, currSum)
        _pathSum(node.right, currSum)
        
        map.set(currSum, map.get(currSum) - 1)
    }
    
    const map = new Map()
    map.set(0, 1)
    let count = 0
    _pathSum(root, 0)
    return count
};
```

## 897. Increasing Order Search Tree
```javascript
var increasingBST = function(root) {
    const _increasingBST = root => {
        if (!root) return
        _increasingBST(root.left)
        
        root.left = null
        curr.right = root
        curr = root
        
        _increasingBST(root.right)
        return root
    }
    
    const dummy = new TreeNode(0)
    let curr = dummy
    _increasingBST(root)
    return dummy.right
};
```

## 733. Flood Fill
```javascript
// BFS
/**
 * @param {number[][]} image
 * @param {number} sr
 * @param {number} sc
 * @param {number} newColor
 * @return {number[][]}
 */
var floodFill = function(image, sr, sc, newColor) {
    const originalColor = image[sr][sc]
    if (newColor === originalColor) return image
    image[sr][sc] = newColor
    
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    const rowLen = image.length
    const colLen = image[0].length
    
    const queue = [[sr, sc]]
    while (queue.length) {
        const [row, col] = queue.shift()
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen || 
                image[nextRow][nextCol] !== originalColor) {
                continue
            }
            
            image[nextRow][nextCol] = newColor
            queue.push([nextRow, nextCol])
        }
    }
    
    return image
};

// Recursive DFS
/**
 * @param {number[][]} image
 * @param {number} sr
 * @param {number} sc
 * @param {number} newColor
 * @return {number[][]}
 */
var floodFill = function(image, sr, sc, newColor) {
    const _floodFill = (cr, cc) => {
        image[cr][cc] = newColor
        
        for (const [dr, dc] of dirs) {
            const nr = cr + dr
            const nc = cc + dc
            
            if (nr < 0 || nr >= image.length || 
                nc < 0 || nc >= image[0].length || 
                image[nr][nc] !== oldColor) continue
            
            _floodFill(nr, nc)
        }
    }
    
    const oldColor = image[sr][sc]
    if (oldColor === newColor) return image
    
    const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
    _floodFill(sr, sc)
    return image
};

// Iterative DFS
/**
 * @param {number[][]} image
 * @param {number} sr
 * @param {number} sc
 * @param {number} newColor
 * @return {number[][]}
 */
var floodFill = function(image, sr, sc, newColor) {
    const oldColor = image[sr][sc]
    if (oldColor === newColor) return image
    
    const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
    const stack = [[sr, sc]]
    
    while (stack.length) {
        const [cr, cc] = stack.pop()
        
        image[cr][cc] = newColor
        
        for (const [dr, dc] of dirs) {
            const nr = cr + dr
            const nc = cc + dc
            
            if (nr < 0 || nr >= image.length || 
                nc < 0 || nc >= image[0].length || 
                image[nr][nc] !== oldColor) continue
            
            stack.push([nr, nc])
        }
    }
    
    return image
};
```

## 1161. Maximum Level Sum of a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxLevelSum = function(root) {
    let maxSum = -Infinity
    let maxLevel = -1
    
    const queue = [root]
    let level = 0
    while (queue.length) {
        const size = queue.length
        let currSum = 0
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            currSum += node.val
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        level++
        if (maxSum < currSum) {
            maxSum = currSum
            maxLevel = level
        }
    }
    
    return maxLevel
};
```

## 841. Keys and Rooms
```javascript
// DFS
var canVisitAllRooms = function(rooms) {
    let stack = [0]
    let seen = new Set()
    seen.add(0)
    
    while (stack.length) {
        const curr = stack.pop()
        
        for (let key of rooms[curr]) {
            if (!seen.has(key)) {
                stack.push(key)
                seen.add(key)
                if (seen.size === rooms.length) return true
            }
        }
    }

    return seen.size === rooms.length
};

// BFS
/**
 * @param {number[][]} rooms
 * @return {boolean}
 */
var canVisitAllRooms = function(rooms) {
    const visited = Array(rooms.length).fill(false)
    visited[0] = true
    let count = 1
    
    const queue = [0]
    while (queue.length) {
        const vertex = queue.shift()
        
        for (const neighbor of rooms[vertex]) {
            if (visited[neighbor]) continue
            count++
            visited[neighbor] = true
            queue.push(neighbor)
        }
    }
    
    return count === rooms.length
};
```

## 784. Letter Case Permutation
```javascript
// Iterative
/**
 * @param {string} S
 * @return {string[]}
 */
var letterCasePermutation = function(S) {
    const result = [[]]
    
    for (const char of S) {
        if (Number.isNaN(+char)) {
            const n = result.length
            
            for (let i = 0; i < n; i++) {
                result.push(result[i].slice())
                result[i].push(char.toLowerCase())
                result[n + i].push(char.toUpperCase())
            }
            continue
        }
        for (const arr of result)
            arr.push(char)
    }
    
    return result.map(charArr => charArr.join(''))
};

// Recursive
/**
 * @param {string} S
 * @return {string[]}
 */
var letterCasePermutation = function(S) {
    const _letterCasePermutation = index => {
        if (index >= S.length) {
            result.push(path.join(''))
            return
        }
        
        const char = S[index]
        if (isDigit(char)) {
            path.push(char)
            _letterCasePermutation(index + 1)
            path.pop()
            return
        }          
        
        path.push(char.toLowerCase())
        _letterCasePermutation(index + 1)
        path.pop()

        path.push(char.toUpperCase())
        _letterCasePermutation(index + 1)
        path.pop()
    }
    
    const result = []
    const path = []
    _letterCasePermutation(0)
    return result
};

const isDigit = char => '0' <= char && char <= '9'
```

## 46. Permutations
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const _permute = start => {
        if (start >= nums.length) {
            result.push(nums.slice())
            return
        }
        
        for (let i = start; i < nums.length; i++) {
            swap(nums, start, i)
            _permute(start + 1)
            swap(nums, start, i)
        }
    }
    
    const result = []
    _permute(0)
    return result
};

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 77. Combinations
```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    const _combine = (curr, i) => {
        if (curr.length >= k) {
            result.push(curr.slice())
            return
        }
        
        for (let num = i; num <= n; num++) {
            curr.push(num)
            _combine(curr, num + 1)
            curr.pop()
        }
    }
    
    const result = []
    _combine([], 1)
    return result
};

// Iterative Bitmask
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    const result = []
    const limit = 1 << n
    
    for (let bitmask = 0; bitmask < limit; bitmask++) {
        const curr = []
        for (let i = 0; i < n; i++) {
            if (bitmask & 1 << i) {
                curr.push(i + 1)
            }
        }
        
        if (curr.length === k)
            result.push(curr)
    }
    
    return result
};
```

## 47. Permutations II
```javascript
// Bitmask
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
    const _permuteUnique = (start) => {
        if (start === nums.length) {
            result.push(nums.slice())
            return
        }
        
        let seen = 0
        for (let i = start; i < nums.length; i++) {
            const mask = 1 << (nums[i] + 10)
            if (seen & mask) continue
            seen |= mask
            
            swap(nums, i, start)
            _permuteUnique(start + 1)
            swap(nums, i, start)
        }
    }
    
    const result = []
    _permuteUnique(0)
    return result
};

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

// Counter
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
    const _permuteUnique = (list) => {
        if (list.length === nums.length) {
            result.push(list.slice())
            return
        }
        
        for (const char of Object.keys(counter)) {
            if (counter[char] <= 0) continue
            counter[char]--
            list.push(char)
            _permuteUnique(list)
            list.pop()
            counter[char]++
        }
    }
    
    const result = []
    const counter = count(nums)
    _permuteUnique([])
    return result
};

const count = nums => {
    return nums.reduce((result, ele) => {
        result[ele] = 1 + (result[ele] || 0)
        return result
    }, [])
}
```

## 60. Permutation Sequence
```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getPermutation = function(n, k) {
    const permutation = []
    let used = 0
    let f = factorial(n)
    
    let seqIndex = 0
    for (let pos = 1; pos <= n; pos++) {    
        f /= n - pos + 1
        
        for (let num = 1; num <= n; num++) {
            const mask = 1 << num
            if (used & mask) continue
            
            const nextSeqIndex = seqIndex + f
            permutation[pos - 1] = num
            
            used |= mask
            
            if (nextSeqIndex >= k) break
            seqIndex = nextSeqIndex
            
            used ^= mask
        }
    }
    
    return permutation.join('')
};

const factorial = n => {
    let f = 1
    
    while (n > 1) {
        f *= n--
    }
    
    return f
}
```

## 17. Letter Combinations of a Phone Number
```javascript
// DFS
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    const _letterCombinations = i => {
        if (i >= digits.length) {
            if (combo.length) {
                result.push(combo.join(''))
            }
            return
        }
        
        for (const char of map[digits[i]]) {
            combo.push(char)
            _letterCombinations(i + 1)
            combo.pop()
        }
    }
    
    const map = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 
                  6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }
    
    const result = []
    const combo = []
    _letterCombinations(0)
    return result
};

// BFS
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {    
    if (!digits.length) return []
    
    const map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
    
    let level = 0
    const queue = [[]]
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const path = queue.shift()
            
            const digit = digits[level]
            for (const neighbor of map[digit]) {
                queue.push(path + neighbor)
            }
        }
        
        level++
        if (level >= digits.length) break
    }
    
    return queue
};
```

## 369. Plus One Linked List
```javascript
// Iterative
var plusOne = function(head) {
    const dummy = new ListNode(0)
    dummy.next = head
    
    let i = dummy
    let j = dummy
    
    while (j) {
        if (j.val < 9)
            i = j
        
        j = j.next
    }
    
    i.val++
    i = i.next
    
    while (i) {
        i.val = 0
        i = i.next
    }
    
    return dummy.val !== 0 ? dummy : dummy.next
};

// Recursive
var plusOne = function(head) {
    const _plusOne = (node) => {
        if (!node) return 1
        
        let carry = _plusOne(node.next)
        let sum = node.val + carry 
        node.val = Math.floor(sum % 10)
        carry = Math.floor(sum / 10)
        return carry
    }
    
    let remainder = _plusOne(head)
    
    if (remainder > 0) {
        const newHead = new ListNode(remainder)
        newHead.next = head
        head = newHead
    }
    return head
};
```

## 496. Next Greater Element I
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement = function(nums1, nums2) {
    const map = {}
    
    const stack = []
    for (const num of nums2) {
        while (stack[stack.length - 1] < num)
            map[stack.pop()] = num
        
        stack.push(num)
    }
    
    return nums1.map(num => map[num] || -1)
};
```

## 503. Next Greater Element II
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var nextGreaterElements = function(nums) {
    const n = nums.length
    
    const result = new Array(n).fill(-1)
    const stack = []
    
    for (let i = 0; i < 2 * n; i++) {
        while (stack.length && nums[stack[stack.length - 1]] < nums[i % n]) {
            result[stack.pop()] = nums[i % n]
        }
        
        stack.push(i % n)
    }
    
    return result
};
```

## 1019. Next Greater Node In Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {number[]}
 */
var nextLargerNodes = function(head) {
    const result = []
    
    const stack = []
    while (head) {
        while (stack.length && stack[stack.length - 1][1] < head.val) {
            const [index, val] = stack.pop()
            result[index] = head.val
        }
        
        stack.push([result.length, head.val])
        result.push(0)
        head = head.next
    }
    
    return result
};
```

## Add Two Numbers
```javascript
var addTwoNumbers = function(l1, l2) {
    const dummy = new ListNode(-1)
    let curr = dummy
    let carry = 0
    
    while (l1 || l2) {
        let l1Val = l1 ? l1.val : 0
        let l2Val = l2 ? l2.val : 0
        let sum = carry + l1Val + l2Val
        
        let node = new ListNode(sum % 10)
        carry = Math.floor(sum / 10)
        
        curr.next = node
        curr = curr.next
        
        if (l1) l1 = l1.next
        if (l2) l2 = l2.next
    }
    
    if (carry)
        curr.next = new ListNode(carry)
    
    return dummy.next
};
```

## 445. Add Two Numbers II
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    const _addTwoNumbers = (l1, l2) => {
        if (!l1 || !l2) return [null, 0]
        
        let [nextNode, carry] = _addTwoNumbers(l1.next, l2.next)
        
        const sum = carry + l1.val + l2.val
        
        const digit = sum % 10
        const node = new ListNode(digit)
        node.next = nextNode
        
        carry = Math.trunc(sum / 10)
        
        return [node, carry]
    }
    
    const l1Len = getLen(l1)
    const l2Len = getLen(l2)
    
    const diff = Math.abs(l1Len - l2Len)
    if (l1Len < l2Len) {
        l1 = padZeros(l1, diff)
    } else {
        l2 = padZeros(l2, diff)
    }
    
    const [head, carry] = _addTwoNumbers(l1, l2)
    if (carry > 0) {
        const newHead = new ListNode(carry)
        newHead.next = head
        return newHead
    }
    
    return head
};

const padZeros = (head, k) => {
    let curr = head
    while (k--) {
        const newHead = new ListNode(0)
        newHead.next = curr
        curr = newHead
    }
    return curr
}

const getLen = node => {
    let len = 0
    while (node) {
        len++
        node = node.next
    }
    return len
}
```

## Linked List Cycle II
```javascript
var detectCycle = function(head) {
    if (!head) return null
    
    let slow = head
    let fast = head
    
    while (fast && fast.next) {
        slow = slow.next
        fast = fast.next.next
        
        if (slow === fast) break
    }
    
    if (!fast || !fast.next) return null
    
    slow = head
    
    while (slow !== fast) {
        fast = fast.next
        slow = slow.next
    }
    return slow
};
```

## 430. Flatten a Multilevel Doubly Linked List
```javascript
/**
 * // Definition for a Node.
 * function Node(val,prev,next,child) {
 *    this.val = val;
 *    this.prev = prev;
 *    this.next = next;
 *    this.child = child;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var flatten = function(head) {
    if (!head) return

    let curr = head
    while (curr) {
        if (!curr.child) {
            curr = curr.next
            continue
        }

        const next = curr.next
        
        let tail = curr.child
        tail.prev = curr
        
        curr.next = tail
        curr.child = null

        while (tail && tail.next) {
            tail = tail.next
        }

        tail.next = next
        if (next) next.prev = tail
    }
    
    return head
};
```

## Convert Sorted List to Binary Search Tree
```javascript
const seralize = node => {
    const arr = []
    while (node) {
        arr.push(node.val)
        node = node.next
    }
    return arr
}

var sortedListToBST = function(head) {
    const _sortedListToBST = arr => {
        if (!arr.length) return null
        
        const midIndex = Math.floor(arr.length / 2)
        const parent = new TreeNode(arr[midIndex])
        parent.left = _sortedListToBST(arr.slice(0, midIndex))
        parent.right = _sortedListToBST(arr.slice(midIndex + 1))
        return parent
    }
          
    const arr = seralize(head)
    return _sortedListToBST(arr)
};
```

## 328. Odd Even Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
    let oddHead = new ListNode(NaN)
    let oddCurr = oddHead
    
    let evenHead = new ListNode(NaN)
    let evenCurr = evenHead
    
    let curr = head
    let index = 1
    while (curr) {
        if (index % 2 === 0) {
            evenCurr.next = curr
            evenCurr = evenCurr.next
        } else {
            oddCurr.next = curr
            oddCurr = oddCurr.next
        }
        curr = curr.next
        index++
    }
    
    oddCurr.next = null
    evenCurr.next = null
    
    oddCurr.next = evenHead.next
    return oddHead.next
};
```

## 86. Partition List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function(head, x) {
    let left = new ListNode(NaN)
    let leftCurr = left
    
    let right = new ListNode(NaN)
    let rightCurr = right
    
    let curr = head
    while (curr) {
        if (curr.val < x) {
            leftCurr.next = curr
            leftCurr = leftCurr.next
        } else {
            rightCurr.next = curr
            rightCurr = rightCurr.next
        }
        curr = curr.next
    }
    
    rightCurr.next = null
    
    leftCurr.next = right.next
    return left.next
};
```

## 19. Remove Nth Node From End of List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    const dummy = new ListNode(NaN)
    dummy.next = head
    
    let fast = dummy
    for (let i = 0; i < n + 1; i++) {
        fast = fast.next
    }
    
    let slow = dummy
    while (fast) {
        fast = fast.next
        slow = slow.next
    }
    
    slow.next = slow.next.next    
    return dummy.next
};
```

## 82. Remove Duplicates from Sorted List II
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if (!head) return head
    
    const dummy = new ListNode(-1)
    dummy.next = head
    let curr = dummy
    
    while (curr) {
        let runner = curr.next
        if (runner && runner.next && runner.val === runner.next.val) {
            const val = runner.val
            while (runner && runner.val === val) {
                runner = runner.next
            }
            
            curr.next = runner
            continue
        }
        
        
        curr = curr.next
    }
    
    return dummy.next
};
```

## 426. Convert Binary Search Tree to Sorted Doubly Linked List
```javascript
// Recursive
var treeToDoublyList = function(root) {
    const _treeToDoublyList = root => {
        if (!root) return
        
        let left = root.left
        let right = root.right
        
        _treeToDoublyList(left)
        
        curr.right = root
        root.left = curr
        curr = curr.right
        
        _treeToDoublyList(right)
    }
    
    if (!root) return root
    
    const dummy = new Node(-1)
    let curr = dummy
    
    _treeToDoublyList(root)
    
    curr.right = dummy.right
    dummy.right.left = curr
    
    return dummy.right
};

// Iterative
var treeToDoublyList = function(root) {
    const _treeToDoublyList = root => {
        const stack = []
        
        while (root || stack.length) {
            if (root) {
                stack.push(root)
                root = root.left
            } else {
                const top = stack.pop()
                
                curr.right = top
                top.left = curr
                curr = curr.right
                
                root = top.right
            }
        }
    }
    
    if (!root) return root
    
    const dummy = new Node(-1)
    let curr = dummy
    
    _treeToDoublyList(root)
    
    curr.right = dummy.right
    dummy.right.left = curr
    
    return dummy.right
};
```

## 61. Rotate List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var rotateRight = function(head, k) {
    if (!head) return head
    if (!head.next) return head
    
    let curr = head
    let n = 1
    while (curr.next) {
        curr = curr.next
        n++
    }
    curr.next = head
    
    for (let i = 0; i < n - k % n - 1; i++)
        head = head.next
    
    let newHead = head.next
    head.next = null
    return newHead
};
```

## 817. Linked List Components
```javascript
var numComponents = function(head, G) {
    const set = new Set(G)
    
    let groups = 0
    
    while (head) {    
        if (set.has(head.val) && (!head.next || !set.has(head.next.val))) 
            groups++
        
        head = head.next
    }
    return groups
};
```

## 725. Split Linked List in Parts
```javascript
const count = list => {
    let count = 0
    while (list) {
        list = list.next
        count++
    }
    return count
}

var splitListToParts = function(root, k) {
    let length = count(root)    
    let remainder = Math.floor(length % k)
    let parts = Math.floor(length / k)
    
    const result = Array(k).fill(null)
    
    for (let i = 0; i < k; i++) {
        let head = root
        for (let j = 0; j < parts + (i < remainder ? 1 : 0) - 1; j++)
            root = root.next
            
        if (root) {
            let prev = root
            root = root.next
            prev.next = null
        }
        result[i] = head
    }
    return result
};
```

## 1171. Remove Zero Sum Consecutive Nodes from Linked List
```javascript
var removeZeroSumSublists = function(head) {
    const dummy = new ListNode(-1)
    dummy.next = head
    
    const map = {0: dummy}
    
    let sum = 0
    while (head) {
        sum += head.val
        if (map[sum]) {
            let removed = map[sum].next
            let subSum = sum
            while (removed !== head) {
                subSum += removed.val
                map[subSum] = null
                removed = removed.next
            }
            map[sum].next = head.next
        } else
            map[sum] = head
        
        head = head.next
    }
    
    return dummy.next
};
```

## 138. Copy List with Random Pointer
```javascript
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
    const copyMap = new Map()
    
    let curr = head
    while (curr) {
        copyMap.set(curr, new Node(curr.val))
        curr = curr.next
    }
    
    curr = head
    while (curr) {
        const copyCurr = copyMap.get(curr)
        copyCurr.next = (copyMap.get(curr.next) || null)
        copyCurr.random = (copyMap.get(curr.random) || null)
        curr = curr.next
    }
    
    return copyMap.get(head)
};

// O(1)
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
    if (!head) return null
    
    // Interweave Original and Copy Nodes
    let originalCurr = head
    while (originalCurr) {
        const originalNext = originalCurr.next
        const copyCurr = new Node(originalCurr.val)
        originalCurr.next = copyCurr
        copyCurr.next = originalNext
        originalCurr = originalNext
    }
    
    // Link Random Pointers
    originalCurr = head
    while (originalCurr) {
        if (originalCurr.random) {
            const copyCurr = originalCurr.next
            copyCurr.random = originalCurr.random.next    
        }
        
        originalCurr = originalCurr.next.next
    }
    
    // Get final copy list
    const copyHead = head.next
    originalCurr = head
    while (originalCurr) {
        const originalNext = originalCurr.next.next
        const copyCurr = originalCurr.next
        
        originalCurr.next = originalNext
        
        if (originalNext)
            copyCurr.next = originalNext.next
        
        originalCurr = originalCurr.next
    }
    
    return copyHead
};
```

## 143. Reorder List
```javascript
const reverse = node => {
    let prev = null
    let next = null
    
    while (node) {
        next = node.next
        node.next = prev
        prev = node
        node = next
    }
    return prev
}

const split = head => {
    let fast = head
    let slow = head
    let prev = null
    
    while (fast && fast.next) {
        prev = slow
        slow = slow.next
        fast = fast.next.next
    }
    
    prev.next = null
    return [head, slow]
}

const merge = (l1, l2) => {
    while (l1) {
        let nextL1 = l1.next
        let nextL2 = l2.next
        
        l1.next = l2

        if (!nextL1) break        
        l2.next = nextL1
        
        l1 = nextL1
        l2 = nextL2
    }
}

var reorderList = function(head) {
    if (!head || !head.next || !head.next.next) return head

    let [half1, half2] = split(head)
    half2 = reverse(half2)
    merge(half1, half2)
};
```

## 708. Insert into a Cyclic Sorted List
```javascript
var insert = function(head, insertVal) {
    if (!head) {
        const node = new Node(insertVal)
        node.next = node
        return node
    }
    
    let prev = head
    let next = head.next

    while (true) {
        if ((prev.val <= insertVal && insertVal <= next.val) ||
            (prev.val > next.val && insertVal < next.val) ||
            (prev.val > next.val && insertVal > prev.val)) {
            prev.next = new Node(insertVal, next)
            return head
        }
        
        prev = prev.next
        next = next.next
        if (prev === head) break
    }
    
    prev.next = new Node(insertVal, next)
    return head
};
```

## 92. Reverse Linked List II
```javascript
// Iterative
var reverseBetween = function(head, m, n) {
    if (!head) return head
    
    let dummy = new ListNode(NaN)
    dummy.next = head
    
    let prev = dummy
    
    while (--m) {
        prev = prev.next
        --n
    }
    
    let reverse = null
    let curr = prev.next
    let next = curr
    
    while (n--) {
        next = curr.next
        curr.next = reverse
        reverse = curr
        curr = next
    }
    
    prev.next.next = curr
    prev.next = reverse
    
    return dummy.next
};

// Recursion
var reverseBetween = function(head, m, n) {
    const _reverseBetween = (head, j) => {
        if (j <= 1) {
            successor = head.next
            return head
        }

        let root = _reverseBetween(head.next, j - 1)
        head.next.next = head
        head.next = successor
        return root    
    }
    
    let successor = null
    if (m <= 1)
        return _reverseBetween(head, n)
    
    head.next = reverseBetween(head.next, m - 1, n - 1)
    return  head
};
```

## 23. Merge k Sorted Lists
```javascript
// Heap
// Time - O(n log k)
// Space - O(k)
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if (!lists.length) return null
    
    const heap = new Heap([], (a, b) => a.node.val < b.node.val)
    for (let k = 0; k < lists.length; k++) {
        if (!lists[k]) continue
        
        const mergeNode = new MergeNode(lists[k], k)
        heap.insert(mergeNode)
    }
    
    const dummyHead = new ListNode(NaN)
    let curr = dummyHead
    
    while (heap.length()) {
        const { node, index } = heap.remove()
        
        curr.next = node
        curr = curr.next
        
        lists[index] = lists[index].next
        
        if (lists[index]) {
            heap.insert(new MergeNode(lists[index], index))
        }
    }
    
    return dummyHead.next
};

class MergeNode {
    constructor(node, index) {
        this.node = node
        this.index = index
    }
}

class Heap {
    constructor(elements, sortBy) {
        this.elements = elements
        this.sortBy = sortBy
        this.heapify()
    }
    
    heapify() {
        if (!this.elements.length) return
        
        for (let i = Math.floor(this.elements.length / 2) - 1; i >= 0; i--)
            this.siftDown(i)
    }
    
    peek() {
        return this.elements[0]
    }
    
    insert(val) {
        this.elements.push(val)
        this.siftUp()
    }
  
    remove() {
        if (!this.elements.length) return null
        
        let temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        let element = this.elements.pop()
        
        this.siftDown(0)
        
        return element
    }
    
    siftUp() {
        let childIndex = this.elements.length - 1
        let parentIndex = this.parentIndex(childIndex)
        
        while (childIndex > 0 && this.sortBy(this.elements[childIndex], this.elements[parentIndex])) {
            let temp = this.elements[parentIndex]
            this.elements[parentIndex] = this.elements[childIndex]
            this.elements[childIndex] = temp
            
            childIndex = parentIndex
            parentIndex = this.parentIndex(childIndex) 
        }
    }
    
    siftDown(index) {
        let parentIndex = index
        while (true) {
            let leftIndex = this.leftChildIndex(parentIndex)
            let rightIndex = this.rightChildIndex(parentIndex)
            let candidate = parentIndex
            
            if (leftIndex < this.elements.length && 
                this.sortBy(this.elements[leftIndex], this.elements[candidate]))
                candidate = leftIndex
            
            if (rightIndex < this.elements.length && 
                this.sortBy(this.elements[rightIndex], this.elements[candidate]))
                candidate = rightIndex
            
            if (parentIndex === candidate) return
            
            let temp = this.elements[parentIndex]
            this.elements[parentIndex] = this.elements[candidate]
            this.elements[candidate] = temp
          
            parentIndex = candidate
        }
    }
    
    leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }
    
    rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }
    
    parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }
    
    length() {
        return this.elements.length
    }
}

// Bottom Up Divide and Conquer
// Time - O(n log k)
// Space - O(1)
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if (!lists.length) return null
    
    const k = lists.length
    let interval = 1
    while (interval < k) {
        const step = interval * 2 
        for (let i = 0; i < k - interval; i += step) {
            lists[i] = merge(lists[i], lists[i + interval])
        }
        
        interval *= 2
    }
    
    return lists[0]
};

const merge = (l1, l2) => {
    if (!l1) return l2
    if (!l2) return l1
    
    const dummy = new ListNode(NaN)
    let curr = dummy
    
    while (l1 && l2) {
        if (l1.val < l2.val) {
            curr.next = l1
            l1 = l1.next
        } else {
            curr.next = l2
            l2 = l2.next
        }
        curr = curr.next
    }
    
    curr.next = l1 ? l1 : l2    
    return dummy.next
}
```

## 1046. Last Stone Weight
```javascript
// O(n log n)
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeight = function(stones) {
    const heap = new Heap(stones, ((a, b) => a > b))
    
    while (heap.size() > 1) {
        const y = heap.remove()
        const x = heap.remove()
        
        if (x === y) continue

        heap.insert(y - x)
    }
    
    return heap.size() ? heap.peek() : 0
};

class Heap {
    constructor(elements, sortBy) {
        this._elements = elements
        this._sortBy = sortBy
        this._heapify()
    }
    
    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }
    
    remove() {
        if (!this._elements.length) 
            return null
        
        this._swap(0, this._elements.length - 1)
        
        const element = this._elements.pop()
        this._siftDown(0)
        return element
    }
    
    peek() {
        return this._elements[0]
    }
    
    size() {
        return this._elements.length
    }
    
    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; i >= 0; i--) {
            this._siftDown(i)
        }
    }
    
    _siftUp(index) {
        let child = index
        let parent = this._parentIndex(child)
        
        while (child > 0 && this._sortBy(this._elements[child], this._elements[parent])) {
            this._swap(child, parent)
            child = parent
            parent = this._parentIndex(child)
        }
    }
    
    _siftDown(index) {
        let parent = index
        while (true) {
            const left = this._leftChildIndex(parent)
            const right = this._rightChildIndex(parent)
            let candidate = parent
            
            if (left < this._elements.length && 
                this._sortBy(this._elements[left], this._elements[candidate])) {
                candidate = left
            }
            
            if (right < this._elements.length && 
                this._sortBy(this._elements[right], this._elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent) {
                return
            }
            
            this._swap(candidate, parent)
            parent = candidate
        }
    }
    
    _leftChildIndex(index) {
        return 2 * index + 1
    }

    _rightChildIndex(index) {
        return 2 * index + 2
    }
    
    _parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }

    _swap(i, j) {
        const temp = this._elements[i]
        this._elements[i] = this._elements[j]
        this._elements[j] = temp
    }
}
```

## 703. Kth Largest Element in a Stream
```javascript
/**
 * @param {number} k
 * @param {number[]} nums
 */
var KthLargest = function(k, nums) {
    this.k = k
    this.heap = new Heap([], k, (a, b) => a < b)
    
    for (const num of nums) {
        this.heap.insert(num)
    }
};

/** 
 * @param {number} val
 * @return {number}
 */
KthLargest.prototype.add = function(val) {
    this.heap.insert(val)
    return this.heap.peek()
};

/** 
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(val)
 */

class Heap {
    constructor(elements, k, sortBy) {
        this._elements = elements
        this._capacity = k
        this._sortBy = sortBy
        this._heapify()
    }
    
    insert(element) {
        if (this._elements.length < this._capacity) {
            this._elements.push(element)
            this._siftUp(this._elements.length - 1)
        } else if (this.peek() < element) {
            this.remove()
            this._elements.push(element)
            this._siftUp(this._elements.length - 1)
        }
    }
    
    remove() {
        if (!this._elements.length) 
            return null
        
        this._swap(0, this._elements.length - 1)
        
        const element = this._elements.pop()
        this._siftDown(0)
        return element
    }
    
    peek() {
        return this._elements[0]
    }
    
    size() {
        return this._elements.length
    }
    
    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; i >= 0; i--) {
            this._siftDown(i)
        }
    }
    
    _siftUp(index) {
        let child = index
        let parent = this._parentIndex(child)
        
        while (child > 0 && this._sortBy(this._elements[child], this._elements[parent])) {
            this._swap(child, parent)
            child = parent
            parent = this._parentIndex(child)
        }
    }
    
    _siftDown(index) {
        let parent = index
        while (true) {
            const left = this._leftChildIndex(parent)
            const right = this._rightChildIndex(parent)
            let candidate = parent
            
            if (left < this._elements.length && 
                this._sortBy(this._elements[left], this._elements[candidate])) {
                candidate = left
            }
            
            if (right < this._elements.length && 
                this._sortBy(this._elements[right], this._elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent) {
                return
            }
            
            this._swap(candidate, parent)
            parent = candidate
        }
    }
    
    _leftChildIndex(index) {
        return 2 * index + 1
    }

    _rightChildIndex(index) {
        return 2 * index + 2
    }
    
    _parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }

    _swap(i, j) {
        const temp = this._elements[i]
        this._elements[i] = this._elements[j]
        this._elements[j] = temp
    }
}
```

## Heap Sort
```javascript
const heapSort = (elements, sortBy) => {
  const _heapify = () => {
    for (let i = Math.floor(elements.length / 2) + 1; i >= 0; i--)
      _siftDown(i)
  }
  
  const _siftDown = (index, size) => {
    let parent = index || 0
    size = size || elements.length
    
    while (true) {
      let left = _leftChildIndex(parent)
      let right = _rightChildIndex(parent)
      let candidate = parent
      
      if (left < size && sortBy(elements[left], elements[candidate]))
        candidate = left
      
      if (right < size && sortBy(elements[right], elements[candidate]))
        candidate = right
      
      if (candidate === parent) return
      [elements[candidate], elements[parent]] = [elements[parent], elements[candidate]]
      
      parent = candidate
    }
  }
  
  const _leftChildIndex = index => 2 * index + 1
  const _rightChildIndex = index => 2 * index + 2
  
  if (elements.length <= 1) return elements
  sortBy = sortBy || ((a, b) => a > b)
  _heapify()
  
  for (let i = elements.length - 1; i > 0; i--) {
    [elements[0], elements[i]] = [elements[i], elements[0]]
    _siftDown(0, i)
  }
}


const t = [1, 6, 4, 5, 3, 8, 7, 9, 8, 7, 3]
heapSort(t)
console.log(t)
```

## 973. K Closest Points to Origin
```javascript
// O(n)
// O(1)
/**
 * @param {number[][]} points
 * @param {number} k
 * @return {number[][]}
 */
var kClosest = function(points, k) {
    return quickSelect(points, k - 1)
};

const quickSelect = (arr, k) => {
    let left = 0
    let right = arr.length - 1
    
    while (left <= right) {
        const randomIndex = random(left, right)
        swap(arr, randomIndex, right)
        
        const partitionIndex = partition(arr, left, right)
        if (partitionIndex === k) {
            return arr.slice(0, k + 1)
        }
        
        if (partitionIndex < k) {
            left = partitionIndex + 1
        } else {
            right = partitionIndex - 1
        }
    }
    
    return []
}

const partition = (arr, low, high) => {
    let i = low - 1
    for (let j = low; j < high; j++) {
        if (dist(arr[j]) < dist(arr[high])) {
            swap(arr, ++i, j)
        }
    }
    
    swap(arr, ++i, high)
    return i
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

const dist = point => point[0] ** 2 + point[1] ** 2
const random = (low, high) => Math.trunc(Math.random() * (high - low + 1)) + low

// O(n log k)
// O(k)
/**
 * @param {number[][]} points
 * @param {number} K
 * @return {number[][]}
 */
var kClosest = function(points, K) {
    const heap = new Heap([], K, ((a, b) => dist(a) > dist(b)))
    
    for (const point of points) {
        heap.insert(point)
    }
    
    return heap._elements
};

const dist = point => {
    return Math.sqrt(point[0] ** 2 + point[1] ** 2)
}

class Heap {
    constructor(elements, k, sortBy) {
        this._elements = elements
        this._capacity = k
        this._sortBy = sortBy
        this._heapify()
    }
        
    insert(element) {
        if (this._atCapacity() && this._sortBy(this.peek(), element))
            this.remove()
        
        if (!this._atCapacity()) {
            this._elements.push(element)
            this._siftUp(this._elements.length - 1)   
        }
    }
    
    remove() {
        if (!this._elements.length) 
            return null
        
        this._swap(0, this._elements.length - 1)
        
        const element = this._elements.pop()
        this._siftDown(0)
        return element
    }
    
    peek() {
        return this._elements[0]
    }
    
    size() {
        return this._elements.length
    }
    
    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; i >= 0; i--) {
            this._siftDown(i)
        }
    }
    
    _siftUp(index) {
        let child = index
        let parent = this._parentIndex(child)
        
        while (child > 0 && this._sortBy(this._elements[child], this._elements[parent])) {
            this._swap(child, parent)
            child = parent
            parent = this._parentIndex(child)
        }
    }
    
    _siftDown(index) {
        let parent = index
        while (true) {
            const left = this._leftChildIndex(parent)
            const right = this._rightChildIndex(parent)
            let candidate = parent
            
            if (left < this._elements.length && 
                this._sortBy(this._elements[left], this._elements[candidate])) {
                candidate = left
            }
            
            if (right < this._elements.length && 
                this._sortBy(this._elements[right], this._elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent) {
                return
            }
            
            this._swap(candidate, parent)
            parent = candidate
        }
    }
    
    _leftChildIndex(index) {
        return 2 * index + 1
    }

    _rightChildIndex(index) {
        return 2 * index + 2
    }
    
    _parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }

    _swap(i, j) {
        const temp = this._elements[i]
        this._elements[i] = this._elements[j]
        this._elements[j] = temp
    }
    
    _atCapacity() {
        return this._elements.length >= this._capacity
    }
}
```

## 451. Sort Characters By Frequency
```javascript
// HashMap + Comparative Sort - Time: O(N + K Log K)
/**
 * @param {string} s
 * @return {string}
 */
var frequencySort = function(s) {
    const chars = {}
    for (const char of s) {
        chars[char] = 1 + (chars[char] || 0)
    }
    
    const entries = Object.entries(chars)
    entries.sort((a, b) => b[1] - a[1])
    
    const result = []
    for (const [char, freq] of entries) {
        result.push(char.repeat(freq))
    }
    
    return result.join('')
};

// HashMap + Counting Sort - Time: O(N)
/**
 * @param {string} s
 * @return {string}
 */
var frequencySort = function(s) {
    let max = 0
    const chars = {}
    for (const char of s) {
        chars[char] = 1 + (chars[char] || 0)
        max = Math.max(max, chars[char])
    }
    
    const buckets = Array(max + 1).fill().map(a => [])
    for (const [char, freq] of Object.entries(chars)) {
        buckets[freq].push(char)
    }
    
    const result = []
    for (let freq = buckets.length - 1; freq >= 0; freq--) {
        for (const char of buckets[freq]) {
            result.push(char.repeat(freq))
        }
    }
    
    return result.join('')
};
```

## 347. Top K Frequent Elements
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
const frequencies = nums => {
    return nums.reduce((result, num) => {
        result[num] = 1 + (result[num] || 0)
        return result
    }, {})
}

var topKFrequent = function(nums, k) {
    const buckets = []
    for (let [key, value] of Object.entries(frequencies(nums))) {
        key = +key
        
        if (!buckets[value]) {
            buckets[value] = [key]
            continue
        }
        buckets[value].push(key)
    }

    const result = []
    for (let i = buckets.length - 1; i >= 0; i--) {
        if (result.length >= k) break

        if (!buckets[i]) continue
        
        for (let num of buckets[i])
            result.push(num)        
    }

    return result    
};

// Quick Select
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    const freq = {}
    for (const num of nums) {
        freq[num] = 1 + (freq[num] || 0)
    }
    
    const counts = Object.entries(freq)
    const index = quickSelect(counts, k)
    const kFrequent = counts.slice(index)
    return kFrequent.map(pair => pair[0])
};

const quickSelect = (arr, k) => {
    const target = arr.length - k
    let left = 0
    let right = arr.length - 1
    
    while (left <= right) {
        const randomIndex = random(left, right)
        const temp = arr[randomIndex]
        arr[randomIndex] = arr[right]
        arr[right] = temp
        
        const partitionIndex = partition(arr, left, right)
        if (partitionIndex === target) {
            return partitionIndex
        } else if (partitionIndex < target) {
            left = partitionIndex + 1
        } else {
            right = partitionIndex - 1
        }
    }
}

const random = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min
}

const partition = (arr, left, right) => {
    const pivot = arr[right][1]
    let i = left - 1
    
    for (let j = left; j <= right; j++) {
        if (arr[j][1] <= pivot) {
            i++
            
            const temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
    }
    
    return i
}

// Heap
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    const chars = {}
    for (const num of nums) {
        chars[num] = 1 + (chars[num] || 0)
    }
    
    const heap = new Heap([], k, ((a, b) => chars[a] < chars[b]))
    for (const char of Object.keys(chars)) {
        heap.insert(char)
    }
    
    return heap._elements
};

class Heap {
    constructor(elements, k, sortBy) {
        this._elements = elements
        this._capacity = k
        this._sortBy = sortBy
        this._heapify()
    }
        
    insert(element) {
        if (this._atCapacity() && this._sortBy(this.peek(), element))
            this.remove()
        
        if (!this._atCapacity()) {
            this._elements.push(element)
            this._siftUp(this._elements.length - 1)   
        }
    }
    
    remove() {
        if (!this._elements.length) 
            return null
        
        this._swap(0, this._elements.length - 1)
        
        const element = this._elements.pop()
        this._siftDown(0)
        return element
    }
    
    peek() {
        return this._elements[0]
    }
    
    size() {
        return this._elements.length
    }
    
    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; i >= 0; i--) {
            this._siftDown(i)
        }
    }
    
    _siftUp(index) {
        let child = index
        let parent = this._parentIndex(child)
        
        while (child > 0 && this._sortBy(this._elements[child], this._elements[parent])) {
            this._swap(child, parent)
            child = parent
            parent = this._parentIndex(child)
        }
    }
    
    _siftDown(index) {
        let parent = index
        while (true) {
            const left = this._leftChildIndex(parent)
            const right = this._rightChildIndex(parent)
            let candidate = parent
            
            if (left < this._elements.length && 
                this._sortBy(this._elements[left], this._elements[candidate])) {
                candidate = left
            }
            
            if (right < this._elements.length && 
                this._sortBy(this._elements[right], this._elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent) {
                return
            }
            
            this._swap(candidate, parent)
            parent = candidate
        }
    }
    
    _leftChildIndex(index) {
        return 2 * index + 1
    }

    _rightChildIndex(index) {
        return 2 * index + 2
    }
    
    _parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }

    _swap(i, j) {
        const temp = this._elements[i]
        this._elements[i] = this._elements[j]
        this._elements[j] = temp
    }
    
    _atCapacity() {
        return this._elements.length >= this._capacity
    }
}
```

## 215. Kth Largest Element in an Array
```javascript
// Heap
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    const heap = new Heap([], k, ((a, b) => a < b))
    
    for (const num of nums) {
        heap.insert(num)
    }
    
    return heap.peek()
};

class Heap {
    constructor(elements, k, sortBy) {
        this._elements = elements
        this._capacity = k
        this._sortBy = sortBy
        this._heapify()
    }
        
    insert(element) {
        if (this._atCapacity() && this._sortBy(this.peek(), element))
            this.remove()
        
        if (!this._atCapacity()) {
            this._elements.push(element)
            this._siftUp(this._elements.length - 1)   
        }
    }
    
    remove() {
        if (!this._elements.length) 
            return null
        
        this._swap(0, this._elements.length - 1)
        
        const element = this._elements.pop()
        this._siftDown(0)
        return element
    }
    
    peek() {
        return this._elements[0]
    }
    
    size() {
        return this._elements.length
    }
    
    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; i >= 0; i--) {
            this._siftDown(i)
        }
    }
    
    _siftUp(index) {
        let child = index
        let parent = this._parentIndex(child)
        
        while (child > 0 && this._sortBy(this._elements[child], this._elements[parent])) {
            this._swap(child, parent)
            child = parent
            parent = this._parentIndex(child)
        }
    }
    
    _siftDown(index) {
        let parent = index
        while (true) {
            const left = this._leftChildIndex(parent)
            const right = this._rightChildIndex(parent)
            let candidate = parent
            
            if (left < this._elements.length && 
                this._sortBy(this._elements[left], this._elements[candidate])) {
                candidate = left
            }
            
            if (right < this._elements.length && 
                this._sortBy(this._elements[right], this._elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent) {
                return
            }
            
            this._swap(candidate, parent)
            parent = candidate
        }
    }
    
    _leftChildIndex(index) {
        return 2 * index + 1
    }

    _rightChildIndex(index) {
        return 2 * index + 2
    }
    
    _parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }

    _swap(i, j) {
        const temp = this._elements[i]
        this._elements[i] = this._elements[j]
        this._elements[j] = temp
    }
    
    _atCapacity() {
        return this._elements.length >= this._capacity
    }
}

// Quick Select
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    return quickSelect(nums, nums.length - k)
};

const quickSelect = (nums, k) => {
    let left = 0
    let right = nums.length - 1
    
    while (left <= right) {
        const randomIndex = random(left, right)
        swap(nums, left, right)
        
        const partitionIndex = partition(nums, left, right)
        if (partitionIndex === k) {
            return nums[k]
        }
        
        if (partitionIndex < k) {
            left = partitionIndex + 1
        } else {
            right = partitionIndex - 1
        }
    }
    
    return -1
}

const partition = (arr, low, high) => {
    let i = low - 1
    for (let j = low; j < high; j++) {
        if (arr[j] < arr[high]) {
            i++
            swap(arr, i, j)
        }
    }
    
    i++
    swap(arr, i, high)
    return i
}

const random = (low, high) => {
    return Math.floor(Math.random() * (high - low + 1)) + low
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

// Counting Sort
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    let max = null
    let min = null
    
    for (const num of nums) {
        max = Math.max(num, max || -Number.MAX_VALUE)
        min = Math.min(num, min || Number.MAX_VALUE)
    }
    
    let offset = min >= 0 ? 0 : Math.abs(min)
    
    const counts = Array(max + offset + 1).fill(0)
    for (const num of nums)
        counts[num + offset]++
    
    const result = []
    for (let i = 0; i < counts.length; i++)
        while (counts[i]--)
            result.push(i - offset)
    
    return result[result.length - k]
};
```

## 692. Top K Frequent Words
```javascript
/**
 * @param {string[]} words
 * @param {number} k
 * @return {string[]}
 */
var topKFrequent = function(words, k) {
    const heap = new Heap([], (a, b) => {
        if (a[1] === b[1]) {
            return a[0] > b[0]
        }
        
        return a[1] < b[1]
    })
    
    const map = {}
    for (const word of words) {
        map[word] = 1 + (map[word] || 0)
    }
    
    for (const entry of Object.entries(map)) {
        heap.insert(entry)
        
        if (heap.size() > k) {
            heap.remove()
        }
    }
    
    const result = []
    while (heap.size()) {
        result.push(heap.remove()[0])
    }
    
    return result.reverse()
};

class Heap {
  constructor(elements, sort = ((a, b) => { return a < b })) {
    this._elements = elements
    this._sort = sort
    this._heapify()
  }
  
  _heapify() {
    for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
      this._siftDown(i);
    }
  }
  
  _siftUp(index) {
    let childIndex = index
    let parentIndex = this._parentIndex(childIndex)
    
    while (childIndex > 0 && 
           this._sort(this._elements[childIndex], this._elements[parentIndex])) {
      let temp = this._elements[childIndex]
      this._elements[childIndex] = this._elements[parentIndex]
      this._elements[parentIndex] = temp
      
      childIndex = parentIndex
      parentIndex = this._parentIndex(childIndex)
    }
    
  }
  
  _siftDown(index) {
    let parentIndex = index
    while (true) {
      let leftIndex = this._leftChildIndex(parentIndex)
      let rightIndex = this._rightChildIndex(parentIndex)
      let candidate = parentIndex
      
      if (leftIndex < this._elements.length && 
          this._sort(this._elements[leftIndex], this._elements[candidate])) {
        candidate = leftIndex
      }
            
      if (rightIndex < this._elements.length && 
          this._sort(this._elements[rightIndex], this._elements[candidate])) {
        candidate = rightIndex
      }
      
      if (parentIndex === candidate) {
        return
      }
      
      let temp = this._elements[parentIndex]
      this._elements[parentIndex] = this._elements[candidate]
      this._elements[candidate] = temp
      
      parentIndex = candidate
    }
  }
  
  _leftChildIndex(parentIndex) {
    return 2 * parentIndex + 1
  }
  
  _rightChildIndex(parentIndex) {
    return 2 * parentIndex + 2
  }
  
  _parentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  
  insert(element) {
    this._elements.push(element)
    this._siftUp(this._elements.length - 1)
  }
  
  remove() {
    if (this._elements.length < 1) {
      return null
    }
    
    let temp = this._elements[0]
    this._elements[0] = this._elements[this._elements.length - 1]
    this._elements[this._elements.length - 1] = temp
    
    let element = this._elements.pop()
    this._siftDown(0)
    return element
  }
    
    size() {
        return this._elements.length
    }
}
```

## 442. Find All Duplicates in an Array
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDuplicates = function(nums) {
    const result = []
    for (const num of nums) {
        const index = Math.abs(num) - 1
        
        if (nums[index] < 0) {
            result.push(Math.abs(num))
        }
        
        nums[index] *= -1
    }
    
    return result
};
```

## 153. Find Minimum in Rotated Sorted Array
```javascript
// O(log n)
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    let left = 0
    let right = nums.length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        // right side sorted
        if (nums[mid] < nums[right]) {
            right = mid
        } 
        // left side sorted
        else {
            left = mid + 1
        }
    }
    
    return nums[left]
};
```

## 33. Search in Rotated Sorted Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0
    let right = nums.length - 1
    
    while (left <= right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        if (nums[mid] === target) {
            return mid
        }
        
        // if left is sorted
        if (nums[left] <= nums[mid]) {
            // if target is sorted range
            if (nums[left] <= target && target <= nums[mid]) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } 
        // if right is sorted
        else {
            if (nums[mid] <= target && target <= nums[right]) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    
    return -1
};
```

## 378. Kth Smallest Element in a Sorted Matrix
```javascript
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(matrix, k) {
    const heap = new Heap([], k, ((a, b) => a > b))
    
    for (let row = 0; row < matrix.length; row++) {
        for (let col = 0; col < matrix.length; col++) {
            heap.insert(matrix[row][col])
        }
    }
    
    return heap.peek()
};

class Heap {
    constructor(elements, k, sortBy) {
        this._elements = elements
        this._capacity = k
        this._sortBy = sortBy
        this._heapify()
    }
        
    insert(element) {
        if (this._atCapacity() && this._sortBy(this.peek(), element))
            this.remove()
        
        if (!this._atCapacity()) {
            this._elements.push(element)
            this._siftUp(this._elements.length - 1)   
        }
    }
    
    remove() {
        if (!this._elements.length) 
            return null
        
        this._swap(0, this._elements.length - 1)
        
        const element = this._elements.pop()
        this._siftDown(0)
        return element
    }
    
    peek() {
        return this._elements[0]
    }
    
    size() {
        return this._elements.length
    }
    
    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; i >= 0; i--) {
            this._siftDown(i)
        }
    }
    
    _siftUp(index) {
        let child = index
        let parent = this._parentIndex(child)
        
        while (child > 0 && this._sortBy(this._elements[child], this._elements[parent])) {
            this._swap(child, parent)
            child = parent
            parent = this._parentIndex(child)
        }
    }
    
    _siftDown(index) {
        let parent = index
        while (true) {
            const left = this._leftChildIndex(parent)
            const right = this._rightChildIndex(parent)
            let candidate = parent
            
            if (left < this._elements.length && 
                this._sortBy(this._elements[left], this._elements[candidate])) {
                candidate = left
            }
            
            if (right < this._elements.length && 
                this._sortBy(this._elements[right], this._elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent) {
                return
            }
            
            this._swap(candidate, parent)
            parent = candidate
        }
    }
    
    _leftChildIndex(index) {
        return 2 * index + 1
    }

    _rightChildIndex(index) {
        return 2 * index + 2
    }
    
    _parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }

    _swap(i, j) {
        const temp = this._elements[i]
        this._elements[i] = this._elements[j]
        this._elements[j] = temp
    }
    
    _atCapacity() {
        return this._elements.length >= this._capacity
    }
}
```

## 373. Find K Pairs with Smallest Sums
```javascript
class Heap {
    constructor(elements, capacity, sortBy) {
        this.elements = elements
        this.capacity = capacity
        this.sortBy = sortBy
        
        if (this.elements.length)
            this.heapify()
    }
    
    heapify() {
        for (let i = Math.floor(this.elements.length / 2) + 1; i >= 0; i--)
            this.siftDown(i)
    }
    
    siftDown(index) {
        let parent = index || 0
        while (true) {
            let left = this.leftChildIndex(parent)
            let right = this.rightChildIndex(parent)
            let candidate = parent
            
            if (left < this.elements.length && this.sortBy(this.elements[left], this.elements[candidate]))
                candidate = left
            
            if (right < this.elements.length && this.sortBy(this.elements[right], this.elements[candidate]))
                candidate = right
            
            if (parent === candidate) return
            
            let temp = this.elements[parent]
            this.elements[parent] = this.elements[candidate]
            this.elements[candidate] = temp
            
            parent = candidate
        }
    }
    
    siftUp(index) {
        let child = index || this.elements.length - 1
        let parent = this.parentIndex(child)
        
        while (child > 0 && this.sortBy(this.elements[child], this.elements[parent])) {
            let temp = this.elements[child]
            this.elements[child] = this.elements[parent]
            this.elements[parent] = temp
            
            child = parent
            parent = this.parentIndex(child)
        }
    }
    
    atCapacity() {
        return this.elements.length >= this.capacity
    }
    
    insert(val) {
        if (this.atCapacity() && this.sortBy(val, this.elements[0]))
            this.remove()
        
        if (!this.atCapacity()) {
            this.elements.push(val)
            this.siftUp()
        }
    }
    
    remove() {
        if (!this.elements.length) return null
        
        let temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        let element = this.elements.pop()
        
        this.siftDown()
        
        return element
    }
    
    leftChildIndex(index) {
        return 2 * index + 1
    }
    
    rightChildIndex(index) {
        return 2 * index + 2
    }
    
    parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }
}

class Node {
    constructor(sum, leftVal, rightVal, rightPos) {
        this.sum = sum
        this.leftVal = leftVal
        this.rightVal = rightVal
        this.rightPos = rightPos
    }
}

var kSmallestPairs = function(nums1, nums2, k) {
    if (!nums1.length || !nums2.length) return []
    
    const heap = new Heap([], k, (a, b) => a.sum < b.sum)
    const result = []
    
    for (let i = 0; i < nums1.length; i++) {
        const node = new Node(nums1[i] + nums2[0], nums1[i], nums2[0], 0)
        heap.insert(node)
    }
    
    while (k > 0) {
        const node = heap.remove()
        
        if (!node) break
        result.push([node.leftVal, node.rightVal])
        
        if (node.rightPos < nums2.length - 1) {
            const newNode = new Node(node.leftVal + nums2[node.rightPos + 1], 
                                     node.leftVal, 
                                     nums2[node.rightPos + 1], 
                                     node.rightPos + 1)
            heap.insert(newNode)
        }
        k--
    }
    
    return result
};
```

## 621. Task Scheduler
```javascript
/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function(tasks, n) {
    const map = {}
    for (const task of tasks) {
        map[task] = 1 + (map[task] || 0)
    }
    
    let time = 0
    
    const heap = new Heap(Object.values(map), (a, b) => a > b)
    const queue = []
    while (heap.size() || queue.length) {
        if (heap.size()) {
            const count = heap.remove()
            if (count - 1 > 0)
                queue.push([count - 1, time])
        }
        
        time++
        
        if (queue.length && time - queue[0][1] > n) {
            const [nextCount] = queue.shift()
            heap.insert(nextCount)
        }
    }
    
    return time
};

class Heap {
  constructor(elements, sort = ((a, b) => { return a < b })) {
    this._elements = elements
    this._sort = sort
    this._heapify()
  }
  
  _heapify() {
    for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
      this._siftDown(i);
    }
  }
  
  _siftUp(index) {
    let childIndex = index
    let parentIndex = this._parentIndex(childIndex)
    
    while (childIndex > 0 && 
           this._sort(this._elements[childIndex], this._elements[parentIndex])) {
      let temp = this._elements[childIndex]
      this._elements[childIndex] = this._elements[parentIndex]
      this._elements[parentIndex] = temp
      
      childIndex = parentIndex
      parentIndex = this._parentIndex(childIndex)
    }
    
  }
  
  _siftDown(index) {
    let parentIndex = index
    while (true) {
      let leftIndex = this._leftChildIndex(parentIndex)
      let rightIndex = this._rightChildIndex(parentIndex)
      let candidate = parentIndex
      
      if (leftIndex < this._elements.length && 
          this._sort(this._elements[leftIndex], this._elements[candidate])) {
        candidate = leftIndex
      }
            
      if (rightIndex < this._elements.length && 
          this._sort(this._elements[rightIndex], this._elements[candidate])) {
        candidate = rightIndex
      }
      
      if (parentIndex === candidate) {
        return
      }
      
      let temp = this._elements[parentIndex]
      this._elements[parentIndex] = this._elements[candidate]
      this._elements[candidate] = temp
      
      parentIndex = candidate
    }
  }
  
  _leftChildIndex(parentIndex) {
    return 2 * parentIndex + 1
  }
  
  _rightChildIndex(parentIndex) {
    return 2 * parentIndex + 2
  }
  
  _parentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  
  insert(element) {
    this._elements.push(element)
    this._siftUp(this._elements.length - 1)
  }
  
  remove() {
    if (this._elements.length < 1) {
      return null
    }
    
    let temp = this._elements[0]
    this._elements[0] = this._elements[this._elements.length - 1]
    this._elements[this._elements.length - 1] = temp
    
    let element = this._elements.pop()
    this._siftDown(0)
    return element
  }
    
    size() {
        return this._elements.length
    }
}
```

## 767. Reorganize String
```javascript
/**
 * @param {string} S
 * @return {string}
 */
var reorganizeString = function(S) {
    const map = {}
    for (const char of S) {
        map[char] = 1 + (map[char] || 0)
    }
    
    const heap = new Heap(Object.entries(map), (a, b) => a[1] > b[1])
    const result = []
    
    while (heap.length() > 1) {
        const [val1, count1] = heap.remove()
        const [val2, count2] = heap.remove()
        
        result.push(val1)
        result.push(val2)
        
        if (count1 - 1 > 0)
            heap.insert([val1, count1 - 1])
        
        if (count2 - 1 > 0)
            heap.insert([val2, count2 - 1])
    }
    
    if (heap.length()) {
        const [val, count] = heap.remove()
        if (count > 1) return ''
        result.push(val)
    }
    
    return result.join('')
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 358. Rearrange String k Distance Apart
```javascript
class Heap {
    constructor(elements, sortBy) {
        this.elements = elements
        this.sortBy = sortBy
        
        if (this.elements.length)
            this.heapify()
    }
    
    heapify() {
        for (let i = Math.floor(this.elements.length / 2) + 1; i >= 0; i--)
            this.siftDown(i)
            
    }
    
    siftDown(index) {
        let parent = index || 0
        while (true) {
            let left = this.leftChildIndex(parent)
            let right = this.rightChildIndex(parent)
            let candidate = parent
            
            if (left < this.elements.length && this.sortBy(this.elements[left], this.elements[candidate]))
                candidate = left
            
            if (right < this.elements.length && this.sortBy(this.elements[right], this.elements[candidate]))
                candidate = right
            
            if (candidate === parent) return
            
            let temp = this.elements[parent]
            this.elements[parent] = this.elements[candidate]
            this.elements[candidate] = temp
            
            parent = candidate
        }
    }
    
    siftUp(index) {
        let child = index || this.elements.length - 1
        let parent = this.parentIndex(child)
        
        while (child > 0 && this.sortBy(this.elements[child], this.elements[parent])) {
            let temp = this.elements[child]
            this.elements[child] = this.elements[parent]
            this.elements[parent] = temp
            
            child = parent
            parent = this.parentIndex(child)
        }
    }
    
    insert(val) {
        this.elements.push(val)
        this.siftUp()
    }
    
    remove() {
        if (!this.elements.length) return null
        
        let temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        let element = this.elements.pop()
        
        this.siftDown()
        
        return element
    }
    
    leftChildIndex(index) {
        return 2 * index + 1
    }
    
    rightChildIndex(index) {
        return 2 * index + 2
    }
    
    parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }
    
    isEmpty() {
        return this.elements.length === 0
    }
}

const counts = str => {
    return str.split('').reduce((result, ele) => {
        result[ele] = 1 + (result[ele] || 0)
        return result
    }, {})
}

var rearrangeString = function(s, k) {
    const strCounts = Object.entries(counts(s))
    const heap = new Heap(strCounts, (a, b) => a[1] > b[1])
    const result = []
    const queue = []
    
    while (!heap.isEmpty()) {
        const curr = heap.remove()
        result.push(curr[0])
        curr[1]--
        queue.push(curr)
        
        if (queue.length < k) continue
        
        let element = queue.shift()
        if (element[1] > 0) heap.insert(element)
    }

    return result.length == s.length ? result.join('') : ''
};
```

## 1054. Distant Barcodes
```javascript
/**
 * @param {number[]} barcodes
 * @return {number[]}
 */
var rearrangeBarcodes = function(barcodes) {
    let max = null
    const map = {}
    for (const barcode of barcodes) {    
        map[barcode] = 1 + (map[barcode] || 0)
        
        if (max === null || map[max] < map[barcode]) {
            max = barcode
        }
    }
    
    const result = new Array(barcodes.length)
    let k = 0
    
    while (map[max]--) {
        result[k] = max
        k += 2
        if (k >= result.length) k = 1
    }
    
    for (const [val, freq] of Object.entries(map)) {
        for (let i = 0; i < freq; i++) {
            result[k] = +val
            k += 2
            if (k >= result.length) k = 1
        }
    }
    
    return result
};
```

## 253. Meeting Rooms II
```javascript
// Heap
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var minMeetingRooms = function(intervals) {
    if (!intervals.length) return 0
    intervals.sort((a, b) => a[0] - b[0])
    
    const heap = new Heap([intervals[0]], ((a, b) => a[1] < b[1]))
    
    for (let i = 1; i < intervals.length; i++) {
        const top = heap.peek()
        
        if (top[1] <= intervals[i][0]) {
            heap.remove()   
        }
        
        heap.insert(intervals[i])
    }
    
    return heap.length()
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}

// Two Pointer
var minMeetingRooms = function(intervals) {
    const starts = intervals.map(i => i[0]).sort((a, b) => a - b)
    const ends = intervals.map(i => i[1]).sort((a, b) => a - b)
    
    let s = 0
    let e = 0
    let rooms = 0
    
    while (s < intervals.length) {
        if (starts[s] >= ends[e]) {
            rooms--
            e++
        }
        
        rooms++
        s++
    }
    
    return rooms
};
```

## 263. Ugly Number
```javascript
var isUgly = function(num) {
    if (num <= 0) return false
    while (num % 2 == 0) num /= 2
    while (num % 3 == 0) num /= 3
    while (num % 5 == 0) num /= 5
    return num == 1
};
```

## 264. Ugly Number II
```javascript
class Heap {
    constructor(elements, sortBy) {
        this.elements = elements
        this.sortBy = sortBy
        
        if (this.elements.length)
            this.heapify()
    }
    
    heapify() {
        for (let i = Math.floor(this.elements.length / 2) + 1; i >= 0; i--)
            this.siftDown(i)
    }
    
    siftDown(index) {
        let parent = index || 0
        while (true) {
            let left = this.leftChildIndex(parent)
            let right = this.rightChildIndex(parent)
            let candidate = parent
            
            if (left < this.elements.length && this.sortBy(this.elements[left], this.elements[candidate]))
                candidate = left
            
            if (right < this.elements.length && this.sortBy(this.elements[right], this.elements[candidate]))
                candidate = right
            
            if (candidate === parent) return
            
            let temp = this.elements[candidate]
            this.elements[candidate] = this.elements[parent]
            this.elements[parent] = temp
            
            parent = candidate
        }
    } 
    
    siftUp(index) {
        let child = index || this.elements.length - 1
        let parent = this.parentIndex(child)
        
        while (child > 0 && this.sortBy(this.elements[child], this.elements[parent])) {
            let temp = this.elements[child]
            this.elements[child] = this.elements[parent]
            this.elements[parent] = temp
            
            child = parent
            parent = this.parentIndex(child)
        }
    }
    
    insert(val) {
        this.elements.push(val)
        this.siftUp()
    }
    
    remove() {
        if (!this.elements.length) return null
        
        let temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        let element = this.elements.pop()
        
        this.siftDown()
        
        return element
    }
    
    leftChildIndex(index) {
        return 2 * index + 1
    }
    
    rightChildIndex(index) {
        return 2 * index + 2
    }
    
    parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }
}

const cache = { 1: 1 }
var nthUglyNumber = function(n) {
    if (cache[n]) return cache[n]
    
    const heap = new Heap([1], (a, b) => a < b)
    const primes = [2, 3, 5]
    const seen = new Set()
    
    for (let i = n; i > 0; i--) {
        const top = heap.remove()
        cache[n] = top
        
        for (const num of primes) {
            const currNum = top * num
            if (!seen.has(currNum)) {
                heap.insert(currNum)
                seen.add(currNum)
            }
        }
    }
    
    return cache[n]
};
```

## 313. Super Ugly Number
```javascript
var nthSuperUglyNumber = function(n, primes) {
    if (n === 1) return 1
    
    const heap = new Heap([1], (a, b) => a < b)
    const seen = new Set()
    let last = 0
    
    for (let i = n; i > 0; i--) {
        const top = heap.remove()
        last = top
        
        for (const num of primes) {
            const currNum = top * num
            if (!seen.has(currNum)) {
                heap.insert(currNum)
                seen.add(currNum)
            }
        }
    }
    
    return last
};

class Heap {
    constructor(elements, sortBy) {
        this.elements = elements
        this.sortBy = sortBy
        
        if (this.elements.length)
            this.heapify()
    }
    
    heapify() {
        for (let i = Math.floor(this.elements.length / 2) + 1; i >= 0; i--)
            this.siftDown(i)
    }
    
    siftDown(index) {
        let parent = index || 0
        while (true) {
            let left = this.leftChildIndex(parent)
            let right = this.rightChildIndex(parent)
            let candidate = parent
            
            if (left < this.elements.length && this.sortBy(this.elements[left], this.elements[candidate]))
                candidate = left
            
            if (right < this.elements.length && this.sortBy(this.elements[right], this.elements[candidate]))
                candidate = right
            
            if (candidate === parent) return
            
            let temp = this.elements[candidate]
            this.elements[candidate] = this.elements[parent]
            this.elements[parent] = temp
            
            parent = candidate
        }
    } 
    
    siftUp(index) {
        let child = index || this.elements.length - 1
        let parent = this.parentIndex(child)
        
        while (child > 0 && this.sortBy(this.elements[child], this.elements[parent])) {
            let temp = this.elements[child]
            this.elements[child] = this.elements[parent]
            this.elements[parent] = temp
            
            child = parent
            parent = this.parentIndex(child)
        }
    }
    
    insert(val) {
        this.elements.push(val)
        this.siftUp()
    }
    
    remove() {
        if (!this.elements.length) return null
        
        let temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        let element = this.elements.pop()
        
        this.siftDown()
        
        return element
    }
    
    leftChildIndex(index) {
        return 2 * index + 1
    }
    
    rightChildIndex(index) {
        return 2 * index + 2
    }
    
    parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }
}
```

## 787. Cheapest Flights Within K Stops
```javascript
// BFS
var findCheapestPrice = function(n, flights, src, dst, K) {
    const graph = {}
    
    for (const [vertex, neighbor, weight] of flights) {
        if (!graph[vertex]) {
            graph[vertex] = [[neighbor, weight]]
        } else {
            graph[vertex].push([neighbor, weight])
        }
    }

    const queue = [[src, 0, 0]]
    let minCost = Number.MAX_VALUE
    
    while (queue.length) {
        const [node, stops, costSoFar] = queue.shift()
        
        if (node === dst) {
            minCost = Math.min(minCost, costSoFar)
            continue
        }
        
        if (stops > K || costSoFar > minCost)
            continue
        
        if (!graph[node])
            continue
        
        for (const [neighbor, cost] of graph[node]) {
            queue.push([neighbor, stops + 1, costSoFar + cost])
        }
    }
    
    return minCost !== Number.MAX_VALUE ? minCost : -1
};

// Dijkstra's
class Heap {
    constructor(elements, sortBy) {
        this.elements = elements
        this.sortBy = sortBy
        
        if (this.elements.length)
            this.heapify()
    }
    
    heapify() {
        for (let i = Math.floor(this.elements.length / 2) + 1; i >= 0; i--)
            this.siftDown(i)
    }
    
    insert(val) {
        this.elements.push(val)
        this.siftUp()
    }
    
    remove() {
        if (!this.elements.length) return null
        
        let temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        let element = this.elements.pop()
        
        this.siftDown()
        
        return element
    }
    
    siftUp(index) {
        let child = index || this.elements.length - 1
        let parent = this.parentIndex(child)
        
        while (child > 0 && this.sortBy(this.elements[child], this.elements[parent])) {
            let temp = this.elements[child]
            this.elements[child] = this.elements[parent]
            this.elements[parent] = temp
            
            child = parent
            parent = this.parentIndex(child)
        }
    }
    
    siftDown(index) {
        let parent = index || 0
        while(true) {
            let left = this.leftChildIndex(parent)
            let right = this.rightChildIndex(parent)
            let candidate = parent
            
            if (left < this.elements.length && this.sortBy(this.elements[left], this.elements[candidate]))
                candidate = left
            
            if (right < this.elements.length && this.sortBy(this.elements[right], this.elements[candidate]))
                candidate = right
            
            if (candidate === parent)
                return
            
            let temp = this.elements[candidate]
            this.elements[candidate] = this.elements[parent]
            this.elements[parent] = temp
            
            parent = candidate
        }
    }
    
    leftChildIndex(parent) {
        return 2 * parent + 1
    }
    
    rightChildIndex(parent) {
        return 2 * parent + 2
    }
    
    parentIndex(child) {
        return Math.floor((child - 1) / 2)
    }
}

var findCheapestPrice = function(n, flights, src, dst, K) {
    const graph = {}
    for (const [vertex, neighbor, weight] of flights) {
        if (!graph[vertex]) {
            graph[vertex] = [[neighbor, weight]]
        } else {
            graph[vertex].push([neighbor, weight])
        }
    }
    
    const heap = new Heap([], (a, b) => a[1] < b[1])
    heap.insert([src, 0, 0])
    
    while (heap.elements.length) {
        const [vertex, costSoFar, stops] = heap.remove()
        
        if (vertex === dst)
            return costSoFar
        
        if (stops > K)
            continue
        
        if (!graph[vertex]) continue
        
        for (const [neighbor, weight] of graph[vertex]) {
            heap.insert([neighbor, costSoFar + weight, stops + 1])
        }
    }
    
    return -1
};
```

## 743. Network Delay Time
```javascript
/**
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var networkDelayTime = function(times, n, k) {
    const graph = new Array(n + 1).fill().map(a => [])
    for (const [u, v, w] of times) {
        graph[u].push([v, w])
    }
    
    const dists = new Array(n + 1).fill(Infinity)
    dists[k] = 0
    
    const heap = new Heap([[k, 0]], (a, b) => a[1] < b[1])
    while (heap.size()) {
        const [node, time] = heap.remove()
        
        for (const [neighborNode, neighborTime] of graph[node]) {
            const totalTime = time + neighborTime
            if (dists[neighborNode] <= totalTime) continue
            dists[neighborNode] = totalTime
            
            heap.insert([neighborNode, time + neighborTime])
        }
    }
    
    let max = 0
    for (let node = 1; node <= n; node++) {
        if (dists[node] === Infinity) return -1
        max = Math.max(max, dists[node])
    }
    
    return max
};

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
            this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
            let temp = this._elements[childIndex]
            this._elements[childIndex] = this._elements[parentIndex]
            this._elements[parentIndex] = temp
            
            childIndex = parentIndex
            parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
            let leftIndex = this._leftChildIndex(parentIndex)
            let rightIndex = this._rightChildIndex(parentIndex)
            let candidate = parentIndex
            
            if (leftIndex < this._elements.length && 
                this._sort(this._elements[leftIndex], this._elements[candidate])) {
                candidate = leftIndex
            }
            
            if (rightIndex < this._elements.length && 
                this._sort(this._elements[rightIndex], this._elements[candidate])) {
                candidate = rightIndex
            }
            
            if (parentIndex === candidate) {
                return
            }
            
            let temp = this._elements[parentIndex]
            this._elements[parentIndex] = this._elements[candidate]
            this._elements[candidate] = temp
            
            parentIndex = candidate
        }
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
            return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    size() {
        return this._elements.length
    }
}
```

## 147. Insertion Sort List
```javascript
function insertionSortList(head) {
    if (!head) return head
    
    const dummy = new ListNode(NaN)
    
    while (head) {
        let prev = dummy
        
        while (prev.next && prev.next.val < head.val)
            prev = prev.next
        
        const next = head.next
        head.next = prev.next
        prev.next = head
        head = next
    }
    
    return dummy.next
}
```

## 148. Sort List
```javascript
const listLength = head => {
    let length = 0
    
    while (head) {
        head = head.next
        length++
    }
        
    return length
}

const mergeK = (head, k) => {
    const dummy = new ListNode(NaN)
    dummy.next = head
    let curr = dummy
    let currHead = head
    
    while (currHead) {
        let l1Head = currHead
        let l1Tail = l1Head

        let i = 1
        while (l1Tail.next && i < k) {
            l1Tail = l1Tail.next
            i++
        }
            
        let l2Head = l1Tail.next
        let l2Tail = l2Head
        
        if (!l2Tail) break
        
        l1Tail.next = null

        i = 1
        while (l2Tail.next && i < k) {
            l2Tail = l2Tail.next
            i++
        }
            
        let next = l2Tail.next
        l2Tail.next = null

        const merged = merge(l1Head, l2Head)
        let mergedTail = merged

        while (mergedTail.next)
            mergedTail = mergedTail.next

        mergedTail.next = next
        
        curr.next = merged
        curr = mergedTail
        currHead = next
    }
    
    return dummy.next
}

const merge = (left, right) => {
    if (!left) return right
    if (!right) return left
    
    let dummy = new ListNode(NaN)
    let curr = dummy
    
    while (left && right) {
        if (left.val < right.val) {
            curr.next = left
            left = left.next
        } else {
            curr.next = right
            right = right.next
        }
        curr = curr.next
    }
    
    curr.next = left ? left : right
    return dummy.next
}

var sortList = function(head) {
    if (!head) return head
    
    const length = listLength(head)
    
    let steps = 1
    while (steps < length) {
        head = mergeK(head, steps)
        steps *= 2
    }
    
    return head
};
```

## 207. Course Schedule
```javascript
// DFS Top Sort
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
const buildGraph = edges => {
    const graph = {}
    
    for (const [vertex, neighbor] of edges) {
        if (!graph[vertex]) {
            graph[vertex] = [neighbor]
        } else {
            graph[vertex].push(neighbor)
        }
    }
    
    return graph
}

var canFinish = function(numCourses, prerequisites) {
    const dfs = (start) => {
        if (visiting.has(start))
            return true
        
        if (visited.has(start))
            return false
        
        visiting.add(start)
        
        let neighbors = graph[start]
        if (neighbors)
            for (const neighbor of neighbors)
                if (dfs(neighbor))
                    return true
        
        visiting.delete(start)
        visited.add(start)
        return false
    }
    
    const graph = buildGraph(prerequisites)
    const visited = new Set()
    const visiting = new Set()
    
    for (const vertex of Object.keys(graph))
        if (dfs(vertex)) return false
    
    return true
};

// Kahn's Algorithm
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
    const graph = buildAdjList(prerequisites)
    const degrees = getDegrees(graph, numCourses)
    
    const list = []
    for (const [vertex, degree] of Object.entries(degrees)) {
        if (degree === 0)
            list.push(vertex)
    }
    
    if (!list.length) 
        return false
    
    for (let i = 0; i < list.length; i++) {
        if (!graph[list[i]]) continue
        for (const neighbor of graph[list[i]]) {
            degrees[neighbor]--
            if (degrees[neighbor] === 0)
                list.push(neighbor)
        }
    }
    
    return list.length === numCourses
};

const buildAdjList = edges => {
    const graph = {}
    
    for (const [vertex, neighbor] of edges) {
        if (graph[vertex]) {
            graph[vertex].push(neighbor)
        } else {
            graph[vertex] = [neighbor]
        }
    }
    
    return graph
}

const getDegrees = (graph, n) => {
    const degrees = Array(n).fill(0)
    
    for (const [vertex, neighbors] of Object.entries(graph)) {
        for (const neighbor of neighbors) {
            degrees[neighbor]++
        }
    }
    
    return degrees
}
```

## 210. Course Schedule II
```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
    const graph = buildGraph(numCourses, prerequisites)
    return topoSort(numCourses, graph)
};

const topoSort = (n, graph) => {
    const _topoSort = vertex => {
        if (colors[vertex] === 2) return false
        if (colors[vertex] === 1) return true
        colors[vertex] = 1
        
        for (const neighbor of graph[vertex]) {
            if (_topoSort(neighbor)) return true
        }
        
        colors[vertex] = 2
        result[i--] = vertex
        return false
    }
    
    const result = Array(n).fill()
    let i = n - 1
    
    const colors = Array(n).fill(0)
    for (let vertex = 0; vertex < n; vertex++) {
        if (_topoSort(vertex)) return []
    }
    
    return result
}

const buildGraph = (n, edges) => {
    const graph = Array(n).fill().map(a => [])
    
    for (const [a, b] of edges) {
        graph[b].push(a)
    }
    
    return graph
}

// Kahn's Algorithm
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
    const [graph, indegrees] = buildGraph(numCourses, prerequisites)
    return kahns(numCourses, graph, indegrees)
};

const kahns = (n, graph, indegrees) => {
    const queue = []
    for (let node = 0; node < n; node++) {
        if (indegrees[node] === 0) {
            queue.push(node)
        }
    }
    
    for (let i = 0; i < queue.length; i++) {
        const node = queue[i]
        for (const neighbor of graph[node]) {
            indegrees[neighbor]--
            
            if (indegrees[neighbor] === 0) {
                queue.push(neighbor)
            }
        }
    }
    
    return queue.length === n ? queue : []
}

const buildGraph = (n, edges) => {
    const graph = new Array(n).fill().map(a => [])
    const indegrees = new Array(n).fill(0)
    
    for (const [a, b] of edges) {
        graph[b].push(a)
        indegrees[a]++
    }
    
    return [graph, indegrees]
}
```

## 582. Kill Process
```javascript
/**
 * @param {number[]} pid
 * @param {number[]} ppid
 * @param {number} kill
 * @return {number[]}
 */
var killProcess = function(pid, ppid, kill) {
    const map = {}
    for (let i = 0; i < pid.length; i++) {
        const parent = ppid[i]
        const child = pid[i]
        
        if (map[parent] === undefined) {
            map[parent] = []
        }
        
        map[parent].push(child)
    }
    
    const result = []
    const queue = [kill]
    while (queue.length) {
        const process = queue.shift()
        
        result.push(process)
        
        if (map[process]) {
            for (const child of map[process]) {
                queue.push(child)
            }
        }
    }
    
    return result
};
```

## 303. Range Sum Query - Immutable
```javascript
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.sums = [0]
    
    for (const num of nums) {
        this.sums.push(num + this.sums[this.sums.length - 1])
    }
};

/** 
 * @param {number} i 
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
    return this.sums[j + 1] - this.sums[i]
};

/** 
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(i,j)
 */
```

## 280. Wiggle Sort
```javascript
const isEven = num => (num & 1) === 0

const swap = (arr, i, j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

var wiggleSort = function(nums) {
    for (let i = 0; i < nums.length - 1; i++) {
        if (isEven(i)) {
            if (!(nums[i] < nums[i+1]))
                swap(nums, i, i+1)
        } else {
            if (!(nums[i] > nums[i+1]))
                swap(nums, i, i+1)
        }
    }
};
```

## 1057. Campus Bikes
```javascript
// Alt approach is GaleShapley greedy algorithm

/**
 * @param {number[][]} workers
 * @param {number[][]} bikes
 * @return {number[]}
 */
var assignBikes = function(workers, bikes) {
  const buckets = buildBuckets(workers, bikes)
  const result = []
  
  for (let i = 0; i < buckets.length; i++) {
      for (let j = 0; j < buckets[i].length; j++) {
          const { bike, worker } = buckets[i][j]
          if (bikes[bike] && workers[worker]) {
              workers[worker] = null
              bikes[bike] = null
              result[worker] = bike
          }
      }    
  }
      
  return result
}

const buildBuckets = (workers, bikes) => {
    let buckets = Array(2001).fill(null).map(() => [])
    for (let i = 0; i < workers.length; i++) {
        for (let j = 0; j < bikes.length; j++) {
            const dist = manhattanDist(workers[i], bikes[j])    
            buckets[dist].push({ worker: i, bike: j })
        }
    }
    
    return buckets
}

const manhattanDist = (p1, p2) => {
    return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1])
}
```

## 1030. Matrix Cells in Distance Order
```javascript
// Counting Sort
/**
 * @param {number} R
 * @param {number} C
 * @param {number} r0
 * @param {number} c0
 * @return {number[][]}
 */
var allCellsDistOrder = function(R, C, r1, c1) {
    const buckets = Array(R + C + 1).fill(null)
    
    for (let r2 = 0; r2 < R; r2++) {
        for (let c2 = 0; c2 < C; c2++) {
            const dist = manhattan(r1, c1, r2, c2)
            if (!buckets[dist]) buckets[dist] = []
            buckets[dist].push([r2, c2])
        }
    }
    
    const result = []
    for (const bucket of buckets) {
        if (!bucket) continue
        for (const point of bucket) {
            result.push(point)
        }
    }
    
    return result
};

const manhattan = (r1, c1, r2, c2) => {
    return Math.abs(r1 - r2) + Math.abs(c1 - c2)
}

/**
 * @param {number} R
 * @param {number} C
 * @param {number} r0
 * @param {number} c0
 * @return {number[][]}
 */
var allCellsDistOrder = function(R, C, r0, c0) {
    const result = []
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const queue = [[r0, c0]]
    const visited = new Set()
    visited.add(`${r0}-${c0}`)
    
    while (queue.length) {
        const [row, col] = queue.shift()
        result.push([row, col])
        
        for (const [dRow, dCol] of dirs) {
            const nRow = row + dRow 
            const nCol = col + dCol
            
            if (nRow < 0 || nRow >= R || nCol < 0 || nCol >= C) continue
            if (visited.has(`${nRow}-${nCol}`)) continue
            visited.add(`${nRow}-${nCol}`)
            queue.push([nRow, nCol])
        }
    }
    
    return result
};
```

## 853. Car Fleet
```javascript
var carFleet = function(target, position, speed) {
    const map = new Map()
    for (let i = 0; i < position.length; i++)
        map.set(position[i], speed[i])
    
    position.sort((a, b) => b - a)
    
    let time = -1
    let fleets = 0
    
    for (let i = 0; i < position.length; i++) {
        const currTime = (target - position[i]) / map.get(position[i])
        if (currTime > time) {
            time = currTime
            fleets++
        }
    }
    
    return fleets
};
```

## 56. Merge Intervals
```javascript
var merge = function(intervals) {
    if (intervals.length <= 1) return intervals
    intervals.sort((a, b) => a[0] - b[0])
    
    let result = [intervals[0]]
    
    for (let i = 1; i < intervals.length; i++) {
        let lastInterval = result[result.length - 1]
        let currInterval = intervals[i]
        
        if (lastInterval[1] >= currInterval[0]) {
            lastInterval[1] = Math.max(lastInterval[1], currInterval[1])
            result[result.length - 1] = lastInterval
            continue
        }
        
        result.push(intervals[i])
    }
    
    return result
};
```

## 524. Longest Word in Dictionary through Deleting
```javascript
// https://techdevguide.withgoogle.com/paths/foundational/find-longest-word-in-dictionary-that-subsequence-of-given-string/#

// O(nm)
var findLongestWord = function(s, d) {
    let result = ""

    for (let word of d) {
        let wordIndex = 0
        for (let strIndex = 0; strIndex < s.length; strIndex++) {
            if (word[wordIndex] === s[strIndex]) 
                wordIndex++
        }
        
        
        if (wordIndex === word.length && result.length <= word.length) {
            if (result.length === word.length && result < word)
                continue
            
            result = word
        }
    }
    
    return result
};

// O(n + l * log m)
const getIndices = str => {
    const indices = {}
    
    for (let i = 0; i < str.length; i++) {
        let char = str[i]
        if (!indices[char]) {
            indices[char] = [i]
        } else {
            indices[char].push(i)
        }
    }
    
    return indices
}

const binarySeach = (target, arr) => {
    let left = 0
    let right = arr.length - 1
    
    while (left < right) {
        let middle = Math.floor((right - left) / 2) + left
        let middleVal = arr[middle]
        
        if (middleVal > target) {
            right = middle
        } else {
            left = middle + 1
        }
    }
    return target < arr[left] ? arr[left] : null
}

var findLongestWord = function(s, d) {
    const indices = getIndices(s)
    
    let result = ""
    
    for (let word of d) {
        
        let length = 0
        let curr = -1
        for (let i = 0; i < word.length; i++) {
            let char = word[i]
            let charIndices = indices[char]
            if (!charIndices) break
            
            let index = binarySeach(curr, charIndices)
            if (index === null) break
            
            curr = index
            length++
        }
        
        if (length === word.length && result.length <= word.length) {
            if (result.length === word.length && result < word)
                continue
            
            result = word
        }
    }
    
    return result
};
```

## 969. Pancake Sorting
```javascript
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var pancakeSort = function(arr) {
    const result = []
    
    for (let endIndex = arr.length - 1; endIndex > 0; endIndex--) {
        let maxIndex = 0
        for (let i = 1; i <= endIndex; i++) {
            if (arr[i] > arr[maxIndex]) {
                maxIndex = i
            }
        }
        
        reverse(arr, 0, maxIndex)
        reverse(arr, 0, endIndex)
        
        result.push(maxIndex + 1)
        result.push(endIndex + 1)
    }
    
    return result
};

const reverse = (arr, i, j) => {
    while (i < j) {
        const temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
        
        i++
        j--
    }
}
```

## 75. Sort Colors
```javascript
// Two Pass
var sortColors = function(nums) {
    let counts = [0, 0, 0]
    
    for (let num of nums)
        counts[num]++
    
    let i = 0
    for (let j = 0; j < counts.length; j++)
        while (counts[j]--)
            nums[i++] = j
};

// One Pass
const swap = (arr, i, j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

var sortColors = function(nums) {
    let low = 0
    let high = nums.length - 1
    
    let i = 0
    while (i <= high) {
        if (nums[i] === 0) {
            swap(nums, i++, low++)
            continue
        }
        
        if (nums[i] == 2) {
            swap(nums, i, high--)
            continue
        }
        
        i++
    }
};
```

## 179. Largest Number
```javascript
var largestNumber = function(nums) {
    if (nums.every(num => num === 0)) 
        return "0"
    
    nums.sort((a, b) => {
        const s1 = `${a}${b}`
        const s2 = `${b}${a}`
        
        if (s1 < s2) return 1
        if (s1 > s2) return -1
        return 0
    })
    
    return nums.join('')
};
```

## 961. N-Repeated Element in Size 2N Array
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var repeatedNTimes = function(A) {
    const unique = new Set()
    
    for (const a of A) {
        if (unique.has(a)) return a
        unique.add(a)
    }
};
```

## 1207. Unique Number of Occurrences
```javascript
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var uniqueOccurrences = function(arr) {
    const map = {}
    for (const num of arr) {
        map[num] = 1 + (map[num] || 0)
    }
    
    const occurrences = Object.values(map)
    const seen = new Set(occurrences)
    return seen.size === occurrences.length
};
```

## 760. Find Anagram Mappings
```javascript
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number[]}
 */
var anagramMappings = function(A, B) {
    const map = {}
    for (let i = 0; i < B.length; i++) {
        map[B[i]] = i
    }
    
    const result = []
    for (const a of A) {
        result.push(map[a])
    }
    
    return result
};
```

## 1152. Analyze User Website Visit Pattern
```javascript
var sequences = (pages) => {
    let set = new Set()
    for (let i = 0; i < pages.length-2; i++) {
        for (let j = i+1; j < pages.length-1; j++) {
            for (let k = j+1; k < pages.length; k++) {
                set.add(pages[i] + '-' +  pages[j] + '-' +  pages[k])
            }
        }
    }
    return set
}

var mostVisitedPattern = function(username, timestamp, website) {
    const tuples = []
    for (let i = 0; i < username.length; i++)
        tuples.push([username[i], timestamp[i], website[i]])
    
    tuples.sort((a, b) => a[1] - b[1])
    
    const userList = {}
    for (let i = 0; i < tuples.length; i++) {
        if (!userList[tuples[i][0]])
            userList[tuples[i][0]] = []
        
        userList[tuples[i][0]].push(tuples[i][2])
    }
    
    let sequence = {}
    let max = 0
    let maxSeq = []
    
    for (let user of Object.keys(userList)) {
        let pages = userList[user]
        
        if (pages.length <= 2) continue
        
        let subsequences = sequences(pages)
        for (let s of subsequences) {
            if (!sequence[s])
                sequence[s] = 0
            
            sequence[s]++
            
            if (sequence[s] > max) {
                max = sequence[s]
                maxSeq = s
            }
            
            if (sequence[s] == max && s < maxSeq) {
                max = sequence[s]
                maxSeq = s
            }
        }
    }
    return maxSeq.split('-')
};
```

## 219. Contains Duplicate II
```javascript
var containsNearbyDuplicate = function(nums, k) {
    const map = {}
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i]
        if (map[num] >= 0 && i - map[num] <= k) {
            return true
        } else {
            map[num] = i
        }
    }
    
    return false
};
```

## 435. Non-overlapping Intervals
```javascript
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    intervals.sort((a, b) => a[1] - b[1])
    
    let min = 0
    let prev = intervals[0]
    for (let i = 1; i < intervals.length; i++) {
        const curr = intervals[i]
        
        if (prev[1] > curr[0]) {
            min++
            continue
        }
        
        prev = curr
    }
    
    return min
};
```

## 208. Implement Trie (Prefix Tree)
```javascript
/**
 * Initialize your data structure here.
 */
var Trie = function() {
    this.root = new TrieNode()
};

/**
 * Inserts a word into the trie. 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
    let curr = this.root
    
    for (const char of word) {
        if (!curr.children[char]) {
            curr.children[char] = new TrieNode(char)
        }
        
        curr = curr.children[char]
    }
    
    curr.isEnd = true
};

/**
 * Returns if the word is in the trie. 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
    let curr = this.root
    
    for (const char of word) {
        if (!curr.children[char]) {
            return false
        }
        
        curr = curr.children[char]
    }
    
    return curr.isEnd
};

/**
 * Returns if there is any word in the trie that starts with the given prefix. 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
    let curr = this.root
    
    for (const char of prefix) {
        if (!curr.children[char]) {
            return false
        }
        
        curr = curr.children[char]
    }
    
    return true
};

/** 
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 677. Map Sum Pairs
```javascript
/**
 * Initialize your data structure here.
 */

class TrieNode {
    constructor(sum = 0) {
        this.sum = sum
        this.children = {}
    }
}

var MapSum = function() {
    this.root = new TrieNode()
    this.keys = {}
};

/** 
 * @param {string} key 
 * @param {number} val
 * @return {void}
 */
MapSum.prototype.insert = function(key, val) {
    let curr = this.root
    let delta = val - (this.keys[key] || 0)
    
    this.keys[key] = val
    curr.sum += delta
    
    for (let char of key) {
        if (!curr.children[char]) {
            curr.children[char] = new TrieNode()
        }
        curr = curr.children[char]
        curr.sum += delta
    }
};

/** 
 * @param {string} prefix
 * @return {number}
 */
MapSum.prototype.sum = function(prefix) {
    let curr = this.root
    
    for (let char of prefix) {
        if (!curr.children[char])
            return 0
            
        curr = curr.children[char]
    }
    
    return curr.sum
};

/** 
 * Your MapSum object will be instantiated and called as such:
 * var obj = new MapSum()
 * obj.insert(key,val)
 * var param_2 = obj.sum(prefix)
 */
```

## 648. Replace Words
```javascript
/**
 * @param {string[]} dictionary
 * @param {string} sentence
 * @return {string}
 */
var replaceWords = function(dictionary, sentence) {
    const trie = new Trie(dictionary)
    
    const result = []
    
    for (const word of sentence.split(' ')) {
        const prefix = trie.shortestPrefix(word)
        if (prefix === '') {
            result.push(word)
        } else {
            result.push(prefix)
        }
    }
    
    return result.join(' ')
};

class Trie {
    constructor(words) {
        this.root = new TrieNode()
        
        for (const word of words) {
            this.insert(word)
        }
    }
    
    insert(word) {
        let curr = this.root
        for (const char of word) {
            if (curr.children[char] === undefined) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
            
            /*
            One optimization when building the trie, 
            if a shorter root is already found, we can stop 
            adding it to the trie. e.g. "a", "aa", "aaa", if 
            "a" is already in the trie, we don't need to go 
            beyond first character of "aa" and "aaa".
            */
            if (curr.isEnd) return
        }
        
        curr.isEnd = true
    }
    
    shortestPrefix(word) {
        const prefix = []
        let curr = this.root
        for (const char of word) {
            if (curr.children[char] === undefined) {
                return ''
            }
            
            curr = curr.children[char]
            prefix.push(curr.key)
            
            if (curr.isEnd) {
                return prefix.join('')
            }
        }
        
        return ''
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 211. Add and Search Word - Data structure design
```javascript
var WordDictionary = function() {
    this.root = new TrieNode()
};

/**
 * Adds a word into the data structure. 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
    let curr = this.root
    for (const char of word) {
        if (!curr.children[char])
            curr.children[char] = new TrieNode(char)
            
        curr = curr.children[char]
    }
    curr.isEnd = true
};

/**
 * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
    const _search = (curr, word, i) => {
        if (word.length === i)
            return curr.isEnd
        
        const char = word[i]
        if (char === '.') {
            for (const key of Object.keys(curr.children)) {
                if (_search(curr.children[key], word, i + 1)) {
                    return true
                }
            }
            return false
        } else {
            return curr.children[char] !== undefined && 
                _search(curr.children[char], word, i + 1)
        }
    }
    
    return _search(this.root, word, 0)
};

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 720. Longest Word in Dictionary
```javascript
/**
 * @param {string[]} words
 * @return {string}
 */
var longestWord = function(words) {
    const trie = new Trie(words)
    return trie.getLongest()
};

class Trie {
    constructor(words) {
        this.root = new TrieNode(NaN)
        
        for (const word of words) {
            this.insert(word)
        }
    }
    
    insert(word) {
        let curr = this.root
        for (const char of word) {
            if (curr.children[char] === undefined) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
        }
        
        curr.word = word
    }
    
    getLongest() {
        const dfs = (node) => {
            for (const [key, child] of Object.entries(node.children)) {
                if (child.word.length) {
                    dfs(child)
                }
            }
            
            if (result.length < node.word.length) {
                result = node.word
            } else if (result.length === node.word.length && result > node.word) {
                result = node.word
            }
        }
        
        let result = ''
        dfs(this.root)
        return result
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.word = ''
    }
}
```

## 79. Word Search
```javascript
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[0].length; col++) {
            if (board[row][col] === word[0] && 
                dfs(board, row, col, word)) {
                return true
            }
        }
    }
    
    return false
};

const dfs = (board, row, col, word) => {
    const _dfs = (row, col, wordIndex) => {
        if (board[row][col] !== word[wordIndex]) {
            return false
        }
        
        if (wordIndex >= word.length - 1) {
            return true
        }
        
        const temp = board[row][col]
        board[row][col] = -1
        
        for (const [dRow, dCol] of dirs) {
            const nextRow = row + dRow
            const nextCol = col + dCol
            
            if (nextRow < 0 || nextRow >= board.length || 
                nextCol < 0 || nextCol >= board[0].length ||
                board[nextRow][nextCol] === -1) continue
            
            if (_dfs(nextRow, nextCol, wordIndex + 1)) {
                return true
            }
        }
        
        board[row][col] = temp
        return false
    }
    
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    return _dfs(row, col, 0)
}
```

## 200. Number of Islands
```javascript
// DFS
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    if (!grid.length || !grid[0].length)
        return 0
    
    let numOfIslands = 0
    
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[row].length; col++) {
            if (grid[row][col] === '1') {
                numOfIslands++
                dfs(grid, row, col)
            }
        }
    }
    return numOfIslands
};

const dfs = (grid, row, col) => {
    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] === '0')
        return
    
    grid[row][col] = '0'
    
    dfs(grid, row + 1, col)
    dfs(grid, row - 1, col)
    dfs(grid, row, col + 1)
    dfs(grid, row, col - 1)  
}

// BFS
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    if (!grid.length || !grid[0].length)
        return 0
    
    let numOfIslands = 0
    const queue = []
    
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[row].length; col++) {
            if (grid[row][col] === '1') {
                numOfIslands++
                
                queue.push([row, col])
                while (queue.length) {
                    const [topRow, topCol] = queue.shift()
                    
                    if (topRow >= 0 && topRow < grid.length && topCol >= 0 && topCol < grid[0].length) {
                        if (grid[topRow][topCol] === '0') continue

                        grid[topRow][topCol] = '0'

                        queue.push([topRow + 1, topCol])
                        queue.push([topRow - 1, topCol])
                        queue.push([topRow, topCol + 1])
                        queue.push([topRow, topCol - 1])
                    }
                }
            }
        }
    }
    return numOfIslands
};

// Union Find
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    const rowLen = grid.length
    const colLen = grid[0].length
    
    const dirs = [[1, 0], [0, 1]]
    
    const unionFind = new UnionFind(rowLen * colLen)
    
    let waterCount = 0
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (grid[row][col] === '1') {
                for (const [deltaRow, deltaCol] of dirs) {
                    const nextRow = deltaRow + row
                    const nextCol = deltaCol + col
                    
                    if (nextRow >= rowLen || 
                        nextCol >= colLen || 
                        grid[nextRow][nextCol] === '0') continue
                    
                    unionFind.union(row * colLen + col, nextRow * colLen + nextCol)
                }
            } else {
                waterCount++
            }
        }
    }
    
    return unionFind.numOfComponents - waterCount
};

class UnionFind {
    constructor(size) {
        this.numOfComponents = size
        
        this.parents = []
        this.sizes = []
        for (let i = 0; i < size; i++) {
            this.parents.push(i)
            this.sizes.push(1)
        }
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (root !== a) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
}
```

## 1110. Delete Nodes And Return Forest
```javascript
var delNodes = function(root, to_delete) {
    const _delNodes = (node) => {
        if (!node) return null
        
        node.left = _delNodes(node.left)
        node.right = _delNodes(node.right)
        
        if (toDelete.has(node.val)) {
            if (node.left) remaining.push(node.left)
            if (node.right) remaining.push(node.right)
            return null
        }
        
        return node
    }
    
    const toDelete = new Set(to_delete)
    const remaining = []
    
    _delNodes(root)
    
    if (!toDelete.has(root.val))
        remaining.push(root)
    
    return remaining
};
```
## 293. Flip Game
```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var generatePossibleNextMoves = function(s) {
    const charArr = s.split('')
    const result = []
    
    for (let i = 1; i < s.length; i++) {
        if (charArr[i - 1] === '+' && charArr[i] === '+') {
            charArr[i - 1] = '-'
            charArr[i] = '-'
            result.push(charArr.join(''))
            charArr[i - 1] = '+'
            charArr[i] = '+'
        }
    }
    
    return result
};
```

## 292. Nim Game
```javascript
// Math
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    return n % 4 !== 0
};

// DP
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    let dp1 = true
    let dp2 = true
    let dp3 = true
    
    for (let i = 4; i <= n; i++) {
        const result = !dp1 || !dp2 || !dp3
        dp1 = dp2
        dp2 = dp3
        dp3 = result
    }
    
    return dp3
};

// Minimax
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    return miniMax(n, true) === 1
};

const miniMax = (stones, maximizingPlayer) => {
    if (stones < 0) return 0
    
    if (stones === 0) {
        return maximizingPlayer ? -1 : 1
    }
    
    if (maximizingPlayer) {
        let maxEval = -Infinity
        for (let i = 1; i <= 3; i++) {
            maxEval = Math.max(maxEval, miniMax(stones - i, false))
        }
        return maxEval
    } else {
        let minEval = Infinity
        for (let i = 1; i <= 3; i++) {
            minEval = Math.min(minEval, miniMax(stones - i, true))
        }
        return minEval
    }
}

// Minimax + DP
/**
 * @param {number} n
 * @return {boolean}
 */
const dp = {}

var canWinNim = function(n) {
    return miniMax(n)
};

const miniMax = (stones) => {
    if (stones <= 0) 
        return false
    
    if (dp[stones] !== undefined) {
        return dp[stones]
    }
    
    for (let i = 1; i <= 3; i++) {
        if (!miniMax(stones - i)) {
            dp[stones] = true
            return true
        }
    }

    dp[stones] = false
    return false
}
```

## 199. Binary Tree Right Side View
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if (!root) return []
    
    const result = []
    
    const queue = [root]
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (i === 0) {
                result.push(node.val)
            }
            
            if (node.right) queue.push(node.right)
            if (node.left) queue.push(node.left)
        }
    }
    
    return result
};
```

## 520. Detect Capital
```javascript
var detectCapitalUse = function(word) {
    let capCount = 0
    
    for (let char of word) {
        if (char === char.toUpperCase())
            capCount++
    }

    return capCount === word.length || 
           capCount === 0 || 
           capCount === 1 && word[0] === word[0].toUpperCase()
};
```

## 204. Count Primes
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
    const sieve = new Array(n).fill(true)
    sieve[0] = false
    sieve[1] = false
    
    let count = 0
    for (let num = 2; num < n; num++) {
        if (sieve[num] === true) {
            count++
            let multiplier = 2
            while (num * multiplier <= n) {
                sieve[num * multiplier] = false
                multiplier++
            }
        }
    }
    
    return count
};
```

## 680. Valid Palindrome II
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
    const _validPalindrome = (left, right) => {
        while (left < right) {
            if (s[left] !== s[right]) {
                return false
            }
            
            left++
            right--
        }
        
        return true
    }
    
    let left = 0
    let right = s.length - 1
    while (left < right) {
        if (s[left] !== s[right]) {
            return _validPalindrome(left + 1, right) || 
                   _validPalindrome(left, right - 1)
        }
        
        left++
        right--
    }
    
    return true
};
```

## 383. Ransom Note
```javascript
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    const map = Array(26).fill(0)
    for (const char of magazine) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        map[index]++
    }
    
    for (const char of ransomNote) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        if (map[index] <= 0) return false
        map[index]--
    }
    
    return true
};
```

## 202. Happy Number
```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let slow = n
    let fast = getNext(n)
    
    while (fast > 1 && slow !== fast) {
        slow = getNext(slow)
        fast = getNext(fast)
        fast = getNext(fast)
    }
    
    return fast === 1
};

const getNext = num => {
    let sum = 0
    
    while (num) {
        const digit = num % 10
        sum += digit ** 2
        num = Math.trunc(num / 10)
    }
    
    return sum
}
```

## 258. Add Digits
```javascript
var addDigits = function(num) {
    let curr = num
    
    while (Math.floor(curr / 10)) {
        let sum = 0
        
        while (curr) {
            let digit = curr % 10
            sum += digit
            curr = Math.floor(curr / 10)
        }
        curr = sum
    }
    
    return curr
};
```

## 49. Group Anagrams
```javascript
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    const map = {}
    for (const str of strs) {
        const count = getCount(str)
        
        const key = count.join(',')
        if (map[key] === undefined) {
            map[key] = []
        }
        
        map[key].push(str)
    }
    
    return Object.values(map)
};

const getCount = str => {
    const counts = new Array(26).fill(0)
    for (const char of str) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        counts[index]++
    }
    return counts
}
```

## 1221. Split a String in Balanced Strings
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var balancedStringSplit = function(s) {
    let balance = 0
    let count = 0
    
    for (let i = 0; i < s.length; i++) {
        s[i] === 'R' ? balance++ : balance--
        if (balance === 0) count++
    }
    
    return count
};
```

## 90. Subsets II
```javascript
var subsetsWithDup = function(nums) {
    const _subsetsWithDup = (curr, start) => {
        if (start > nums.length)
            return
        
        result.push(curr.slice())
        
        for (let i = start; i < nums.length; i++) {
            if (i > start && nums[i] === nums[i - 1]) 
                continue
            
            curr.push(nums[i])
            _subsetsWithDup(curr, i + 1)
            curr.pop()
        }
    }
    
    const result = []
    nums.sort((a, b) => a - b)
    _subsetsWithDup([], 0)
    return result
};
```

## 78. Subsets
```javascript
// Backtracking
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  const _subsets = (curr, index) => {
      if (index === nums.length) {
          result.push(curr.slice())
          return
      }
      
      curr.push(nums[index])
      _subsets(curr, index + 1)
      curr.pop()
      
      _subsets(curr, index + 1)
  }  
  
  const result = []
  _subsets([], 0)
  return result
};

// Iterative Bitmask
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const result = []
    const n = nums.length
    const limit = 1 << n
    
    for (let bitmask = 0; bitmask < limit; bitmask++) {
        const curr = []
        for (let i = 0; i < n; i++) {        
            if (bitmask & 1 << i) {
                curr.push(nums[i])
            }
        }
        result.push(curr)
    }
    
    return result
};
```

## 11. Container With Most Water
```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let maxArea = 0
    let left = 0
    let right = height.length - 1
    
    while (left < right) {
        let currWidth = right - left
        let currHeight = Math.min(height[left], height[right])
        let area = currWidth * currHeight
        maxArea = Math.max(maxArea, area)
        
        if (height[left] >= height[right]) {
            right--
        } else {
            left++
        }
    }
    
    return maxArea
};
```

## 881. Boats to Save People
```javascript
var numRescueBoats = function(people, limit) {
    people.sort((a, b) => a - b)
    
    let boats = 0
    let left = 0
    let right = people.length - 1
    
    while (left <= right) {
        let weight = people[left] + people[right]
        
        if (weight > limit) {
            right--
        } else {
            left++
            right--
        }
        boats++
    }
    
    return boats
};
```

## 875. Koko Eating Bananas
```javascript
var minEatingSpeed = function(piles, H) {
    let low = 0
    let high = 1000000000
    
    while (low < high) {
        let mid = Math.floor((high - low) / 2) + low
        if (!possible(piles, H, mid)) {
            low = mid + 1
        } else {
            high = mid
        }
    }
    
    return low
};

const possible = (piles, H, K) => {
    let time = 0
    for (const pile of piles)
        time += Math.ceil(pile / K)
    
    return time <= H
}
```

## 113. Path Sum II
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function(root, targetSum) {
    const _pathSum = (node, sum) => {
        if (!node) return
        
        sum += node.val
        
        path.push(node.val)
        
        if (!node.left && !node.right && sum === targetSum) {
            result.push(path.slice())
        } else {
            _pathSum(node.left, sum)
            _pathSum(node.right, sum)
        }
        
        path.pop()
    }
    
    const result = []
    const path = []
    _pathSum(root, 0)
    return result
};
```

## 482. License Key Formatting
```javascript
var licenseKeyFormatting = function(S, K) {
    const arr = S.split('').filter(char => char !== '-')
    const remaining = arr.length % K
    const result = []    
    let charArr = []
    
    if (remaining) {    
        for (let i = 0; i < remaining; i++)
            charArr.push(arr[i].toUpperCase())
        
        result.push(charArr.join(''))
        charArr = []
    }
    
    for (let i = remaining; i < arr.length; i++) {
        charArr.push(arr[i].toUpperCase())
        
        if (charArr.length === K) {
            result.push(charArr.join(''))
            charArr = []
        }
    }

    return result.join('-')  
};

/**
 * @param {string} S
 * @param {number} K
 * @return {string}
 */
var licenseKeyFormatting = function(S, K) {
    const result = []
    
    let size = 0
    for (let i = S.length - 1; i >= 0; i--) {
        if (S[i] === '-') continue
        
        if (size === K) {
            result.push('-')
            size = 0
        }
        
        result.push(S[i].toUpperCase())
        size++
    }
    
    result.reverse()
    return result.join('')
};
```

## 415. Add Strings
```javascript
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
    if (!num1) return num2
    if (!num2) return num1
    
    const result = []
    
    let carry = 0
    let i = num1.length - 1
    let j = num2.length - 1
    while (i >= 0 || j >= 0) {
        const num1Val = i >= 0 ? +num1[i] : 0
        const num2Val = j >= 0 ? +num2[j] : 0
        
        const sum = num1Val + num2Val + carry
        
        carry = Math.floor(sum / 10)
        result.push(sum % 10)
        
        i--
        j--
    }
    
    if (carry !== 0) {
        result.push(carry)
    }
    
    return result.reverse().join('')
};
```

## 508. Most Frequent Subtree Sum
```javascript
var findFrequentTreeSum = function(root) {
    const dfs = (node) => {
        if (!node) return 0
        
        const sum = node.val + dfs(node.left) + dfs(node.right)
        
        sumFreq[sum] ? sumFreq[sum]++ : sumFreq[sum] = 1
        maxFreq = Math.max(sumFreq[sum], maxFreq)
        return sum
    }
    
    const sumFreq = {}
    let maxFreq = 0
    dfs(root)
    
    return Object.entries(sumFreq).reduce((result, [key, val]) => {
        if (val === maxFreq)
            result.push(key)
        return result
    }, [])
};
```

## 366. Find Leaves of Binary Tree
```javascript
var findLeaves = function(root) {
    const dfs = (node) => {
        if (!node) return -1
        
        const leftDepth = dfs(node.left)
        const rightDepth = dfs(node.right)
        const depth = Math.max(leftDepth, rightDepth) + 1
        depths[depth] ? depths[depth].push(node.val) : depths[depth] = [node.val]
        return depth
    }
    
    const depths = []
    dfs(root)
    return depths
};
```

## 695. Max Area of Island
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxAreaOfIsland = function(grid) {
    const rowLen = grid.length
    const colLen = grid[0].length
    
    let maxArea = 0
    
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (grid[row][col] !== 1) continue
            maxArea = Math.max(maxArea, getArea(row, col, grid))
        }
    }
    
    return maxArea
};

const getArea = (row, col, grid) => {
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    const rowLen = grid.length
    const colLen = grid[0].length
    
    let area = 0
    
    const queue = [[row, col]]
    grid[row][col] = 0
    
    while (queue.length) {
        const [currRow, currCol] = queue.shift()
        
        area++
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = currRow + deltaRow
            const nextCol = currCol + deltaCol
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen || 
                grid[nextRow][nextCol] !== 1) continue
            
            grid[nextRow][nextCol] = 0
            
            queue.push([nextRow, nextCol])
        }
    }
    
    return area
}
```

## 463. Island Perimeter
```javascript
// DFS
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function(grid) {
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 1) {
                return perimeter(grid, row, col)   
            }
        }
    }
    return 0
};

const perimeter = (grid, row, col) => {
    if (row < 0 || row >= grid.length || 
        col < 0 || col >= grid[0].length || grid[row][col] === 0) return 1

    if (grid[row][col] === 'X')
        return 0

    grid[row][col] = 'X'

    let count = 0
    count += perimeter(grid, row - 1, col)
    count += perimeter(grid, row + 1, col)
    count += perimeter(grid, row, col - 1)
    count += perimeter(grid, row, col + 1)
    return count
}

// BFS
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function(grid) {
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col])
                return perimeter(grid, row, col)
        }
    }
};

const perimeter = (grid, row, col) => {
    let result = 0
    const queue = [[row, col]]
    grid[row][col] = 'X'

    while (queue.length) {
        const [currRow, currCol] = queue.shift()
        for (const [dRow, dCol] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const newRow = currRow + dRow
            const newCol = currCol + dCol

            if (newRow < 0 || newRow >= grid.length || 
                newCol < 0 || newCol >= grid[0].length || 
                grid[newRow][newCol] === 0) {
                result++
                continue
            }
            
            if (grid[newRow][newCol] === 'X') continue
            grid[newRow][newCol] = 'X'
            queue.push([newRow, newCol])
        }
    }
    
    return result
}
```

## 994. Rotting Oranges
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var orangesRotting = function(grid) {
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const queue = []
    let orangeCount = 0
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 2) {
                queue.push([row, col])
            } else if (grid[row][col] === 1) {
                orangeCount++
            }
        }
    }
    
    let level = 0
    if (orangeCount === 0) return level
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()
            
            for (const [dRow, dCol] of dirs) {
                const nextRow = row + dRow
                const nextCol = col + dCol

                if (nextRow < 0 || nextRow >= grid.length || 
                    nextCol < 0 || nextCol >= grid[0].length || 
                    grid[nextRow][nextCol] !== 1) continue
                
                orangeCount--        
                grid[nextRow][nextCol] = 2
                queue.push([nextRow, nextCol])
            }
        }
        level++
        if (orangeCount === 0) return level
    }
    
    return -1
};
```

## 323. Number of Connected Components in an Undirected Graph
```javascript
// Union Find
var countComponents = function(n, edges) {
    const set = new DisjointSet(n)
    for (const [start, end] of edges) {
        set.union(start, end)
    }
    return set.numOfComponents
};

class DisjointSet {
    constructor(n) {
        this.numOfComponents = n
        this.componentSize = Array(n).fill(0)
        this.parent = []
        
        for (let i = 0; i < n; i++) {
            this.parent[i] = i
        }
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root])
            root = this.parent[root]
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}

// BFS
var countComponents = function(n, edges) {
    const adjList = {}
    
    for (let [start, end] of edges) {
        adjList[start] ? adjList[start].push(end) : adjList[start] = [end] 
        adjList[end] ? adjList[end].push(start) : adjList[end] = [start] 
    }
    
    const visited = new Set()
    let count = 0
    
    while (--n >= 0) {
        if (!visited.has(n)) {
            bfs(n, adjList, visited)
            count++
        }
    }
    
    return count
};

const bfs = (source, list, visited) => {
    const queue = [source]
    
    while (queue.length) {
        const next = queue.shift()
        
        if (!list[next]) continue

        for (const neighbor of list[next]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor)
                queue.push(neighbor)
            }
        }
    }
}
```

## 904. Fruit Into Baskets
```javascript
/**
 * @param {number[]} tree
 * @return {number}
 */
var totalFruit = function(tree) {
    const counter = new Map()
    let max = 0
    let j = 0
    
    for (let i = 0; i < tree.length; i++) {
        counter.set(tree[i], i)
        
        if (counter.size > 2) {
            const min = Math.min(...counter.values())
            j = min + 1
            counter.delete(tree[min])
        }
        
        max = Math.max(max, i - j)
    }
    
    return max + 1
};
```

## 681. Next Closest Time
```javascript
var nextClosestTime = function(time) {
    const [hour, min] = time.split(':')
    let totalMin = (+hour * 60) + +min
    
    const nums = new Set()
    for (let char of time)
        nums.add(+char)
    
    outer: while (true) {
        totalMin = (totalMin + 1) % (24 * 60)
        
        const time = format(totalMin)
        for (const char of time)
            if (!nums.has(+char)) 
                continue outer
        
        return time
    }
};

const format = time => {
    let hour = Math.floor(time / 60)
    let min = time % 60
    return `${Math.floor(hour / 10)}${hour % 10}:${Math.floor(min / 10)}${min % 10}`
}
```

## 1209. Remove All Adjacent Duplicates in String II
```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var removeDuplicates = function(s, k) {
    const stack = []
    for (let i = 0; i < s.length; i++) {
        if (!stack.length) {
            stack.push([s[i], 1])
            continue
        }
        
        const top = stack[stack.length - 1]
        if (top[0] === s[i]) {
            top[1]++
            
            if (top[1] === k) {
                stack.pop()
            }
            
            continue
        }
        
        stack.push([s[i], 1])
    }
    
    const result = []
    for (const [char, count] of stack) {
        result.push(char.repeat(count))
    }
    return result.join('')
};
```

## 133. Clone Graph
```javascript
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
    if (!node) return null
    
    const graph = {}
    graph[node.val] = new Node(node.val, [])
    
    const queue = [node]
    while (queue.length) {
        const source = queue.shift()
        
        for (const neighbor of source.neighbors) {
            if (!graph[neighbor.val]) {
                graph[neighbor.val] = new Node(neighbor.val, [])
                queue.push(neighbor)
            }
            
            graph[source.val].neighbors.push(graph[neighbor.val])
        }
    }
    
    return graph[node.val]
};
```

## 645. Set Mismatch
```javascript
var findErrorNums = function(nums) {
    const n = nums.length
    const sum = (n * (n + 1)) / 2
    
    const seen = new Set()
    let repeat = 0
    let currSum = 0
    
    for (const num of nums) {
        currSum += num
        
        if (seen.has(num)) {
            repeat = num
        } else {
            seen.add(num)
        }
    }
    
    return [repeat, sum - (currSum - repeat)]
};

// O(1) Space
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findErrorNums = function(nums) {
    let dup = 0
    for (const num of nums) {
        if (nums[Math.abs(num) - 1] < 0) {
            dup = Math.abs(num)
        } else {
            nums[Math.abs(num) - 1] *= -1
        }
    }
    
    let missingNum = 0
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            missingNum = i + 1
        }
    }
    
    return [dup, missingNum]
};
```

## 500. Keyboard Row
```javascript
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
    const keyboard = [1,2,2,1,0,1,1,1,0,1,1,1,2,2,0,0,0,0,1,0,0,2,0,2,0,2]
    
    return words.filter(word => {
        let prevRow = null
        
        for (const char of word) {
            const index = char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)
            const currRow = keyboard[index]
            
            if (prevRow !== null && prevRow !== currRow) {
                return false
            }
            
            prevRow = currRow
        }
        
        return true
    })
};
```

## 1189. Maximum Number of Balloons
```javascript
var maxNumberOfBalloons = function(text) {
    const counts = {}
    for (const t of text)
        counts[t] ? counts[t]++ : counts[t] = 1
    
    let min = Number.MAX_VALUE
    
    for (const char of "balloon") {
        if (!counts[char]) 
            return 0
        
        if (char === 'l' || char === 'o') {
            min = Math.min(min, Math.floor(counts[char] / 2))
            continue
        }
        
        min = Math.min(min, counts[char])
    }
    return min
};
```

## 277. Find the Celebrity
```javascript
/**
 * Definition for knows()
 * 
 * @param {integer} person a
 * @param {integer} person b
 * @return {boolean} whether a knows b
 * knows = function(a, b) {
 *     ...
 * };
 */

/**
 * @param {function} knows()
 * @return {function}
 */
var solution = function(knows) {
    /**
     * @param {integer} n Total people
     * @return {integer} The celebrity
     */
    return function(n) {
        let celebrity = 0
        
        for (let i = 1; i < n; i++)
            if (knows(celebrity, i))
                celebrity = i
        
        for (let i = 0; i < n; i++) {
            if (i !== celebrity && knows(celebrity, i) || !knows(i, celebrity)) {
                return -1
            }
        }
        
        return celebrity
    };
};
```

## 739. Daily Temperatures
```javascript
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function(T) {
    const result = new Array(T.length).fill(0)
    const stack = []
    for (let i = 0; i < T.length; i++) {
        while (stack.length && T[stack[stack.length - 1]] < T[i]) {
            const index = stack.pop()
            result[index] = i - index
        }
        
        stack.push(i)
    }
    
    return result
};
```

## 286. Walls and Gates
```javascript
/**
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */
var wallsAndGates = function(rooms) {
    if (!rooms.length) return
    
    const rowLen = rooms.length
    const colLen = rooms[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const INF = 2147483647
    
    const queue = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (rooms[row][col] === 0) {
                queue.push([row, col, 0])
            }
        }
    }
    
    while (queue.length) {
        const [row, col] = queue.shift()
        for (const [dRow, dCol] of dirs) {
            const nextRow = dRow + row
            const nextCol = dCol + col
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen ||
               rooms[nextRow][nextCol] !== INF) continue
            
            rooms[nextRow][nextCol] = rooms[row][col] + 1
            queue.push([nextRow, nextCol])
        }
    }
};
```

## 3. Longest Substring Without Repeating Characters
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    const seen = new Set()
    let max = 0
    let start = 0
    for (let end = 0; end < s.length; end++) {
        while (seen.has(s[end])) {
            seen.delete(s[start])
            start++
        }
        
        seen.add(s[end])
        max = Math.max(max, end - start + 1)
    }
    
    return max
};
```

## 43. Multiply Strings
```javascript
var multiply = function(num1, num2) {
    if (!(+num1)) return "0"
    if (!(+num2)) return "0"
    
    let i = num1.length - 1
    let products = []
    let zerosPlace = 0
    
    while (i >= 0) {
        let result = []
        let carry = 0
        
        let curr = 0
        while (curr < zerosPlace) {
            result.push(0)
            curr++
        }

        for (let j = num2.length - 1; j >= 0; j--) {
            let product = (+num1[i] * +num2[j]) + carry
            carry = Math.floor(product / 10)
            result.push(product % 10)
        }

        if (carry) {
            result.push(carry)
        }

        zerosPlace++
        products.push(result.reverse().join(''))
        i--
    }
    
    while (products.length > 1) {
        products[0] = addStrings(products[0], products[products.length - 1])
        products.pop()
    }
    
    return products[0]
};

var addStrings = function(num1, num2) {
    if (!(+num1)) return num2
    if (!(+num2)) return num1
    
    let i = num1.length - 1
    let j = num2.length - 1
    let carry = 0
    
    let result = []
    
    while (i >= 0 || j >= 0 || carry) {
        let num1Val = i >= 0 ? +num1[i] : 0
        let num2Val = j >= 0 ? +num2[j] : 0
        
        let sum = num1Val + num2Val + carry
        carry = Math.floor(sum / 10)
        result.push(sum % 10)
        i--
        j--
    }
    
    return result.reverse().join('')
};
```

## 1252. Cells with Odd Values in a Matrix
```javascript
// Simulation
var oddCells = function(n, m, indices) {
    const matrix = Array(n).fill(false).map(e => Array(m).fill(false))
    
    for (let [row, col] of indices) {
        fillRow(matrix, row, m)
        fillCol(matrix, col, n)
    }
    
    let count = 0
    for (let row = 0; row < n; row++)
        for (let col = 0; col < m; col++)
            if (matrix[row][col])
                count++
    return count
};

const fillRow = (matrix, row, m) => {
    for (let col = 0; col < m; col++) {
        matrix[row][col] ^= true
    }
}

const fillCol = (matrix, col, n) => {
    for (let row = 0; row < n; row++) {
        matrix[row][col] ^= true
    }
}

// Accumulate
/**
 * @param {number} n
 * @param {number} m
 * @param {number[][]} indices
 * @return {number}
 */
var oddCells = function(n, m, indices) {
    const rows = Array(n).fill(0)
    const cols = Array(m).fill(0)
    
    for (const [row, col] of indices) {
        rows[row]++
        cols[col]++
    }
    
    let odd = 0
    
    for (const row of rows) {
        for (const col of cols) {
            odd += isOdd(row + col)
        }
    }
    
    return odd
};

const isOdd = num => num & 1
```

## 73. Set Matrix Zeroes
```javascript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
    let zeroInFirstRow = false
    let zeroInFirstCol = false
    for (let row = 0; row < matrix.length; row++) {
        for (let col = 0; col < matrix[0].length; col++) {
            if (matrix[row][col] !== 0) continue
            
            if (row === 0) zeroInFirstRow = true
            if (col === 0) zeroInFirstCol = true
            
            matrix[row][0] = 0
            matrix[0][col] = 0
        }
    }
    
    // Set all zeros except for first row
    for (let row = 1; row < matrix.length; row++) {
        if (matrix[row][0] !== 0) continue
        for (let col = 1; col < matrix[0].length; col++) {
            matrix[row][col] = 0
        }
    }
    
    // Set all zeros except for first col
    for (let col = 1; col < matrix[0].length; col++) {
        if (matrix[0][col] !== 0) continue
        for (let row = 1; row < matrix.length; row++) {
            matrix[row][col] = 0
        }
    }
    
    // Set all zeros in first row
    if (zeroInFirstRow) {
        for (let col = 0; col < matrix[0].length; col++) {
            matrix[0][col] = 0
        }
    }
    
    // Set all zeros in first col
    if (zeroInFirstCol) {
        for (let row = 0; row < matrix.length; row++) {
            matrix[row][0] = 0
        }
    }
};
```

## 541. Reverse String II
```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
    const charArr = s.split('')
    
    for (let i = 0; i < charArr.length; i += (2 * k)) {
        reverse(charArr, i, Math.min((i + k - 1), charArr.length - 1))
    }
    return charArr.join('')
};

const reverse = (s, left, right) => {
    while (left < right) {
        let temp = s[left]
        s[left] = s[right]
        s[right] = temp
        
        left++
        right--
    }
}
```

## 58. Length of Last Word
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    let len = 0
    for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] === ' ' && len === 0) continue
        if (s[i] === ' ' && len > 0) break
        len++
    }
    
    return len
};
```

## 917. Reverse Only Letters
```javascript
/**
 * @param {string} S
 * @return {string}
 */
var reverseOnlyLetters = function(S) {
    const charArr = S.split('')
    let left = 0
    let right = charArr.length - 1
    
    while (left < right) {
        if (!isChar(charArr[left])) {
            left++
            continue
        }
        
        if (!isChar(charArr[right])) {
            right--
            continue
        }
        
        const temp = charArr[left]
        charArr[left] = charArr[right]
        charArr[right] = temp
        
        left++
        right--
    }
    
    return charArr.join('')
};

const isChar = char => {
    return char.toLowerCase() >= 'a' && char.toLowerCase() <= 'z'
}
```

## 159. Longest Substring with At Most Two Distinct Characters
```javascript
var lengthOfLongestSubstringTwoDistinct = function(s) {
    let max = 0
    let currMax = 0
    
    let lastChar = null
    let lastCharCount = 0
    let secondLastChar = null
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] === lastChar) {
            lastCharCount++
            currMax++
        } else if (s[i] === secondLastChar) {
            lastCharCount = 1
            currMax++
            
            secondLastChar = lastChar
            lastChar = s[i]
        } else {
            currMax = lastCharCount + 1
            lastCharCount = 1
            
            secondLastChar = lastChar
            lastChar = s[i]
        }
        max = Math.max(currMax, max)
    }
    
    return max
};
```

## 340. Longest Substring with At Most K Distinct Characters
```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var lengthOfLongestSubstringKDistinct = function(s, k) {
    const distinct = new Map()
    let max = 0
    let left = 0
    for (let right = 0; right < s.length; right++) {
        distinct.set(s[right], 1 + (distinct.get(s[right]) || 0))
        
        while (distinct.size > k) {
            distinct.set(s[left], distinct.get(s[left]) - 1)
            
            if (distinct.get(s[left]) <= 0) {
                distinct.delete(s[left])
            }
            
            left++
        }
        
        max = Math.max(max, right - left + 1)
    }
    
    return max
};
```

## 1213. Intersection of Three Sorted Arrays
```javascript
var arraysIntersection = function(arr1, arr2, arr3) {
    const counts = {}
    for (let a of arr1)
        counts[a] ? counts[a]++ : counts[a] = 1
    
    for (let a of arr2)
        counts[a] ? counts[a]++ : counts[a] = 1
    
    for (let a of arr3)
        counts[a] ? counts[a]++ : counts[a] = 1
    
    return Object.entries(counts).reduce((result, entry) => {
        if (entry[1] === 3) 
            result.push(entry[0])
        return result
    }, [])
};

// Bucket Sort
var arraysIntersection = function(arr1, arr2, arr3) {
    const buckets = Array(2001).fill(0)
    
    for (const num of arr1) {
        buckets[num]++
    }
    
    for (const num of arr2) {
        buckets[num]++
    }
    
    for (const num of arr3) {
        buckets[num]++
    }
    
    const result = []
    for (let num = 0; num < buckets.length; num++) {
        if (buckets[num] === 3) {
            result.push(num)
        }
    }
    
    return result
};

// Constant Space
/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @param {number[]} arr3
 * @return {number[]}
 */
var arraysIntersection = function(arr1, arr2, arr3) {
    let p1 = 0
    let p2 = 0
    let p3 = 0
    
    const result = []
    
    while (p1 < arr1.length && p2 < arr2.length && p3 < arr3.length) {
        if (arr1[p1] === arr2[p2] && arr1[p1] === arr3[p3]) {
            result.push(arr1[p1])
            p1++
            p2++
            p3++
            continue
        }
        
        const max = Math.max(arr1[p1], arr2[p2], arr3[p3])
        if (arr1[p1] !== max) p1++
        if (arr2[p2] !== max) p2++
        if (arr3[p3] !== max) p3++
    }
    
    return result
};
```

## 599. Minimum Index Sum of Two Lists
```javascript
var findRestaurant = function(list1, list2) {
    const order1 = {}
    for (let i = 0; i < list1.length; i++) {
        order1[list1[i]] = i 
    }
    
    let minDist = Number.MAX_VALUE
    let min = []
    
    for (let i = 0; i < list2.length; i++) {
        if (order1[list2[i]] === undefined) continue
        
        let dist = order1[list2[i]] + i

        if (dist === minDist) {
            min.push(list2[i])
        } else if (!min.length || dist < minDist) {
            min = [list2[i]]
            minDist = dist
        }
    }
    return min
};
```

## 266. Palindrome Permutation
```javascript
var canPermutePalindrome = function(s) {
    const counts = {}
    let oddCount = 0
    
    for (let l of s) {
        counts[l] ? counts[l]++ : counts[l] = 1
        
        if (counts[l] & 1) {
            oddCount++
        } else {
            oddCount--
        }
    }

    return oddCount <= 1
};

/**
 * @param {string} s
 * @return {boolean}
 */
var canPermutePalindrome = function(s) {
    const charCounts = {}
    
    let odds = 0
    for (const char of s) {
        charCounts[char] = 1 + (charCounts[char] || 0)
        isEven(charCounts[char]) ? odds-- : odds++         
    }
    
    return odds <= 1
};

const isEven = num => num % 2 === 0
```

## 285. Inorder Successor in BST
```javascript
var inorderSuccessor = function(root, p) {
    if (p.right) {
        p = p.right
        while (p.left) p = p.left
        return p
    }
    
    let left = null
    while (root && p.val !== root.val) {
        if (p.val < root.val) {
            left = root
            root = root.left
        } else {
            root = root.right
        }
    }
    return left
};
```

## 510. Inorder Successor in BST II
```javascript
/**
 * // Definition for a Node.
 * function Node(val) {
 *    this.val = val;
 *    this.left = null;
 *    this.right = null;
 *    this.parent = null;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var inorderSuccessor = function(node) {
    if (node.right) {
        node = node.right
        while (node.left) {
            node = node.left
        }
        return node
    }
    
    while (node) {
        let child = node
        node = node.parent
        
        if (node && node.left === child) {
            break
        }
    }
    
    return node
};
```

## 40. Combination Sum II
```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    const _combinationSum2 = (curr, i, sum) => {
        if (i > candidates.length || sum > target) return
        
        if (sum === target) {
            result.push(curr.slice())
            return
        }
        
        for (let j = i; j < candidates.length; j++) {
            if (target < sum + candidates[j]) break
            if (j !== i && candidates[j] === candidates[j - 1]) continue
            
            curr.push(candidates[j])
            _combinationSum2(curr, j + 1, sum + candidates[j])
            curr.pop()
        }
    }
    
    const result = []
    candidates.sort((a, b) => a - b)
    _combinationSum2([], 0, 0)
    return result
};
```

## 39. Combination Sum
```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    const _combinationSum = (index, sum) => {
        if (target === sum) {
            result.push(path.slice())
            return
        }
        
        if (sum > target || index >= candidates.length) return
        
        path.push(candidates[index])
        _combinationSum(index, sum + candidates[index])
        path.pop()
        
        _combinationSum(index + 1, sum)
    }
    
    const result = []
    const path = []
    _combinationSum(0, 0)
    return result
};
```

## 130. Surrounded Regions
```javascript
// BFS
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
    if (!board.length) return []
    
    const rowLen = board.length
    const colLen = board[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const queue = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (board[row][col] === 'O' && 
                (row === 0 || row === rowLen - 1 || 
                 col === 0 || col === colLen - 1)) {
                queue.push([row, col])
            }
        }
    }
    
    while (queue.length) {
        const [row, col] = queue.shift()
        board[row][col] = 'Z'
        
        for (const [dRow, dCol] of dirs) {
            const nextRow = row + dRow
            const nextCol = col + dCol
            
            if (nextRow < 0 || nextCol < 0 || 
                nextRow >= rowLen || nextCol >= colLen ||
                board[nextRow][nextCol] !== 'O') continue
            
            queue.push([nextRow, nextCol])
        }
    }
    
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (board[row][col] === 'Z') {
                board[row][col] = 'O'
            } else {
                board[row][col] = 'X'
            }
        }
    }
    
    return board
};

// DFS
var solve = function(board) {
    if (!board.length) return
    
    const height = board.length
    const width = board[0].length
    const visited = Array(height).fill(null).map(_ => Array(width).fill(false))
    
    for (let col = 0; col < width; col++)
        if (board[0][col] === 'O')
           dfs(board, 0, col, visited)
    
    for (let col = 0; col < width; col++)
        if (board[height - 1][col] === 'O')
            dfs(board, height - 1, col, visited)
            
    for (let row = 1; row < height - 1; row++)
        if (board[row][0] === 'O')
            dfs(board, row, 0, visited)
    
    for (let row = 1; row < height - 1; row++)
        if (board[row][width - 1] === 'O')
            dfs(board, row, width - 1, visited)
    
    for (let row = 0; row < height; row++)
        for (let col = 0; col < width; col++)
            if (!visited[row][col] && board[row][col] === 'O')
                board[row][col] = 'X'
};

const dfs = (board, row, col, visited) => {
    if (row < 0 || row >= board.length || col < 0 || 
        col >= board[0].length || board[row][col] === 'X' || 
        visited[row][col]) return
    
    if (board[row][col] === 'O')
        visited[row][col] = true
    
    dfs(board, row - 1, col, visited)
    dfs(board, row + 1, col, visited)
    dfs(board, row, col - 1, visited)
    dfs(board, row, col + 1, visited)
}

// Union Find
var solve = function(board) {
    if (!board.length) return
    
    const n = board.length
    const m = board[0].length
    const set = new DisjointSet(n * m + 1)
    
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < m; col++) {
            if (board[row][col] !== 'O')
                continue
            
            if (row === 0 || row === n - 1 || col === 0 || col === m - 1) {
                set.union(row * m + col, n * m)
                continue
            }
            
            if (board[row - 1][col] === 'O')
                set.union(row * m + col, (row - 1) * m + col)
            if (board[row + 1][col] === 'O')
                set.union(row * m + col, (row + 1) * m + col)
            if (board[row][col - 1] === 'O')
                set.union(row * m + col, row * m + (col - 1))
            if (board[row][col + 1] === 'O')
                set.union(row * m + col, row * m + (col + 1))
        }
    }

    for (let row = 0; row < n; row++) {
        for (let col = 0; col < m; col++) {
            if (set.find(row * m + col) !== set.find(n * m))
                board[row][col]='X'
        }
    }
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root])
            root = this.parent[root]
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 763. Partition Labels
```javascript
/**
 * @param {string} S
 * @return {number[]}
 */
var partitionLabels = function(S) {
    const lastIndex = {}
    for (let i = 0; i < S.length; i++) {
        lastIndex[S[i]] = i
    }
    
    const result = []
    let start = 0
    let end = 0
    for (let i = 0; i < S.length; i++) {
        end = Math.max(end, lastIndex[S[i]])
        
        if (end === i) {
            result.push(end - start + 1)
            start = i + 1
        }
    }
    
    return result
};
```

## 819. Most Common Word
```javascript
var mostCommonWord = function(paragraph, banned) {
    const bannedSet = new Set(banned)
    let maxCount = 0
    let maxWord = ""
    
    const words = paragraph
    .split('')
    .map(char => {
        const lowercase = char.toLowerCase()
        if ('a' <= lowercase && lowercase <= 'z') 
            return lowercase
        return ' '
    })
    .join('')
    .split(' ')
    .filter(word => !bannedSet.has(word))
    .reduce((result, word) => {
        if (word == '') return result
        
        result[word] ? result[word]++ : result[word] = 1
        
        if (result[word] > maxCount) {
            maxCount = result[word]
            maxWord = word
        }
        
        return result
    }, {})
    
    return maxWord
};

/**
 * @param {string} paragraph
 * @param {string[]} banned
 * @return {string}
 */
var mostCommonWord = function(paragraph, banned) {
    const bannedWords = new Set(banned)
    const counts = {}
    
    let word = []
    for (let i = 0; i <= paragraph.length; i++) {
        const char = i >= paragraph.length ? "" : paragraph[i].toLowerCase()
        
        if (char < 'a' || char > 'z') {
            const str = word.join('')
            
            if (!bannedWords.has(str) && word.length) {
                counts[str] = 1 + (counts[str] || 0)
            }
            
            word = []
            continue
        }
        
        word.push(char)        
    }
    
    let maxWord = ''
    let maxCount = 0
    for (const [key, val] of Object.entries(counts)) {
        if (maxCount < val) {
            maxWord = key
            maxCount = val
        }
    }
    
    return maxWord
};
```

## 1265. Print Immutable Linked List in Reverse
```javascript
// Recursive
// O(n)
// O(n)
var printLinkedListInReverse = function(head) {
    if (!head) return
    printLinkedListInReverse(head.getNext())
    head.printValue()
};

// Iterative
// O(n)
// O(n)
var printLinkedListInReverse = function(head) {
    const stack = []
    
    while (head) {
        stack.push(head)
        head = head.getNext()
    }
    
    while (stack.length) {
        stack.pop().printValue()
    }
};

// O(n^2)
// O(1)
var printLinkedListInReverse = function(head) {
    let length = listLength(head)
    
    while (length--) {
        let runner = head
        for (let i = 0; i < length; i++) {
            runner = runner.getNext()
        }
        runner.printValue()
    }
};

const listLength = head => {
    let count = 0
    
    while (head) {
        head = head.getNext()
        count++
    }
    
    return count
}

// O(n)
// O(sqrt(n))
var printLinkedListInReverse = function(head) {
    const length = listLength(head)
    const k = Math.floor(Math.sqrt(length))
    const startNodes = []
    
    let runner = head
    let i = 0
    while (runner) {
        if (i % k === 0)
            startNodes.push(runner)
            
        runner = runner.getNext()
        i++
    }
    
    printList(head, startNodes, k)
};

const printList = (head, startNodes, k) => {
    let start = null
    let end = null
    let temp = null
    
    while (startNodes.length) {
        end = start
        start = startNodes.pop()
        temp = start
        const stack = []
        
        while (temp != end) {
            stack.push(temp)
            temp = temp.getNext()
        }

        while (stack.length) {
            stack.pop().printValue()
        }   
    }
}

const listLength = head => {
    let count = 0
    
    while (head) {
        head = head.getNext()
        count++
    }
    
    return count
}
```

## 254. Factor Combinations
```javascript
/**
 * @param {number} n
 * @return {number[][]}
 */
var getFactors = function(n) {
    const _getFactors = (n, start, curr) => {
        if (n === 1) {
            if (curr.length > 1) {
                result.push(curr.slice())
            }
            return
        }
        
        for (let i = start; i <= Math.sqrt(n); i++) {
            if (n % i !== 0) continue
            curr.push(i)
            _getFactors(n / i, i, curr)
            curr.pop()
        }
        
        curr.push(n)
        _getFactors(1, n, curr)
        curr.pop()
    }
    
    if (n <= 3) return []
    const result = []
    _getFactors(n, 2, [])
    return result
};
```

## 409. Longest Palindrome
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
    const map = {}
    for (const char of s) {
        map[char] = 1 + (map[char] || 0)
    }
    
    let len = 0
    let oddCount = 0
    for (const [key, count] of Object.entries(map)) {
        if (count % 2 === 0) {
            len += count
        } else {
            len += count - 1
            oddCount = 1
        }
    }
    
    return len + oddCount
};
```

## 230. Kth Smallest Element in a BST
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
    const inOrder = (root) => {
        if (!root) return
        
        inOrder(root.left)
        
        if (!k) return
        result = root.val
        k--
        
        inOrder(root.right)
    }
    
    let result = null
    inOrder(root)
    return result
};
```

## 128. Longest Consecutive Sequence
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    const seen = new Set(nums)
    
    let max = 0
    
    for (let num of nums) {
        if (seen.has(num - 1)) continue
        
        let count = 1
        
        while (seen.has(num++)) {
            max = Math.max(max, count++)
        }
    }
    
    return max
};

// Iterative DFS
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if (!nums.length) return 0
    
    const numSet = new Set(nums)
    const visited = new Set()
    let maxLength = 0
    
    for (const num of nums) {
        if (visited.has(num)) continue
        
        let count = 0
        const stack = [num]
        while (stack.length) {
            const curr = stack.pop()
            visited.add(curr)
            count++
            
            if (numSet.has(curr - 1) && !visited.has(curr - 1))
                stack.push(curr - 1)
                
            
            if (numSet.has(curr + 1) && !visited.has(curr + 1))
                stack.push(curr + 1)
        }
        maxLength = Math.max(maxLength, count)    
    }
    
    return maxLength
};

// Recursive DFS
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if (!nums.length) return 0
    
    const numSet = new Set(nums)
    const visited = new Set()
    let maxLength = 0
    
    for (const num of nums) {
        if (visited.has(num)) continue
        maxLength = Math.max(maxLength, dfs(num, numSet, visited))
    }
    
    return maxLength
};

const dfs = (curr, graph, visited) => {
    if (!graph.has(curr) || visited.has(curr)) return 0
    visited.add(curr)
    return 1 + dfs(curr - 1, graph, visited) + dfs(curr + 1, graph, visited)
}

// Top Down DP
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    let max = 0
    const map = {}
    for (const num of nums) {
        map[num] = 1
    }
    
    for (const num of nums) {
        max = Math.max(max, dfs(map, num))
    }
    
    return max
};

const dfs = (map, num) => {
    if (map[num] === undefined)
        return 0
    
    if (map[num] > 1) return map[num]
    
    map[num] = dfs(map, num + 1) + 1
    return map[num]
}

// Union Find
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if (!nums.length) return 0
    
    const unionFind = new UnionFind(nums)
    
    for (const num of nums) {
        unionFind.union(num, num + 1)
    }
    
    return unionFind.maxComponentSize
};

class UnionFind {
    constructor(nums) {
        this.map = {}
        let i = 0
        for (const num of nums) {
            if (this.map[num] === undefined) {
                this.map[num] = i
                i++
            }
        }
        
        this.sizes = Array(nums.length).fill(1)
        this.parent = Array(nums.length).fill()
        for (let i = 0; i < nums.length; i++) {
            this.parent[i] = i
        }
        
        this.numOfComponents = nums.length
        this.maxComponentSize = 1
    }
    
    find(vertex) {
        let p = this.map[vertex]
        if (p === undefined)
            return null
        
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (root !== p) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(vertex1, vertex2) {
        if (this.map[vertex1] === undefined || this.map[vertex2] === undefined) {
            return
        }
        
        const parentP = this.find(vertex1)
        const parentQ = this.find(vertex2)
        
        if (parentP === parentQ) {
            return
        }
        
        if (this.sizes[parentP] < this.sizes[parentQ]) {
            this.sizes[parentQ] += this.sizes[parentP]
            this.parent[parentP] = parentQ
            this.maxComponentSize = Math.max(this.maxComponentSize, this.sizes[parentQ])
        } else {
            this.sizes[parentP] += this.sizes[parentQ]
            this.parent[parentQ] = parentP
            this.maxComponentSize = Math.max(this.maxComponentSize, this.sizes[parentP])
        }
        
        this.numOfComponents--
    }
}
```

## 256. Paint House
```javascript
// Top Down DP
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCost = function(costs) {
    const _minCost = (house, prevColor) => {
        if (house >= houses) return 0
        
        if (memo[house][prevColor]) 
            return memo[house][prevColor]
        
        memo[house][prevColor] = Infinity
        for (let color = 0; color <= 2; color++) {
            if (color === prevColor) continue
            memo[house][prevColor] = Math.min(memo[house][prevColor], 
                                              costs[house][color] + _minCost(house + 1, color))
        }
        
        return memo[house][prevColor]
    }
    
    if (!costs.length) return 0
    const houses = costs.length
    const colors = costs[0].length
    const memo = Array(houses).fill().map(a => Array(colors).fill())
    return _minCost(0, -1)
};

// Bottom Up DP
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCost = function(costs) {
    if (!costs.length) return 0
    
    let prevRow = costs[0]
    
    for (let house = 1; house < costs.length; house++) {
        const currRow = Array(costs[0].length).fill(Infinity)
        for (let color = 0; color < costs[0].length; color++) {
            for (let prevColor = 0; prevColor < costs[0].length; prevColor++) {
                if (color === prevColor) continue
                currRow[color] = Math.min(currRow[color], prevRow[prevColor])
            }

            currRow[color] += costs[house][color]
        }
        
        prevRow = currRow
    }
    
    return Math.min(...prevRow)
};

var minCost = function(costs) {
    if (!costs || costs.length < 1) return 0
    
    for (let i = 1; i < costs.length; i++) {
        costs[i][0] += Math.min(costs[i-1][1], costs[i-1][2])
        costs[i][1] += Math.min(costs[i-1][0], costs[i-1][2])
        costs[i][2] += Math.min(costs[i-1][0], costs[i-1][1])
    }

    return Math.min(...costs[costs.length - 1])
};
```

## 339. Nested List Weight Sum
```javascript
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a single integer equal to value.
 *     @return {void}
 *     this.setInteger = function(value) {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
 *     @return {void}
 *     this.add = function(elem) {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @param {NestedInteger[]} nestedList
 * @return {number}
 */
var depthSum = function(nestedList) {
    const _depthSum = (nestedList, depth) => {
        for (let i = 0; i < nestedList.length; i++) {
            const element = nestedList[i]
            if (element.isInteger()) {
                sum += element.getInteger() * depth
            } else {
                _depthSum(element.getList(), depth + 1)
            }
        }
    }

    let sum = 0
    _depthSum(nestedList, 1)
    return sum
};

/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a single integer equal to value.
 *     @return {void}
 *     this.setInteger = function(value) {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
 *     @return {void}
 *     this.add = function(elem) {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @param {NestedInteger[]} nestedList
 * @return {number}
 */
var depthSum = function(nestedList) {
    const queue = [[nestedList, 1]]
    let sum = 0
    
    while (queue.length) {
        const [list, depth] = queue.shift()
        
        for (let i = 0; i < list.length; i++) {
            const element = list[i]
            if (element.isInteger()) {
                sum += element.getInteger() * depth
            } else {
                queue.push([element.getList(), depth + 1])
            }
        }
    }
    
    return sum
};
```

## 364. Nested List Weight Sum II
```javascript
// Two Pass
var depthSumInverse = function(nestedList) {
    const _depthSumInverse = (nestedList, depth = 1) => {
        let sum = 0
        
        for (let n of nestedList) {
            if (n.isInteger()) {
                sum += (max - depth + 1) * n.getInteger()
            } else {
                sum += _depthSumInverse(n.getList(), depth + 1)
            }
        }
        
        return sum
    }
    
    const maxDepth = (nestedList, depth = 1) => {
        for (let n of nestedList) {
            if (n.isInteger()) {
                max = Math.max(max, depth)
            } else {
                maxDepth(n.getList(), depth + 1)
            }
        }
    }
    
    let max = 0
    maxDepth(nestedList)
    return _depthSumInverse(nestedList)
};

// One Pass
var depthSumInverse = function(nestedList) {
    const _depthSumInverse = (nestedList, d = 1) => {
        for (let n of nestedList) {
            if (n.isInteger()) {
                if (!depths[d]) depths[d] = 0
                depths[d] += n.getInteger()
                max = Math.max(max, d)
            } else {
                _depthSumInverse(n.getList(), d + 1)
            }
        }
    }
    
    const depths = {}
    let max = 0
    
    _depthSumInverse(nestedList)
    
    let sum = 0
    
    for (let [key, val] of Object.entries(depths)) {
        sum += (val * (max - key + 1))
    }
    return sum
};
```

## 937. Reorder Data in Log Files
```javascript
/**
 * @param {string[]} logs
 * @return {string[]}
 */
var reorderLogFiles = function(logs) {
    return logs.sort((a, b) => {
        if (isLetterLog(a) && isLetterLog(b)) {
            const logA = formatLog(a)
            const logB = formatLog(b)
            return logA.localeCompare(logB)
        }
        
        if (isLetterLog(a)) return -1
        if (isLetterLog(b)) return 1
        return 0
    })
};

const isLetterLog = log => {
    const lastChar = log[log.length - 1]
    return 'a' <= lastChar && lastChar <= 'z'
}

const formatLog = log => {
    const sections = log.split(' ')
    return [sections.slice(1), sections[0]].join(' ')
}
```

## 170. Two Sum III - Data structure design
```javascript
TwoSum.prototype.find = function(value) {    
    for (const key of Object.keys(this.seen)) {
        const comp = value - key
        if (comp == key) {
            if (this.seen[comp] > 1) 
                return true
        } else if (this.seen[comp]) {
            return true
        }
    }
    return false
};

/** 
 * Your TwoSum object will be instantiated and called as such:
 * var obj = new TwoSum()
 * obj.add(number)
 * var param_2 = obj.find(value)
 */
```

## 168. Excel Sheet Column Title
```javascript
var convertToTitle = function(n) {
    const map = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
    const result = []
    
    while (n) {
        n--
        result.push(n % 26)
        n = Math.floor(n / 26)
    }
    
    return result.reverse().map((letter) => map[letter]).join('')
};
```

## 171. Excel Sheet Column Number
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    let result = 0
    let power = s.length - 1
    const aCode = 'A'.charCodeAt(0)
    
    for (const letter of s) {
        const letterVal = letter.charCodeAt(0) - aCode + 1
        result += letterVal * (26 ** power)
        power--
    }
    
    return result
};
```

## 198. House Robber
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    const _rob = (i) => {
        if (i >= nums.length) {
            return 0
        }
        
        if (memo[i] !== undefined) {
            return memo[i]
        }
        
        memo[i] = Math.max(nums[i] + _rob(i + 2), _rob(i + 1))
        return memo[i]
    }
    
    const memo = new Array(nums.length)
    return _rob(0)
};

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if (!nums.length) return 0
    
    const dp = Array(nums.length).fill(0)
    dp[0] = nums[0]
    dp[1] = Math.max(nums[0], nums[1])
    
    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
    }
    
    return dp[nums.length - 1]
};

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    let prev = 0
    let curr = 0
    
    for (const n of nums) {
        const temp = curr
        curr = Math.max(n + prev, curr)
        prev = temp
    }

    return curr
}
```

## 953. Verifying an Alien Dictionary
```javascript
/**
 * @param {string[]} words
 * @param {string} order
 * @return {boolean}
 */
var isAlienSorted = function(words, order) {
    const dict = {}
    
    for (let i = 0; i < order.length; i++) {
        dict[order[i]] = i
    }
    
    for (let i = 0; i < words.length - 1; i++) {
        const curr = words[i]
        const next = words[i + 1]
        
        if (!inOrder(curr, next, dict))
            return false
    }
    
    return true
};

const inOrder = (w1, w2, dict) => {
    let i = 0
    let j = 0
    
    while (i < w1.length && j < w2.length) {
        const char1 = dict[w1[i]]
        const char2 = dict[w2[j]]
        
        if (char1 === char2) {
            i++
            j++
            continue
        }
        
        return char1 < char2
    }
    
    return w1.length <= w2.length
}
```

## 326. Power of Three
```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    let count = 0
    
    while (n > 0) {
        const digit = n % 3
        count += digit
        n = Math.floor(n / 3)
    }
    
    return count === 1
};

/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    if (n === 0) return false
    const log = Math.round(getBaseLog(3, n))
    return 3 ** log === n
};

function getBaseLog(x, y) {
  return Math.log(y) / Math.log(x)
}
```

## 824. Goat Latin
```javascript
/**
 * @param {string} S
 * @return {string}
 */
var toGoatLatin = function(S) {
    const result = []
    const vowels = new Set('aeiouAEIOU')
    const words = S.split(' ')
    
    for (let [index, word] of words.entries()) {
        word = word.split('')
        
        if (!vowels.has(word[0])) {
            word.push(word[0])
            word[0] = ''   
        }
        
        word.push('ma')
        word.push('a'.repeat(index + 1))
        result.push(word.join(''))
    }
    
    return result.join(' ')
};
```

## 38. Count and Say
```javascript
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    let result = '1'
    
    for (let i = 2; i <= n; i++) {
        result = getNext(result)
    }
    
    return result
};

const getNext = str => {
    const result = []
    
    let currDigit = 0
    let currCount = 0
    
    for (const digit of str) {
        if (digit !== currDigit) {
            if (currCount > 0) {
                result.push(currCount, currDigit)
            }
            
            currDigit = digit
            currCount = 1
            continue
        }
        
        currCount++
    }
    
    result.push(currCount, currDigit)
    return result.join('')
}
```

## 443. String Compression
```javascript
/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function(chars) {
    let write = 0
    let count = 1
    
    for (let read = 1; read <= chars.length; read++) {
        if (chars[read] === chars[read - 1]) {
            count++
            continue
        }
        
        chars[write++] = chars[read - 1]
        
        if (count > 1) {
            for (const digit of `${count}`) {
                chars[write++] = digit
            }
        }
        
        count = 1
    }
    
    return write
};
```

## 249. Group Shifted Strings
```javascript
var groupStrings = function(strings) {
    const result = {}
    
    for (const string of strings) {
        let hash = []
        
        for (let i = 0; i < string.length - 1; i++) {
            const curr = string[i].charCodeAt(0)
            const next = string[i + 1].charCodeAt(0)
            let dist = next - curr
            if (dist < 0) dist += 26
            hash.push(dist)
        }
        
        hash = hash.join('')
        result[hash] ? result[hash].push(string) : result[hash] = [string]
    }
    
    return Object.values(result)
};
```

## 1148. Article Views I
```sql
# Write your MySQL query statement below
SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY author_id ASC
```

## 868. Binary Gap
```javascript
var binaryGap = function(N) {
    let maxDist = 0
    let currDist = 0
    
    while (N) {
        if (N & 1) {
            maxDist = Math.max(maxDist, currDist)
            currDist = 1
        } else if (currDist) {
            currDist++
        }
        N >>>= 1
    }
    
    return maxDist
};
```

## 586. Customer Placing the Largest Number of Orders
```sql
SELECT customer_number 
FROM orders
GROUP BY customer_number
HAVING count(order_number) = (
	SELECT count(order_number)
	FROM orders
	GROUP BY customer_number
	ORDER BY count(order_number) DESC LIMIT 1
)
```

## 1281. Subtract the Product and Sum of Digits of an Integer
```javascript
var subtractProductAndSum = function(n) {
    let product = 1
    let sum = 0
    
    while (n) {
        product *= n % 10
        sum += n % 10    
        n = Math.floor(n / 10)
    }
    return product - sum
};
```

## 5291. Find Numbers with Even Number of Digits
```javascript
var findNumbers = function(nums) {
    let count = 0
    
    for (let num of nums) {
        let numCount = 0
        
        while (num) {
            numCount++
            num = Math.floor(num / 10)
        }
        
        if ((numCount & 1) === 0)
            count++
    }  
    return count
};
```

## 633. Sum of Square Numbers
```javascript
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
    let left = 0
    let right = Math.floor(Math.sqrt(c))
    
    while (left <= right) {
        const sum = left ** 2 + right ** 2
        
        if (sum === c) {
            return true
        } else if (sum < c) {
            left++
        } else {
            right--
        }
    }
    
    return false
};
```

## 595. Big Countries
```sql
# Write your MySQL query statement below
SELECT name, population, area
FROM World
WHERE area > 3000000 OR population > 25000000

# Write your MySQL query statement below
SELECT name, population, area FROM World WHERE area > 3000000
UNION
SELECT name, population, area FROM World WHERE population > 25000000
```

## 728. Self Dividing Numbers
```javascript
/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function(left, right) {
    const result = []
    for (let num = left; num <= right; num++) {
        if (isSelfDividing(num)) {
            result.push(num)
        }
    }
    
    return result
};

const isSelfDividing = num => {
    let n = num
    while (n) {
        const digit = n % 10
        
        if (digit === 0 || num % digit !== 0) {
            return false
        }
        
        n = Math.trunc(n / 10)
    }
    
    return true
}
```

## 9. Palindrome Number
```javascript
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x >= 0 && x <= 9) return true
    if (x < 0 || x % 10 === 0) return false
    
    let reversedNum = 0
    let num = x
    while (x) {
        const digit = x % 10
        
        reversedNum *= 10
        reversedNum += digit
        
        x = Math.trunc(x / 10)
    }
    
    return num === reversedNum
};
```

## 195. Tenth Line
```bash
# Read from the file file.txt and output the tenth line to stdout.
head -n 10 file.txt | tail -n +10
```

## 175. Combine Two Tables
```sql
# Write your MySQL query statement below
SELECT FirstName, LastName, City, State
FROM Person
LEFT JOIN Address
USING(PersonId)
```

## 1068. Product Sales Analysis I
```sql
SELECT product_name, year, price
FROM Sales
INNER JOIN Product
USING(product_id)
```

## 1069. Product Sales Analysis II
```sql
SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales
GROUP BY product_id 
```

## 511. Game Play Analysis I
```sql
SELECT player_id, MIN(event_date) AS first_login
FROM ACTIVITY
GROUP BY player_id
```

## 1173. Immediate Food Delivery I
```sql
SELECT ROUND(100 * AVG(order_date = customer_pref_delivery_date), 2) AS immediate_percentage 
FROM Delivery
```

## 290. Word Pattern
```javascript
/**
 * @param {string} pattern
 * @param {string} s
 * @return {boolean}
 */
var wordPattern = function(pattern, str) {
    const words = str.split(' ')
    if (words.length !== pattern.length)
        return false
    
    const map = {}
    const seen = new Set()
    
    for (let i = 0; i < words.length; i++) {
        const w = words[i]
        const p = pattern[i]
        
        if (!map[p]) {
            if (seen.has(w)) 
                return false
            
            map[p] = w
            seen.add(w)
            continue
        }
        
        if (map[p] !== w)
            return false
    }
    
    return true
};
```

## 205. Isomorphic Strings
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
    const mapST = {}
    const mapTS = {}
    
    for (let i = 0; i < s.length; i++) {
        const sChar = s[i]
        const tChar = t[i]
        
        if (mapST[sChar] === tChar && mapTS[tChar] === sChar) {
            continue
        }
        
        if (!mapST[sChar] && !mapTS[tChar]) {
            mapST[sChar] = tChar
            mapTS[tChar] = sChar
            continue
        }
        
        return false
    }
    
    return true
};

// Follow up group isomorphic strings. Use encode key for hash map
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
    return encode(s) === encode(t)
};

const encode = str => {
    const result = []
    
    const map = {}
    let count = 0
    for (const char of str) {
        if (map[char] === undefined) {
            map[char] = count
            count++
        }
        
        result.push(map[char])
    }
    
    return result.join('')
}
```

## 371. Sum of Two Integers
```javascript
var getSum = function(a, b) {
    while (b) {
        const carry = a & b
        a ^= b
        b = carry << 1
    }
    
    return a
};
```

## 1290. Convert Binary Number in a Linked List to Integer
```javascript
var getDecimalValue = function(head) {
    let result = 0
    
    while (head) {
        result <<= 1
        result |= head.val
        head = head.next
    }
    
    return result
};
```

## 183. Customers Who Never Order
```sql
-- Left Join
# Write your MySQL query statement below
SELECT Name AS Customers
FROM Customers
LEFT JOIN Orders
ON Customers.Id = Orders.CustomerId
WHERE CustomerId IS Null;

-- Subqueury
# Write your MySQL query statement below
SELECT Name AS Customers
FROM Customers
WHERE Id NOT IN (SELECT DISTINCT CustomerId From Orders)
```

## 1083. Sales Analysis II
```sql
SELECT DISTINCT buyer_id
FROM Sales
JOIN Product
USING(product_id)
WHERE product_name = 'S8'
AND buyer_id NOT IN (SELECT buyer_id
                     FROM sales JOIN product USING(product_id)
                     WHERE product_name = 'iPhone');

-- HAVING
# Write your MySQL query statement below
SELECT DISTINCT buyer_id
FROM Sales AS s
JOIN Product AS p
USING(product_id)
GROUP BY buyer_id
HAVING SUM(product_name = 'S8') > 0 AND SUM(product_name = 'iPhone') = 0
```

## 619. Biggest Single Number
```sql
SELECT MAX(num) as num
FROM (SELECT num 
      FROM my_numbers 
      GROUP BY num 
      HAVING COUNT(num) = 1) AS t
```

## 181. Employees Earning More Than Their Managers
```sql
SELECT e.Name AS Employee
FROM Employee AS e
INNER JOIN Employee AS m
ON e.ManagerId = m.Id
WHERE e.Salary > m.Salary
```

## 597. Friend Requests I: Overall Acceptance Rate
```sql
SELECT ROUND(
    IFNULL(
        (SELECT COUNT(*) FROM (SELECT DISTINCT requester_id, accepter_id FROM request_accepted) AS A)
        /
        (SELECT COUNT(*) FROM (SELECT DISTINCT sender_id, send_to_id FROM friend_request) AS B)
        , 0
    )
, 2) as accept_rate
```

## 1076. Project Employees II
```sql
SELECT project_id
FROM Project
GROUP BY project_id
HAVING COUNT(employee_id) = 
(
    SELECT COUNT(employee_id)
    FROM Project 
    GROUP BY project_id
    ORDER BY COUNT(employee_id) DESC
    LIMIT 1
)
```

## 596. Classes More Than 5 Students
```sql
-- Having
# Write your MySQL query statement below
SELECT class
FROM Courses
GROUP BY class
HAVING COUNT(DISTINCT student) >= 5

-- Subquery
# Write your MySQL query statement below
SELECT class
FROM (SELECT class, COUNT(DISTINCT student) as count
      FROM courses
      GROUP BY class) as t
WHERE count >= 5
```

## 1141. User Activity for the Past 30 Days I
```sql
SELECT activity_date as day, COUNT(DISTINCT user_id) as active_users
FROM Activity
WHERE DATEDIFF('2019-07-27', activity_date) < 30
GROUP BY activity_date
```

## 176. Second Highest Salary
```sql
# Write your MySQL query statement below
SELECT 
    (SELECT DISTINCT Salary
     FROM Employee
     ORDER BY Salary DESC
     LIMIT 1 
     OFFSET 1) AS SecondHighestSalary
```

## 1142. User Activity for the Past 30 Days II
```sql
SELECT ROUND(IFNULL(AVG(count), 0), 2) AS average_sessions_per_user
FROM (
    SELECT COUNT(DISTINCT session_id) AS count
    FROM Activity
    WHERE DATEDIFF('2019-07-27', activity_date) < 30
    GROUP BY user_id
) as temp
```

## 1082. Sales Analysis I
```sql
SELECT seller_id
FROM Sales
GROUP BY seller_id
HAVING SUM(price) = 
(
    SELECT SUM(price) 
    FROM Sales 
    GROUP BY seller_id 
    ORDER BY SUM(price) DESC 
    LIMIT 1
)
```

## 182. Duplicate Emails
```sql
SELECT Email
FROM Person
GROUP BY Email
HAVING COUNT(Email) > 1
```

## 196. Delete Duplicate Emails
```sql
DELETE p1
FROM Person AS p1
JOIN Person AS p2 
ON p1.Email = p2.Email AND p1.ID > p2.ID
```

## 1113. Reported Posts
```sql
SELECT extra AS report_reason, COUNT(DISTINCT post_id) AS report_count
FROM Actions
WHERE action = 'report' AND DATEDIFF(action_date, '2019-07-05') = -1
GROUP BY extra
```

## 1084. Sales Analysis III
```sql
SELECT product_id, product_name
FROM Sales
INNER JOIN Product
USING(product_id)
GROUP BY product_id
HAVING MIN(sale_date) >= '2019-01-01' AND MAX(sale_date) <= '2019-03-31'
```

## 620. Not Boring Movies
```sql
SELECT * 
FROM cinema
WHERE MOD(id, 2) <> 0 AND description <> 'boring'
ORDER BY rating DESC
```

## 1241. Number of Comments per Post
```sql
SELECT S1.sub_id AS post_id, COUNT(DISTINCT S2.sub_id) AS number_of_comments
FROM Submissions AS S1
LEFT JOIN Submissions AS S2
ON S1.sub_id = S2.parent_id
WHERE S1.parent_id IS NULL
GROUP BY S1.sub_id
```

## 1280. Students and Examinations
```sql
-- Subquery
SELECT student_id, student_name, subject_name, 
    (SELECT COUNT(subject_name)
     FROM Examinations AS e
     WHERE e.student_id = st.student_id AND e.subject_name = su.subject_name) 
     AS attended_exams
FROM Students AS st
JOIN Subjects AS su
GROUP BY student_id, subject_name

-- JOINS
SELECT a.student_id, 
       a.student_name, 
       b.subject_name, 
       COUNT(c.subject_name) as attended_exams
FROM Students as a
JOIN Subjects as b
LEFT JOIN Examinations as c
ON a.student_id=c.student_id AND b.subject_name=c.subject_name
GROUP BY a.student_id,b.subject_name;
```

## 584. Find Customer Referee
```sql
SELECT name
FROM customer
WHERE referee_id <> 2 OR referee_id IS NULL
```

## 1294. Weather Type in Each Country
```sql
SELECT country_name, 
CASE WHEN AVG(weather_state) <= 15 THEN 'Cold'
     WHEN AVG(weather_state) >= 25 THEN 'Hot'
     ELSE 'Warm'
     END AS weather_type
FROM Weather
INNER JOIN Countries
USING(country_id)
WHERE MONTH(day) = '11' AND YEAR(day) = '2019'
GROUP BY country_id
```

## 512. Game Play Analysis II
```sql
SELECT player_id, device_id 
FROM activity 
WHERE (player_id, event_date)
IN (SELECT player_id, 
    MIN(event_date)
    FROM Activity 
    GROUP BY player_id)
```

## 607. Sales Person
```sql
SELECT name
FROM salesperson
WHERE sales_id NOT IN (SELECT sales_id
                       FROM orders
                       JOIN company
                       USING(com_id)
                       WHERE name = 'RED')
```

## 610. Triangle Judgement
```sql
SELECT *, IF(x + y > z AND x + z > y AND z + y > x, 'Yes', 'No') as triangle
FROM triangle
```

## 577. Employee Bonus
```sql
SELECT name, bonus
FROM Employee
LEFT JOIN Bonus
USING(empId)
WHERE bonus < 1000 OR bonus IS NULL
```

## 1075. Project Employees I
```sql
SELECT project_id, ROUND(AVG(experience_years), 2) AS average_years
FROM Project
LEFT JOIN Employee
USING(employee_id)
GROUP BY project_id
```

## 1050. Actors and Directors Who Cooperated At Least Three Times
```sql
SELECT actor_id, director_id
FROM ActorDirector
GROUP BY director_id, actor_id
HAVING COUNT(*) >= 3
```

## 613. Shortest Distance in a Line
```sql
# Write your MySQL query statement below
SELECT MIN(ABS(p1.x - p2.x)) AS shortest
FROM point AS p1
JOIN point AS p2 
ON p1.x <> p2.x
```

## 1251. Average Selling Price
```sql
SELECT product_id, ROUND(SUM(units * price) / SUM(units), 2) AS average_price
FROM UnitsSold u
INNER JOIN Prices p
USING(product_id)
WHERE u.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY product_id
```

## 603. Consecutive Available Seats
```sql
SELECT DISTINCT c1.seat_id
FROM cinema as c1
JOIN cinema as c2
ON c1.free = 1 AND c2.free = 1 AND ABS(c1.seat_id - c2.seat_id) = 1
ORDER BY c1.seat_id
```

## 1211. Queries Quality and Percentage
```sql
SELECT query_name, 
       ROUND(AVG(rating / position), 2) AS quality,
       ROUND(AVG(rating < 3) * 100, 2) AS poor_query_percentage
FROM Queries
GROUP BY query_name
```

## 942. DI String Match
```javascript
var diStringMatch = function(S) {
    const result = []
    let low = 0
    let high = S.length
    
    for (let i = 0; i < S.length; i++) {
        if (S[i] === 'I') {
            result.push(low++)
        } else {
            result.push(high--)
        }
    }
    
    result.push(low)
    return result
};
```

## 944. Delete Columns to Make Sorted
```javascript
/**
 * @param {string[]} A
 * @return {number}
 */
var minDeletionSize = function(A) {
    let d = 0
    
    for (let col = 0; col < A[0].length; col++) {
        for (let row = 0; row < A.length - 1; row++) {
            if (A[row][col] > A[row + 1][col]) {
                d++
                break
            }
        }
    }
    
    return d
};
```

## 1303. Find the Team Size
```sql
SELECT employee_id, team_size
FROM Employee
JOIN (SELECT team_id, COUNT(*) as team_size 
      FROM Employee 
      GROUP BY team_id) as t
USING(team_id)
```

## 627. Swap Salary
```sql
-- XOR
UPDATE salary
set sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex));

-- IF
UPDATE salary
SET sex = IF(sex = 'm', 'f', 'm')
```

## 1179. Reformat Department Table
```sql
SELECT 
    id, 
    SUM(IF(month = 'Jan', revenue, null)) AS Jan_Revenue,
    SUM(IF(month = 'Feb', revenue, null)) AS Feb_Revenue,
    SUM(IF(month = 'Mar', revenue, null)) AS Mar_Revenue,
    SUM(IF(month = 'Apr', revenue, null)) AS Apr_Revenue,
    SUM(IF(month = 'May', revenue, null)) AS May_Revenue,
    SUM(IF(month = 'Jun', revenue, null)) AS Jun_Revenue,
    SUM(IF(month = 'Jul', revenue, null)) AS Jul_Revenue,
    SUM(IF(month = 'Aug', revenue, null)) AS Aug_Revenue,
    SUM(IF(month = 'Sep', revenue, null)) AS Sep_Revenue,
    SUM(IF(month = 'Oct', revenue, null)) AS Oct_Revenue,
    SUM(IF(month = 'Nov', revenue, null)) AS Nov_Revenue,
    SUM(IF(month = 'Dec', revenue, null)) AS Dec_Revenue
FROM Department
GROUP BY id
```

## 1056. Confusing Number
```javascript
var confusingNumber = function(N) {
    const map = { 0: 0, 1: 1, 6: 9, 8: 8, 9: 6 }
    
    let num = N
    let result = 0
    while (num) {
        const digit = num % 10
        
        if (map[digit] === undefined)
            return false
        
        result *= 10
        result += map[digit]
        
        num = Math.floor(num / 10)
    }

    return result !== N
};
```

## 521. Longest Uncommon Subsequence I
```javascript
var findLUSlength = function(a, b) {
    return a === b ? -1 : Math.max(a.length, b.length)
};
```

## 504. Base 7
```javascript
// Built In Function
var convertToBase7 = function(num) {
    return num.toString(7)
};

// Math
var convertToBase7 = function(num) {
    const sign = num < 0 ? -1 : 1
    num = Math.abs(num)
    
    let result = 0
    let place = 1
    while (num) {
        result += (num % 7) * place
        place *= 10
        num = Math.floor(num / 7)
    }
    
    return `${sign * result}`
};
```

## 246. Strobogrammatic Number
```javascript
/**
 * @param {string} num
 * @return {boolean}
 */
var isStrobogrammatic = function(num) {
    const map = { '0': '0', '1': '1', '6': '9', '8': '8', '9': '6' }
    
    let left = 0
    let right = num.length - 1
    while (left <= right) {
        if (map[num[left]] === undefined)
            return false
            
        if (map[num[left]] !== num[right])
            return false
        
        left++
        right--
    }
    
    return true
};
```

## 551. Student Attendance Record I
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var checkRecord = function(s) {
    let LCount = 0
    let ACount = 0
    
    for (const status of s) {
        if (status === 'L') {
            if (++LCount > 2) return false
            continue
        }
        
        if (status === 'A')
            if (++ACount > 1) return false
        
        LCount = 0
    }
    
    return true
};
```

## 849. Maximize Distance to Closest Person
```javascript
/**
 * @param {number[]} seats
 * @return {number}
 */
var maxDistToClosest = function(seats) {
    const indices = []
    for (let i = 0; i < seats.length; i++) {
        if (seats[i] === 1) {
            indices.push(i) 
        }
    }
    
    let curr = 0
    let max = 0
    
    for (let i = 0; i < seats.length; i++) {
            const left = Math.abs(i - indices[curr])
            const right = Math.abs(i - indices[curr + 1])
            const min = isNaN(right) ? left : Math.min(left, right)
            
            max = Math.max(max, min)
        
            if (left > right) curr++
    }
    
    return max
};

/**
 * @param {number[]} seats
 * @return {number}
 */
var maxDistToClosest = function(seats) {
    const dists = Array(seats.length).fill(Infinity)
    
    for (let i = 0; i < seats.length; i++) {
        if (seats[i] === 1) {
            dists[i] = 0
        } else if (i > 0) {
            dists[i] = dists[i - 1] + 1
        }
    }
    
    for (let i = seats.length - 1; i >= 0; i--) {
        if (seats[i] === 1) {
            dists[i] = 0
        } else if (i < seats.length - 1) {
            dists[i] = Math.min(dists[i + 1] + 1, dists[i])
        }
    }
    
    return Math.max(...dists)
};
```

## 806. Number of Lines To Write String
```javascript
var numberOfLines = function(widths, S) {
    let lines = 1
    let width = 0

    for (const s of S) {
      const pos = s.charCodeAt(0) - 'a'.charCodeAt(0)
      if (width + widths[pos] > 100) {
          lines++
          width = widths[pos]
          continue
      }  

      width += widths[pos]
    }
    
    return [lines, width]
};
```

## 748. Shortest Completing Word
```javascript
const count = str => {
    return str.toLowerCase().split('').reduce((result, char) => {
        if (char < 'a' || char > 'z')
            return result
        
        result[char] = 1 + (result[char] || 0)
        return result
    }, {})
}

var shortestCompletingWord = function(licensePlate, words) {
    const lpCount = count(licensePlate)
    
    let result = ""    
    
    outer: for (const word of words) {
        if (result.length && word.length >= result.length) 
            continue
        
        const wordCount = count(word)
        
        for (const key of Object.keys(lpCount))
            if (!wordCount[key] || wordCount[key] < lpCount[key])
                continue outer
        
        if (!result.length || result.length > word.length)
            result = word
    }
    
    return result
};
```

## 1089. Duplicate Zeros
```javascript
var duplicateZeros = function(arr) {
    const zeroCount = arr.reduce((c, n) => n === 0 ? c + 1 : c, 0)
    const len = arr.length + zeroCount
    
    let j = len - 1
    for (let i = arr.length - 1; i >= 0; i--) {
        if (arr[i] === 0) {
            if (j < arr.length) arr[j] = arr[i]
            j--
            if (j < arr.length) arr[j] = arr[i]
        } else {
            if (j < arr.length) arr[j] = arr[i]
        }
        j--
    }
};
```

## 1077. Project Employees III
```sql
SELECT p.project_id, p.employee_id
FROM Project as p
INNER JOIN Employee as e
USING(employee_id)
WHERE (p.project_id, e.experience_years) IN 
(SELECT project_id, MAX(experience_years) as max
 FROM Project
 INNER JOIN Employee
 USING(employee_id)
 GROUP BY project_id)
```

## 534. Game Play Analysis III
```sql
SELECT player_id, a1.event_date, SUM(a2.games_played) as games_played_so_far
FROM Activity as a1
INNER JOIN Activity as a2
USING(player_id)
WHERE a1.event_date >= a2.event_date
GROUP BY player_id, a1.event_date
```

## 550. Game Play Analysis IV
```sql
SELECT 
    ROUND(
        (
            SELECT COUNT(DISTINCT player_id)
            FROM Activity
            WHERE (player_id, event_date)
            IN (SELECT player_id, DATE_ADD(MIN(event_date), INTERVAL 1 day)
            FROM Activity
            GROUP BY player_id)
        )
        / 
        (SELECT COUNT(DISTINCT player_id) FROM Activity)
    , 2) 
AS fraction
```

## 177. Nth Highest Salary
```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  SET N = N - 1;
  RETURN (
      SELECT DISTINCT Salary
      FROM Employee
      ORDER BY Salary DESC
      LIMIT 1
      OFFSET N
  );
END
```

## 1045. Customers Who Bought All Products
```sql
SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)
```

## 1308. Running Total for Different Genders
```sql
SELECT s1.gender, s1.day, SUM(s2.score_points) as total
FROM Scores as s1
JOIN Scores as s2
ON s1.gender = s2.gender AND s1.day >= s2.day
GROUP BY s1.gender, s1.day
ORDER BY gender, day
```

## 1204. Last Person to Fit in the Elevator
```sql
SELECT q1.person_name
FROM Queue as q1
INNER JOIN Queue as q2
ON q1.turn >= q2.turn
GROUP BY q1.turn
HAVING SUM(q2.weight) <= 1000
ORDER BY SUM(q2.weight) DESC
LIMIT 1
```

## 178. Rank Scores
```sql
SELECT Score, 
       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) AS Rank
FROM Scores AS s
ORDER BY Score DESC
```

## 614. Second Degree Follower
```sql
-- Subquery
SELECT followee as follower, COUNT(DISTINCT follower) AS num
FROM follow
WHERE followee IN (SELECT follower FROM follow)
GROUP BY followee
ORDER BY followee

-- Self Join
SELECT f1.follower, COUNT(DISTINCT f2.follower) AS num
FROM follow as f1
JOIN follow as f2
ON f1.follower = f2.followee
GROUP BY f1.follower
```

## 626. Exchange Seats
```sql
SELECT 
    (CASE
        WHEN id % 2 != 0 AND id != count THEN id + 1
        WHEN id % 2 != 0 AND id = count THEN id
        ELSE id - 1
    END) as id,
    student
FROM seat
JOIN (SELECT COUNT(*) AS count
      FROM seat) AS seat_counts
ORDER BY id ASC;

-- XOR
SELECT s1.id, COALESCE(s2.student, s1.student) AS student
FROM seat AS s1
LEFT JOIN seat AS s2
ON ((s1.id + 1) ^ 1) - 1 = s2.id
ORDER BY s1.id;
```

## 602. Friend Requests II: Who Has the Most Friends
```sql
SELECT ids AS id, COUNT(*) AS num
FROM (SELECT requester_id AS ids FROM request_accepted
      UNION ALL
      SELECT accepter_id FROM request_accepted
     ) AS t
GROUP BY ids
ORDER BY num DESC
LIMIT 1
```

## 580. Count Student Number in Departments
```sql
SELECT dept_name, COALESCE(count, 0) as student_number
FROM department
LEFT JOIN (SELECT dept_id, COUNT(*) as count
           FROM student
           GROUP BY dept_id) as t
USING(dept_id)
ORDER BY student_number DESC, dept_name
```

## 1212. Team Scores in Football Tournament
```sql
SELECT team_id,
       team_name,
       SUM(CASE WHEN host_goals > guest_goals AND team_id = host_team THEN 3
                WHEN host_goals < guest_goals AND team_id = guest_team THEN 3
                WHEN host_goals = guest_goals THEN 1
                ELSE 0
           END) as num_points
FROM Teams as t
LEFT JOIN Matches as m
ON team_id = host_team OR team_id = guest_team
GROUP BY team_id, team_name
ORDER BY num_points DESC, team_id
```

## 608. Tree Node
```sql
SELECT DISTINCT t1.id, CASE WHEN t1.p_id IS NULL THEN 'Root'
                            WHEN t2.id IS NULL THEN 'Leaf'
                            ELSE 'Inner'
                        END AS Type
FROM tree AS t1
LEFT JOIN tree AS t2
ON t1.id = t2.p_id
```

## 574. Winning Candidate
```sql
SELECT Name
FROM Vote
INNER JOIN Candidate AS c
ON c.id = CandidateId
GROUP BY c.Name
ORDER BY COUNT(*) DESC
LIMIT 1
```

## 1070. Product Sales Analysis III
```sql
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (
    SELECT product_id, MIN(year)
    FROM Sales
    GROUP BY product_id)
```

## 1174. Immediate Food Delivery II
```sql
SELECT ROUND(AVG(order_date = customer_pref_delivery_date) * 100, 2) 
       AS immediate_percentage
FROM Delivery
WHERE (customer_id, order_date) 
IN (SELECT customer_id, MIN(order_date) 
    FROM Delivery 
    GROUP BY customer_id)
```

## 1107. New Users Daily Count
```sql
SELECT login_date, COUNT(*) AS user_count
FROM (SELECT user_id, activity, MIN(activity_date) as login_date
      FROM Traffic
      WHERE activity = 'login'
      GROUP BY user_id) as t
WHERE DATEDIFF('2019-06-30', login_date) <= 90
GROUP BY login_date
```

## 1126. Active Businesses
```sql
SELECT business_id
FROM Events
INNER JOIN (SELECT event_type, AVG(occurences) AS avg_occurence
            FROM Events
            GROUP BY event_type) as t
USING(event_type)
WHERE occurences > avg_occurence
GROUP BY business_id
HAVING COUNT(*) > 1
```

## 197. Rising Temperature
```sql
SELECT w1.Id
FROM Weather AS w1
JOIN Weather AS w2
WHERE DATEDIFF(w1.RecordDate, w2.RecordDate) = 1 AND w1.Temperature > w2.Temperature
```

## 1205. Monthly Transactions II
```sql
SELECT trans_date as month, 
       country,
       COUNT(IF(state = 'approved', 1, NULL)) AS approved_count,
       SUM(IF(state = 'approved', amount, 0)) approved_amount,
       COUNT(IF(state = 'chargeback', 1, NULL)) chargeback_count,
       SUM(IF(state = 'chargeback', amount, 0)) AS chargeback_amount
FROM (
    SELECT LEFT(trans_date, 7) AS trans_date, country, state, amount
    FROM Transactions
    WHERE state = 'approved'

    UNION ALL

    SELECT LEFT(c.trans_date, 7) AS trans_date, country, "chargeback" AS state, amount
    FROM Chargebacks AS c
    INNER JOIN transactions AS t 
    ON c.trans_id = t.id
) as t
GROUP BY country, trans_date
```

## 1098. Unpopular Books
```sql
SELECT b.book_id, b.name
FROM Books as b
LEFT JOIN (SELECT book_id, SUM(quantity) as quantity
           FROM Orders as o
           INNER JOIN Books as b
           USING(book_id)
           WHERE dispatch_date >= DATE_ADD('2019-06-23', INTERVAL -1 YEAR)
           GROUP BY book_id) as t
USING(book_id)
WHERE available_from < DATE_ADD('2019-06-23', INTERVAL -1 MONTH) 
AND (t.quantity IS NULL OR t.quantity < 10)
```

## 578. Get Highest Answer Rate Question
```sql
SELECT question_id as survey_log
FROM survey_log
GROUP BY question_id
ORDER BY COUNT(answer_id) / COUNT(IF(action = 'show', 1, NULL)) DESC
LIMIT 1
```

## 1164. Product Price at a Given Date
```sql
SELECT product_id, COALESCE(t.new_price, 10) AS price
FROM Products
LEFT JOIN (SELECT *
           FROM Products
           WHERE (product_id, change_date) IN 
            (SELECT product_id, MAX(change_date)
             FROM Products
             WHERE change_date <= '2019-08-16'
             GROUP BY product_id)
          ) AS t
USING(product_id)
GROUP BY product_id
```

## 612. Shortest Distance in a Plane
```sql
SELECT MIN(ROUND(SQRT(POW(p2.y - p1.y, 2) + POW(p2.x - p1.x, 2)), 2)) AS shortest
FROM point_2d AS p1
JOIN point_2d AS p2
ON (p1.x, p1.y) <> (p2.x, p2.y)
```

## 1158. Market Analysis I
```sql
SELECT user_id AS buyer_id, 
       join_date, 
       COALESCE(COUNT(o.order_id),0) AS orders_in_2019
FROM Users AS u
LEFT JOIN Orders AS o 
ON u.user_id = o.buyer_id AND YEAR(order_date) = '2019'
GROUP BY user_id
```

## 585. Investments in 2016
```sql
SELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016
FROM insurance AS i
WHERE TIV_2015 IN (SELECT TIV_2015 FROM insurance WHERE PID != i.PID)
AND (LAT, LON) NOT IN (SELECT LAT, LON FROM insurance WHERE PID != i.PID)
```

## 1149. Article Views II
```sql
SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY id
```

## 570. Managers with at Least 5 Direct Reports
```sql
SELECT e2.Name
FROM Employee AS e1
INNER JOIN Employee AS e2
ON e1.ManagerId = e2.Id
GROUP BY e1.ManagerId
HAVING COUNT(*) >= 5
```

## 1112. Highest Grade For Each Student
```sql
SELECT student_id, MIN(course_id) AS course_id, grade
FROM Enrollments
WHERE (student_id, grade) IN
    (SELECT student_id, MAX(grade) as grade
     FROM Enrollments
     GROUP BY student_id)
GROUP BY student_id
ORDER BY student_id
```

## 1193. Monthly Transactions I
```sql
SELECT LEFT(trans_date, 7) AS month, 
       country, 
       COUNT(*) AS trans_count, 
       COUNT(IF(state = 'approved', 1, NULL)) AS approved_count,
       SUM(amount) AS trans_total_amount,
       SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country
```

## 1264. Page Recommendations
```sql
SELECT DISTINCT page_id AS recommended_page
FROM (SELECT IF(user1_id = 1, user2_id, user1_id) AS friend_id
      FROM Friendship
      WHERE user1_id = 1 OR user2_id = 1
     ) as t
INNER JOIN Likes
ON friend_id = user_id
WHERE page_id NOT IN (SELECT page_id FROM Likes WHERE user_id = 1)
```

## 1270. All People Report to the Given Manager
```sql
SELECT e1.employee_id
FROM Employees AS e1
JOIN Employees AS e2 ON e1.manager_id = e2.employee_id
JOIN Employees AS e3 ON e2.manager_id = e3.employee_id
WHERE e3.manager_id = 1 AND e1.employee_id != 1
```

## 1285. Find the Start and End Number of Continuous Ranges
```sql
-- Session Variables
SELECT MIN(log_id) AS start_id, MAX(log_id) AS end_id
FROM (
SELECT log_id, 
       @group:= IF(@previous = log_id - 1, @group, @group + 1) AS grouping, 
       @previous:=log_id AS prev
FROM Logs, 
     (SELECT @group:= 0,
             @previous:= -1) AS init
) as t
GROUP BY grouping
ORDER BY start_id

-- Subqueries
SELECT start_id, MIN(end_id) AS end_id  
FROM 
    (
        (SELECT log_id AS start_id
        FROM Logs
        WHERE log_id - 1 NOT IN (SELECT * FROM Logs)) AS L1

        JOIN

        (SELECT log_id AS end_id
        FROM Logs
        WHERE log_id + 1 NOT IN (SELECT * FROM Logs)) AS L2
    )
WHERE start_id <= end_id
GROUP BY start_id
```

## 180. Consecutive Numbers
```sql
SELECT DISTINCT Num AS ConsecutiveNums
FROM (
SELECT Num, 
       @group:= IF(@previous = Num, @group, @group + 1) AS grouping,
       @previous:= Num AS prev
FROM Logs,
     (SELECT @previous:= 0,
             @group:= 0) AS init
) AS t
GROUP BY grouping
HAVING COUNT(*) >= 3
```

## 1132. Reported Posts II
```sql
SELECT ROUND(AVG(percent) * 100, 2) AS average_daily_percent
FROM (SELECT action_date,
      COUNT(DISTINCT r.post_id) / COUNT(DISTINCT a.post_id) AS percent
      FROM Actions AS a
      LEFT JOIN Removals AS r
      USING(post_id)
      WHERE extra = 'spam'
      GROUP BY action_date
     ) AS temp
```

## 185. Department Top Three Salaries
```sql
-- Session Variables
SELECT d.Name AS Department, e.Name AS Employee, e.Salary
FROM Employee AS e
JOIN Department AS d
ON e.DepartmentId = d.Id
WHERE (e.Salary, d.Id) IN
    (SELECT Salary, DepartmentId
     FROM (SELECT Salary, DepartmentId, 
                  @rank:= IF(@prev = DepartmentId, @rank + 1, 0) AS rank, 
                  @prev:= DepartmentId
           FROM (SELECT DISTINCT Salary, DepartmentId
                 FROM Employee
                 ORDER BY DepartmentId, Salary DESC) AS distinct_salaries,
                (SELECT @rank:= 0, @prev:= 0) AS init
          ) AS ranked_salaries
     WHERE rank < 3)
```

## 262. Trips and Users
```sql
SELECT Request_at AS Day,
       ROUND(AVG(Status != 'completed'), 2) AS 'Cancellation Rate'
FROM Trips
WHERE Client_Id IN (SELECT Users_Id FROM Users WHERE Banned = 'NO') 
      AND Driver_Id IN (SELECT Users_Id FROM Users WHERE Banned = 'NO')
      AND Request_at BETWEEN '2013-10-01' AND '2013-10-03'
GROUP BY Request_at
```

## 1225. Report Contiguous Dates
```sql
SELECT state AS period_state, 
       MIN(date) AS start_date, 
       MAX(date) AS end_date
FROM (SELECT date, 
             state, 
             @group_id:= IF(state = @prev_state, @group_id, @group_id + 1) AS group_id, 
             @prev_state:= state AS prev_state
      FROM (SELECT success_date AS date, 'succeeded' AS state 
            FROM Succeeded 
            WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31'
            
            UNION 
            
            SELECT fail_date AS date, 'failed' AS state 
            FROM Failed
            WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31'
            ORDER BY date
           ) as t1,
           (SELECT @prev_state := '', @group_id:= 0) AS init
     ) as t2
GROUP BY group_id
```

## 1194. Tournament Winners
```sql
SELECT group_id, player_id
FROM (SELECT group_id, player_id, SUM(score) AS total_points
      FROM (SELECT first_player AS player_id, first_score AS score FROM Matches
            UNION ALL
            SELECT second_player AS player_id, second_score AS score FROM Matches
        ) AS t1
        JOIN Players 
        USING(player_id)
        GROUP BY player_id
        ORDER BY group_id, total_points DESC, player_id
    ) AS t2
GROUP BY group_id
```

## 1159. Market Analysis II
```sql
SELECT user_id AS seller_id, 
       IF(i.item_brand = u.favorite_brand, "yes", "no") AS '2nd_item_fav_brand'
FROM Users AS u 
LEFT JOIN (SELECT seller_id, item_id
           FROM orders AS o1
           WHERE 1 = (SELECT COUNT(*) 
                      FROM orders AS o2 
                      WHERE o1.seller_id = o2.seller_id 
                      AND o1.order_date > o2.order_date)
          ) AS t1
ON u.user_id = t1.seller_id
LEFT JOIN Items AS i
ON t1.item_id = i.item_id
```

## 579. Find Cumulative Salary of an Employee
```sql
SELECT e1.Id, e1.Month, SUM(e2.Salary) AS Salary
FROM Employee AS e1
JOIN Employee AS e2
ON e1.Id = e2.Id AND e1.month >= e2.month AND e2.Month 
                 AND e1.Month - e2.Month <= 2
WHERE e1.Month NOT IN (SELECT MAX(month) FROM Employee WHERE e1.Id = Id)
GROUP BY e1.Id, e1.Month
ORDER BY e1.Id, e1.Month DESC
```

## 569. Median Employee Salary
```sql
SELECT t1.Id, t1.Company, t1.Salary
FROM (SELECT Id, 
             Company, 
             Salary, 
             @row_number:= IF(@company_name = Company, @row_number + 1, 1) AS row_number, 
             @company_name:= Company AS company_name
      FROM Employee, (SELECT @row_number:= 0, @company_name:= 0) AS init
      ORDER BY Company, Salary
     ) AS t1
JOIN (SELECT Company, 
             FLOOR((COUNT(*) + 1) / 2) as floor, 
             CEIL((COUNT(*) + 1) / 2) as ceil 
      FROM Employee
      GROUP BY Company) as t2
ON t1.Company = t2.Company
WHERE row_number = floor or row_number = ceil
```

## 1097. Game Play Analysis V
```sql
SELECT install_dt, 
       COUNT(*) AS installs, 
       ROUND(COUNT(event_date) / COUNT(*), 2) AS Day1_retention
FROM (SELECT player_id, MIN(event_date) AS install_dt
      FROM Activity
      GROUP BY player_id) AS i
LEFT JOIN Activity as a
ON i.player_id = a.player_id AND install_dt = event_date - 1
GROUP BY install_dt
```

## 571. Find Median Given Frequency of Numbers
```sql
SELECT AVG(Number) AS median
FROM (SELECT Number, 
             Frequency,
             @range_start:= @prev_end + 1 AS range_start,
             @range_end:= @range_end + Frequency AS range_end,
             @prev_end:= @range_end AS prev
      FROM Numbers, (SELECT @range_start:= 0, @range_end:= 0, @prev_end:= 0) AS init
      ORDER BY Number
     ) AS temp
WHERE (SELECT FLOOR((SUM(Frequency) + 1) / 2) FROM Numbers) BETWEEN range_start AND range_end
OR (SELECT CEIL((SUM(Frequency) + 1) / 2) FROM Numbers) BETWEEN range_start AND range_end
```

## 615. Average Salary: Departments VS Company
```sql
SELECT LEFT(pay_date, 7) AS pay_month, 
       department_id,
       CASE WHEN AVG(amount) > (SELECT AVG(amount) 
                                FROM salary 
                                WHERE LEFT(pay_date, 7) = pay_month) THEN "higher"
            WHEN AVG(amount) < (SELECT AVG(amount) 
                                FROM salary 
                                WHERE LEFT(pay_date, 7) = pay_month) THEN "lower"
            ELSE 'same'
       END AS comparison
FROM Salary
JOIN Employee
USING(employee_id)
GROUP BY department_id, pay_month
```

## 1127. User Purchase Platform
```sql
SELECT t1.spend_date, 
       t1.platform, 
       IFNULL(SUM(amount), 0) AS total_amount,
       COUNT(user_id) AS total_users
FROM (SELECT DISTINCT(spend_date), 'mobile' AS platform FROM Spending
      UNION
      SELECT DISTINCT(spend_date), 'desktop' AS platform FROM Spending
      UNION
      SELECT DISTINCT(spend_date), 'both' AS platform FROM Spending
     ) as t1
LEFT JOIN (SELECT user_id,
                  spend_date,
                  CASE WHEN mobile_amount > 0 AND desktop_amount > 0 THEN 'both'
                       WHEN mobile_amount > 0 THEN 'mobile'
                       WHEN desktop_amount > 0 THEN 'desktop'
                  END AS platform,
                  mobile_amount + desktop_amount AS amount
           FROM (SELECT user_id,
                        spend_date,
                        SUM(IF(platform = 'mobile', amount, 0)) AS mobile_amount,
                        SUM(IF(platform = 'desktop', amount, 0)) AS desktop_amount
                 FROM Spending
                 GROUP BY spend_date, user_id
                ) AS u
          ) as t2
ON t1.spend_date = t2.spend_date AND t1.platform = t2.platform
GROUP BY spend_date, platform
```

## 618. Students Report By Geography
```sql
SELECT America, Asia, Europe
FROM (SELECT name AS Asia, 
             @rankA:= @rankA + 1 as rank
      FROM (SELECT * 
            FROM student 
            WHERE continent = 'Asia'
            ORDER BY continent, name) as a1,
      (SELECT @rankA:= 0) as init
     ) as a2
RIGHT JOIN (SELECT name AS America, 
                   @rankB:= @rankB + 1 as rank
           FROM (SELECT * 
                 FROM student 
                 WHERE continent = 'America'
                 ORDER BY continent, name) as b1,
           (SELECT @rankB:= 0) as init
          ) as b2
ON a2.rank = b2.rank
LEFT JOIN (SELECT name AS Europe, 
                  @rankC:= @rankC + 1 as rank
           FROM (SELECT * 
                 FROM student 
                 WHERE continent = 'Europe'
                 ORDER BY continent, name) as c1,
           (SELECT @rankC:= 0) as init
          ) as c2
ON b2.rank = c2.rank

-- Follow Up
SELECT MAX(America) AS America, MAX(Asia) as Asia, MAX(Europe) AS Europe
FROM (
    SELECT 
        CASE WHEN continent = 'America' THEN @r1 := @r1 + 1
             WHEN continent = 'Asia'    THEN @r2 := @r2 + 1
             WHEN continent = 'Europe'  THEN @r3 := @r3 + 1 
        END row_id,
        CASE WHEN continent = 'America' THEN name END America,
        CASE WHEN continent = 'Asia'    THEN name END Asia,
        CASE WHEN continent = 'Europe'  THEN name END Europe
    FROM student, (SELECT @r1 := 0, @r2 := 0, @r3 := 0) AS row_id
    ORDER BY name
) t
GROUP BY row_id;
```

## 601. Human Traffic of Stadium
```sql
SELECT id, visit_date, people
FROM (SELECT id, 
             visit_date, 
             people,
             CASE WHEN people >= 100 AND @prev1 = true THEN @grouping1
                  ELSE @grouping1 := @grouping1 + 1
             END AS grouping,
             @prev1 := people >= 100 AS prev
      FROM stadium, (SELECT @grouping1 := 0, @prev1 := false) AS init
     ) as t1
WHERE (grouping) IN
(SELECT grouping
 FROM (SELECT CASE WHEN people >= 100 AND @prev2 = true THEN @grouping2
                   ELSE @grouping2 := @grouping2 + 1
              END AS grouping,
              @prev2 := people >= 100 AS prev
       FROM stadium, (SELECT @grouping2 := 0, @prev2 := false) as init
      ) as t2
 GROUP BY grouping
 HAVING COUNT(*) >= 3)
```

## 22. Generate Parentheses
```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    const _generateParenthesis = (open, closed) => {
        if (open < 0 || closed < 0) return
        
        if (closed < open) {
            return
        }
        
        if (open === 0 && closed === 0) {
            result.push(combo.join(''))
            return
        }
        
        // add open
        combo.push('(')
        _generateParenthesis(open - 1, closed)
        combo.pop()
        
        // add closed
        combo.push(')')
        _generateParenthesis(open, closed - 1)
        combo.pop()
    }
    
    const result = []
    const combo = []
    _generateParenthesis(n, n)
    return result
};
```

## 1079. Letter Tile Possibilities
```javascript
/**
 * @param {string} tiles
 * @return {number}
 */
var numTilePossibilities = function(tiles) {
    const _numTilePossibilities = length => {
        let count = 0
        for (let i = 0; i < letters.length; i++) {
            if (letters[i] <= 0) continue
            letters[i]--
            count += 1 + _numTilePossibilities(length + 1)
            letters[i]++
        }
        return count
    }
    
    const letters = Array(26).fill(0)
    for (const tile of tiles) {
        const index = tile.charCodeAt(0) - 'A'.charCodeAt(0)
        letters[index]++
    }
    
    return _numTilePossibilities(0)
};
```

## 1219. Path with Maximum Gold
```javascript
// Time: O(m * n  3 ^ k), where k is the number of cells with gold
// Memory: O(k) for the recursion.
/**
 * @param {number[][]} grid
 * @return {number}
 */
var getMaximumGold = function(grid) {
    const _getMaximumGold = (row, col, gold) => {
        if (grid[row][col] <= 0) return gold
        
        let max = 0
        let currGold = grid[row][col]
        grid[row][col] = -1
        
        for (const [dRow, dCol] of dirs) {
            const nextRow = row + dRow
            const nextCol = col + dCol
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen) continue
            
            max = Math.max(max, _getMaximumGold(nextRow, nextCol, gold + currGold))
        }
        
        grid[row][col] = currGold
        return max
    }
    
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const rowLen = grid.length
    const colLen = grid[0].length
    
    let max = 0
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            max = Math.max(max, _getMaximumGold(row, col, 0))
        }
    }
    return max
};
```

## 1087. Brace Expansion
```javascript
/**
 * @param {string} S
 * @return {string[]}
 */
var expand = function(S) {
    const _expand = (i, curr) => {
        if (i === options.length) {
            result.push(curr.join(''))
            return
        }
        
        for (const option of options[i]) {
            curr.push(option)
            _expand(i + 1, curr)
            curr.pop()
        }
    }
    
    const options = parseOptions(S)
    const result = []
    _expand(0, [])
    return result
};

const parseOptions = str => {    
    const options = []
    
    let curr = []
    let open = false
    for (const char of str) {
        if (char === ',') continue
        
        if (char === '{') {
            open = true
            curr = []
            continue
        }
        
        if (char === '}') {
            open = false
            curr.sort((a, b) => a.localeCompare(b))
            options.push(curr)
            continue
        }
        
        if (open) {
            curr.push(char)
        } else {
            options.push([char])
        }
    }
    
    return options
}
```

## 320. Generalized Abbreviation
```javascript
// Backtracking
var generateAbbreviations = function(word) {
    const _generateAbbreviations = (curr, index, lastIsAbbreviation = false) => {
        if (index === word.length) {
            result.push(curr.join(''))
            return
        }
        
        curr.push(word[index])
        _generateAbbreviations(curr, index + 1, false)
        curr.pop()
        
        if (lastIsAbbreviation) return
        
        for (let i = 1; i <= word.length - index; i++) {
            curr.push(i)
            _generateAbbreviations(curr, index + i, true)
            curr.pop()   
        }
    }
    
    const result = []
    _generateAbbreviations([], 0)
    return result
};

// Iterative Bit Manipulation
/**
 * @param {string} word
 * @return {string[]}
 */
var generateAbbreviations = function(word) {
    const n = word.length
    const result = []
    
    for (let bin = 0; bin < 1 << n; bin++) {
        result.push(abbrForBin(word, bin))
    }
    
    return result
};

const abbrForBin = (word, bin) => {
    const abbr = []
    
    let curr = 0
    for (let wordIndex = word.length - 1; wordIndex >= 0; wordIndex--) {
        const bit = bin & 1
        
        if (bit) {
            curr++
        } else {
            if (curr) abbr.push(curr)
            curr = 0
            
            abbr.push(word[wordIndex])
        }
        
        bin >>= 1
    }
    
    if (curr) abbr.push(curr)    
    return abbr.reverse().join('')
}
```

## 526. Beautiful Arrangement
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var countArrangement = function(N) {
    const _countArrangement = (i, used) => {
        if (i === N + 1) return 1
        
        if (memo[`${i}-${used}`] !== undefined)
            return memo[`${i}-${used}`]
        
        let count = 0
        for (let num = 1; num <= N; num++) {
            const mask = 1 << num
            if (used & mask) continue
            if (i % num !== 0 && num % i !== 0) continue
            count += _countArrangement(i + 1, used | mask)
        }
        
        memo[`${i}-${used}`] = count
        return count
    }
    
    const memo = {}
    return _countArrangement(1, 0)
};
```

## 216. Combination Sum III
```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
    const _combinationSum3 = (digit, sum) => {
        if (path.length === k && sum === n) {
            result.push(path.slice())
            return
        }
        
        if (digit > 9 || path.length >= k || sum >= n) {
            return
        }
        
        path.push(digit)
        _combinationSum3(digit + 1, sum + digit)
        path.pop()
        
        _combinationSum3(digit + 1, sum)
    }
    
    const result = []
    const path = []
    _combinationSum3(1, 0)
    return result
};
```

## 1291. Sequential Digits
```javascript
// Sliding Window
var sequentialDigits = function(low, high) {
    const result = []
    const num = "123456789"
    const n = 10
    
    const lowLen = `${low}`.length
    const highLen = `${high}`.length
    
    for (let length = lowLen; length <= highLen; length++) {
        for (let start = 0; start < n - length; start++) {
            const candidate = num.slice(start, start + length)
            if (candidate >= low && candidate <= high) {
                result.push(candidate)
            }
        }
    }
    
    return result
};

// Backtracking
/**
 * @param {number} low
 * @param {number} high
 * @return {number[]}
 */
var sequentialDigits = function(low, high) {
    const _sequentialDigits = (num) => {
        if (num > high) return
        
        if (num >= low && num <= high) {
            result.push(num)
        }
        
        const digit = num % 10
        if (digit === 9) return
        num *= 10
        num += digit + 1
        
        _sequentialDigits(num)
    }
    
    const result = []
    for (let num = 1; num <= 9; num++) {
        _sequentialDigits(num)
    }
    result.sort((a, b) => a - b)
    return result
};
```

## 98. Validate Binary Search Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    const _isValidBST = (node, left, right) => {
        if (!node) return true
        
        if (left >= node.val || node.val >= right) {
            return false
        }
        
        return _isValidBST(node.left, left, node.val) &&
               _isValidBST(node.right, node.val, right)
    }
    
    return _isValidBST(root, -Infinity, Infinity)
};
```

## 31. Next Permutation
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    let i = nums.length - 2
    while (i >= 0 && nums[i + 1] <= nums[i]) {
        i--
    }
        
    if (i >= 0) {
        let j = nums.length - 1
        while (j >= 0 && nums[j] <= nums[i]) {
            j--
        }
        
        swap(nums, i, j)
    }
    
    reverse(nums, i + 1)
};

const reverse = (arr, start) => {
    let i = start
    let j = arr.length - 1
    
    while (i < j) {
        swap(arr, i, j)
        i++
        j--
    }
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 93. Restore IP Addresses
```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
    const _restoreIpAddresses = (index, address) => {
        if (address.length === 4 && index === s.length) {
            result.push(address.join('.'))
            return
        }
        
        if (address.length >= 4 || index >= s.length) {
            return
        }
        
        let num = 0
        for (let i = index; i < index + 3; i++) {
            if (i > index && num === 0) return
            
            num *= 10
            num += +s[i]
            
            if (num > 255) return
            
            address.push(num)
            _restoreIpAddresses(i + 1, address)
            address.pop()
        }
    }
    
    const result = []
    _restoreIpAddresses(0, [])
    return result
};
```

## 1038. Binary Search Tree to Greater Sum Tree
```javascript
var bstToGst = function(root) {
    const dfs = (root) => {
        if (!root) return
        dfs(root.right)
        
        sum += root.val
        root.val = sum
        
        dfs(root.left)
    }
    
    let sum = 0
    dfs(root)
    return root
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var bstToGst = function(root) {
    const dfs = (node, sum) => {
        if (!node) return sum
        
        node.val += dfs(node.right, sum)
        return dfs(node.left, node.val)
    }
    
    dfs(root, 0)
    return root
};
```

## 1214. Two Sum BSTs
```javascript
var twoSumBSTs = function(root1, root2, target) {
    const dfs = (root) => {
        if (!root) return 
        
        dfs(root.left)
        if (search(root2, target - root.val)) {
            isPair = true
            return
        }
        dfs(root.right)
    }
    
    const search = (root, val) => {
        if (seen.has(val)) return true
        
        while (root) {
            if (root.val === val)
                return true
            
            seen.add(root.val)
            
            if (root.val > val) {
                root = root.left
            } else {
                root = root.right
            }
        }
        return false
    }
    
    const seen = new Set()
    let isPair = false
    dfs(root1)
    return isPair
};
```

## 444. Sequence Reconstruction
```javascript
var sequenceReconstruction = function(org, seqs) {
    const graph = buildGraph(seqs)
    const degrees = getDegrees(graph, org.length)
    const queue = []
    let n = 0
    
    for (const vertex of Object.keys(graph)) {
        if (degrees[vertex] === undefined) return false
        if (degrees[vertex] === 0) {
            queue.push(vertex)
            n++
        }
    }
    
    while (queue.length) {
        if (queue.length > 1) 
            return false
        
        const vertex = queue.shift()
        
        if (!graph[vertex]) 
            continue
        
        for (const neighbor of graph[vertex]) {
            if (--degrees[neighbor] === 0) {
                queue.push(neighbor)
                n++
            }
        }
    }
    
    return n === org.length && n === Object.keys(graph).length
};

const buildGraph = seqs => {
    const graph = {}
    
    for (const seq of seqs) {
        if (seq.length === 1) {
            if (!graph[seq[0]]) {
                graph[seq[0]] = []   
            }
        } else {
            for(let i = 0; i < seq.length - 1; i++) {
                if(!graph[seq[i]]) {
                    graph[seq[i]] = []
                }

                if(!graph[seq[i + 1]]) {
                    graph[seq[i + 1]] = []
                }
                
                graph[seq[i]].push(seq[i + 1])
            }   
        }
    }
    
    return graph
}

const getDegrees = (graph, n) => {
    const degrees = Array(n + 1).fill(0)
    
    for (const [vertex, neighbors] of Object.entries(graph)) {
        for (const neighbor of neighbors) {
            degrees[neighbor]++
        }
    }
    
    return degrees
}
```

## 269. Alien Dictionary
```javascript
// DFS TopSort
/**
 * @param {string[]} words
 * @return {string}
 */
var alienOrder = function(words) {    
    const graph = buildGraph(words)
    return topSort(graph)
};

const topSort = graph => {
    const dfs = vertex => {
        if (visiting.has(vertex)) {
            return false
        }
        
        if (visited.has(vertex)) {
            return true
        }
        
        visiting.add(vertex)
        
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                if (!dfs(neighbor)) {
                    return false
                }
            }
        }
        
        visiting.delete(vertex)
        visited.add(vertex)
        result.push(vertex)
        
        return true
    }
    
    const visited = new Set()
    const visiting = new Set()
    const result = []
    
    for (const node of Object.keys(graph)) {
        if (!dfs(node)) {
            return ''
        }
    }
    
    return result.reverse().join('')
}

const buildGraph = words => {
    const graph = {}
    
    for (const word of words) {
        for (const char of word) {
            if (!graph[char]) graph[char] = []
        }
    }
    
    for (let i = 0; i < words.length - 1; i++) {
        const currWord = words[i]
        const nextWord = words[i + 1]
        
        for (let j = 0; j < Math.max(currWord.length, nextWord.length); j++) {
            if (currWord[j] === undefined) {
                break
            }
            
            // Invalid ordering of input words ['abc', 'ab'] => ''
            if (nextWord[j] === undefined) {
                return {}
            }
            
            if (currWord[j] !== nextWord[j]) {
                graph[currWord[j]].push(nextWord[j])               
                break
            }
        }
    }
    
    return graph
} 

// Kahn's Algo
/**
 * @param {string[]} words
 * @return {string}
 */
var alienOrder = function(words) {
    const [graph, degrees] = buildGraph(words)
    
    const queue = []
    for (const [vertex, degree] of Object.entries(degrees)) {
        if (degree === 0) {
            queue.push(vertex)
        }
    }
    
    for (let i = 0; i < queue.length; i++) {
        const vertex = queue[i]
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                degrees[neighbor]--
                if (degrees[neighbor] === 0) {
                    queue.push(neighbor)
                }
            }
        }
    }
    
    return queue.length === Object.keys(graph).length ? queue.join('') : ''
};

const buildGraph = words => {
    const graph = {}
    const degrees = {}
    
    for (const word of words) {
        for (const char of word) {
            if (!graph[char]) {
                graph[char] = new Set()
                degrees[char] = 0
            }
        }
    }
    
    for (let i = 0; i < words.length - 1; i++) {
        const currWord = words[i]
        const nextWord = words[i + 1]
        
        for (let j = 0; j < Math.max(currWord.length, nextWord.length); j++) {
            if (currWord[j] === undefined) {
                break
            }
            
            // Invalid ordering of input words ['abc', 'ab'] => ''
            if (nextWord[j] === undefined) {
                return [{}, {}]
            }
            
            if (currWord[j] !== nextWord[j]) {
                if (!graph[currWord[j]].has(nextWord[j])) {
                    graph[currWord[j]].add(nextWord[j])
                    degrees[nextWord[j]]++
                }
                break
            }
        }
    }
    
    return [graph, degrees]
}
```

## 622. Design Circular Queue
```javascript
var MyCircularQueue = function(k) {
    this.k = k
    this.elements = Array(k).fill(null)
    this.writeIndex = 0
    this.readIndex = 0
};

/**
 * Insert an element into the circular queue. Return true if the operation is successful. 
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
    if (this.isFull())
        return false
    
    this.elements[this.writeIndex++ % this.k] = value
    return true
};

/**
 * Delete an element from the circular queue. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
    if (this.isEmpty())
        return false
        
    this.readIndex++
    return true
};

/**
 * Get the front item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
    return this.isEmpty() ? -1 : this.elements[this.readIndex % this.k]
};

/**
 * Get the last item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
    return this.isEmpty() ? -1 : this.elements[(this.writeIndex - 1) % this.k]
};

/**
 * Checks whether the circular queue is empty or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
    return this.writeIndex === this.readIndex
};

/**
 * Checks whether the circular queue is full or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
    return (this.writeIndex - this.readIndex) === this.k
};

/** 
 * Your MyCircularQueue object will be instantiated and called as such:
 * var obj = new MyCircularQueue(k)
 * var param_1 = obj.enQueue(value)
 * var param_2 = obj.deQueue()
 * var param_3 = obj.Front()
 * var param_4 = obj.Rear()
 * var param_5 = obj.isEmpty()
 * var param_6 = obj.isFull()
 */
```

## 1061. Lexicographically Smallest Equivalent String
```javascript
var smallestEquivalentString = function(A, B, S) {
    const set = new DisjointSet()
    
    for (let i = 0; i < A.length; i++) {
        const aPos = posForChar(A[i])
        const bPos = posForChar(B[i])
        set.union(aPos, bPos)
    }
    
    const result = []
    for (const char of S) {
        const sPos = posForChar(char)
        const parent = set.find(sPos)
        result.push(charForPos(parent))
    }
    
    return result.join('')
};

class DisjointSet {
    constructor() {
        this.parent = []
        for (let i = 0; i < 26; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root])
            root = this.parent[root]
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (rootP > rootQ) {
            this.parent[rootP] = rootQ
        } else {
            this.parent[rootQ] = rootP
        }
    }
}

const posForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
const charForPos = pos => String.fromCharCode(pos + 'a'.charCodeAt(0))
```

## 1101. The Earliest Moment When Everyone Become Friends
```javascript
var earliestAcq = function(logs, N) {
    const set = new DisjointSet(N)
    logs.sort((a, b) => a[0] - b[0])
    
    for (const [time, a, b] of logs) {
        set.union(a, b)
        if (set.numOfComponents === 1)
            return time
    }
    return -1
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root])
            root = this.parent[root]
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 547. Friend Circles
```javascript
var findCircleNum = function(M) {
    const set = new DisjointSet(M.length)
    
    for (let i = 0; i < M.length; i++) {
        for (let j = 0; j < M[0].length; j++) {
            if (M[i][j] === 1) {
                set.union(i, j)
            }
        }
    }
    
    return set.numOfComponents
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 1319. Number of Operations to Make Network Connected
```javascript
// Union Find
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var makeConnected = function(n, connections) {
    if (connections.length < n - 1) return -1
    
    const set = new DisjointSet(n)
    for (const [start, end] of connections)
        set.union(start, end)
        
    return set.numOfComponents - 1
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}

// BFS
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var makeConnected = function(n, connections) {
    if (connections.length < n - 1) return -1
    
    const graph = buildGraph(n, connections)
    const visited = new Set()
    let numOfComponents = 0
    for (let vertex = 0; vertex < n; vertex++) {
        if (visited.has(vertex)) continue
        visited.add(vertex)
        countComponent(vertex, graph, visited)
        numOfComponents++
    }
    
    return numOfComponents - 1
};

const buildGraph = (n, connections) => {
    const graph = Array(n).fill().map(a => [])
    
    for (const [u, v] of connections) {
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}

const countComponent = (vertex, graph, visited) => {
    const queue = [vertex]
    while (queue.length) {
        const node = queue.shift()
        
        for (const neighbor of graph[node]) {
            if (visited.has(neighbor)) continue
            visited.add(neighbor)
            
            queue.push(neighbor)
        }
    }
}
```

## 990. Satisfiability of Equality Equations
```javascript
var equationsPossible = function(equations) {
    const set = new DisjointSet(26)
    
    for (const equation of equations) {
        if (equation[1] === '=') {
            const v1 = posForChar(equation[0])
            const v2 = posForChar(equation[3])
            set.union(v1, v2)
        }
    }
    
    for (const equation of equations) {
        if (equation[1] === '!') {
            const v1 = posForChar(equation[0])
            const v2 = posForChar(equation[3])
            if (set.find(v1) === set.find(v2))
                return false
        }
    }
    return true
};

const posForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 261. Graph Valid Tree
```javascript
// Union Find
var validTree = function(n, edges) {
    const set = new DisjointSet(n)
    
    for (const [start, end] of edges) {
        if (set.find(start) === set.find(end))
            return false
        
        set.union(start, end)
    }
    return set.numOfComponents === 1
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}

// DFS 1
var validTree = function(n, edges) {
    const dfs = (vertex) => {
        for (const neighbor of graph[vertex]) {
            if (visited.has(neighbor)) continue
            visited.add(neighbor)
            dfs(neighbor)
        }
    }
    
    if (edges.length !== n - 1) return false
    const graph = buildGraph(n, edges)
    const visited = new Set([0])
    dfs(0)
    return visited.size === n
};

const buildGraph = (n, edges) => {
    const graph = Array(n).fill().map(a => [])
    for (const [u, v] of edges) {
        graph[u].push(v)
        graph[v].push(u)
    }
    return graph
}

// DFS 2
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */
var validTree = function(n, edges) {
    const dfs = (vertex, parent) => {
        for (const neighbor of graph[vertex]) {
            if (neighbor === parent) continue
            if (visited.has(neighbor)) return false
            visited.add(neighbor)
            if (!dfs(neighbor, vertex)) return false
        }
        return true
    }
    
    const graph = buildGraph(n, edges)
    const visited = new Set([0])
    return dfs(0, null) && visited.size === n
};

const buildGraph = (n, edges) => {
    const graph = Array(n).fill().map(a => [])
    for (const [u, v] of edges) {
        graph[u].push(v)
        graph[v].push(u)
    }
    return graph
}
```

## 737. Sentence Similarity II
```javascript
var areSentencesSimilarTwo = function(words1, words2, pairs) {
    if (words1.length !== words2.length) 
        return false
    
    const set = new DisjointSet(2 * pairs.length)
    const map = {}
    
    let count = 0
    for (const [word1, word2] of pairs) {
        if (!map[word1]) map[word1] = count++
        if (!map[word2]) map[word2] = count++
        
        const pos1 = map[word1]
        const pos2 = map[word2]
        set.union(pos1, pos2)
    }
    
    for (let i = 0; i < words1.length; i++) {
        const pos1 = map[words1[i]]
        const pos2 = map[words2[i]]

        if (set.find(pos1) !== set.find(pos2))
            return false
    }
    
    return true
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 734. Sentence Similarity
```javascript
/**
 * @param {string[]} words1
 * @param {string[]} words2
 * @param {string[][]} pairs
 * @return {boolean}
 */
var areSentencesSimilar = function(words1, words2, pairs) {
    if (words1.length !== words2.length)
        return false
    
    const wordsSet = new Set()
    for (const [a, b] of pairs) {
        wordsSet.add(`${a}#${b}`)
    }
    
    for (let i = 0; i < words1.length; i++) {
        const word1 = words1[i]
        const word2 = words2[i]
        
        if (word1 !== word2 && 
            !wordsSet.has(`${word1}#${word2}`) && 
            !wordsSet.has(`${word2}#${word1}`)) {
            return false
        }
    }
    
    return true
};
```

## 1202. Smallest String With Swaps
```javascript
var smallestStringWithSwaps = function(s, pairs) {
    const set = new DisjointSet(s.length)
    for (const [index1, index2] of pairs) {
        set.union(index1, index2)
    }
    
    const map = {}
    for (let i = 0; i < s.length; i++) {
        const componentId = set.find(i)
        if (map[componentId]) {
            map[componentId].push(s[i])
        } else {
            map[componentId] = [s[i]]
        }
    }
    
    for (const val of Object.values(map)) {
        val.sort().reverse()
    }
    
    const result = []
    for (let i = 0; i < s.length; i++) {
        result.push(map[set.find(i)].pop())
    }
    
    return result.join('')
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 1302. Deepest Leaves Sum
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var deepestLeavesSum = function(root) {
    const dfs = (node, level) => {
        if (!node) return
        
        if (!node.left && !node.right) {
            if (maxLevel === level) {
                sum += node.val
            } else if (maxLevel < level) {
                sum = node.val
                maxLevel = level
            }
        }
        
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)
    }
    
    let maxLevel = 0
    let sum = 0
    dfs(root, 0)
    return sum
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var deepestLeavesSum = function(root) {
    const stack = [[root, 0]]
    
    let maxLevel = 0
    let sum = 0
    
    while (stack.length) {
        const [node, level] = stack.pop()
        
        if (!node.left && !node.right) {
            if (maxLevel === level) {
                sum += node.val
            } else if (maxLevel < level) {
                maxLevel = level
                sum = node.val
            }
        }
        
        if (node.right) stack.push([node.right, level + 1])
        if (node.left) stack.push([node.left, level + 1])
    }
    
    return sum
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var deepestLeavesSum = function(root) {
    const queue = [root]
    let totalSum = 0
    while (queue.length) {
        const size = queue.length
        let sum = 0
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            sum += node.val
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        totalSum = sum
    }
    return totalSum
};
```

## 1315. Sum of Nodes with Even-Valued Grandparent
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumEvenGrandparent = function(root) {
    const _sumEvenGrandparent = (node, parent, grandParent) => {
        if (!node) return 0
        
        let sum = 0
        if (grandParent && grandParent.val % 2 === 0) {
            sum += node.val
        }
        
        sum += _sumEvenGrandparent(node.left, node, parent)
        sum += _sumEvenGrandparent(node.right, node, parent)
        return sum
    }
    
    return _sumEvenGrandparent(root, null, null)
};
```

## 701. Insert into a Binary Search Tree
```javascript
// Iterative
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var insertIntoBST = function(root, val) {
    let curr = root
    let parent = null
    
    while (curr) {
        parent = curr
        
        if (val > curr.val) {
            curr = curr.right
        } else {
            curr = curr.left
        }
    }
    
    const node = new TreeNode(val)
    if (val > parent.val) {
        parent.right = node
    } else {
        parent.left = node
    }
    
    return root
};

// Recursive
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var insertIntoBST = function(root, val) {    
    if (!root) return new TreeNode(val)

    if (val > root.val) {
        root.right = insertIntoBST(root.right, val)
    } else {
        root.left = insertIntoBST(root.left, val)
    }

    return root
};
```

## 1261. Find Elements in a Contaminated Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 */
var FindElements = function(root) {
    const decontaminate = root => {
        if (!root) return
        
        this.values.add(root.val)
        
        if (root.left) {
            root.left.val = 2 * root.val + 1
            decontaminate(root.left)
        }
        
        if (root.right) {
            root.right.val = 2 * root.val + 2
            decontaminate(root.right)
        }
    }
    
    root.val = 0
    this.root = root
    this.values = new Set()
    decontaminate(root)
};

/** 
 * @param {number} target
 * @return {boolean}
 */
FindElements.prototype.find = function(target) {
    return this.values.has(target)
};

/** 
 * Your FindElements object will be instantiated and called as such:
 * var obj = new FindElements(root)
 * var param_1 = obj.find(target)
 */
```

## 1325. Delete Leaves With a Given Value
```javascript
var removeLeafNodes = function(root, target) {
    const dfs = (node) => {
        if (!node) return null
        
        node.left = dfs(node.left)
        node.right = dfs(node.right)
        
        if (!node.left && !node.right && node.val === target) 
            return null
        
        return node
    }
    
    return dfs(root)
};
```

## 814. Binary Tree Pruning
```javascript
var pruneTree = function(root) {
    const dfs = (node) => {
        if (!node) return null
        
        node.left = dfs(node.left)
        node.right = dfs(node.right)
        
        if (!node.left && !node.right && node.val === 0) 
            return null
        
        return node
    }
    
    return dfs(root)
};
```

## 721. Accounts Merge
```javascript
// DFS
var accountsMerge = function(accounts) {
    const [graph, emailToName] = buildGraph(accounts)
    
    const result = []
    const seen = new Set()
    
    for (const vertex of Object.keys(graph)) {
        if (seen.has(vertex)) continue
        
        seen.add(vertex)
        const stack = [vertex]
        const component = []
        
        while (stack.length) {
            const curr = stack.pop()
            component.push(curr)
            for (const neighbor of graph[curr]) {
                if (seen.has(neighbor)) continue
                seen.add(neighbor)
                stack.push(neighbor)
            }
        }
        component.sort()
        result.push([emailToName[vertex], ...component])
    }
    
    return result
};

const buildGraph = (accounts) => {
    const graph = {}
    const emailToName = {}
    
    for (const [name, ...emails] of accounts) {
        for (let i = 0; i < emails.length; i++) {
            emailToName[emails[i]] = name
            
            if (!graph[emails[i]])
                graph[emails[i]] = new Set()
            
            if (i === 0) continue
            
            graph[emails[0]].add(emails[i])
            graph[emails[i]].add(emails[0])
        }
    }
    
    return [graph, emailToName]
}

// Disjoint Set
var accountsMerge = function(accounts) {
    const set = new DisjointSet()
    const emailToName = {}
    
    for (const [name, ...emails] of accounts) {
        for (let i = 0; i < emails.length; i++) {
            const firstEmail = emails[0]
            const currEmail = emails[i]
            
            emailToName[currEmail] = name
            set.makeSet(currEmail)
            
            if (i === 0) continue
            
            set.union(firstEmail, currEmail)
        }
    }
    
    const map = {}
    for (const email of Object.keys(emailToName)) {
        if (map[set.find(email)]) {
            map[set.find(email)].push(email)
        } else {
            map[set.find(email)] = [email]
        }
    }
    
    const result = []
    for (const emails of Object.values(map)) {
        emails.sort()
        result.push([emailToName[emails[0]], ...emails])
    }
    
    return result
};

class DisjointSet {
    constructor() {
        this.numOfComponents = 0
        this.componentSize = []
        this.parent = []
        this.map = {}
        this.id = 0
    }
    
    makeSet(p) {
        if (this.map[p] !== undefined) 
            return
        
        this.map[p] = this.id++
        this.numOfComponents++
        this.componentSize.push(1)
        this.parent.push(this.map[p])
    }
    
    find(p) {
        if (this.map[p] === undefined) 
            return null
        
        p = this.map[p]
        
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === null || rootQ === null) return
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 947. Most Stones Removed with Same Row or Column
```javascript
// Union Find
var removeStones = function(stones) {
    const set = new DisjointSet(20000)
    
    for (const [row, col] of stones) {
        set.union(row, col + 10000)
    }
    
    const seen = new Set()
    for (const [row, col] of stones) {
        seen.add(set.find(row))
    }
    
    return stones.length - seen.size
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 1167. Minimum Cost to Connect Sticks
```javascript
var connectSticks = function(sticks) {
    const heap = new Heap(sticks)
    let cost = 0
    
    while (heap._elements.length > 1) {
        const t1 = heap.remove()
        const t2 = heap.remove()
        
        const currCost = t1 + t2
        cost += currCost
        heap.insert(currCost)
    }
    
    return cost
};

class Heap {
  constructor(elements, sort = ((a, b) => { return a < b })) {
    this._elements = elements
    this._sort = sort
    this._heapify()
  }
  
  _heapify() {
    for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
      this._siftDown(i);
    }
  }
  
  _siftUp(index) {
    let childIndex = index
    let parentIndex = this._parentIndex(childIndex)
    
    while (childIndex > 0 && 
           this._sort(this._elements[childIndex], this._elements[parentIndex])) {
      let temp = this._elements[childIndex]
      this._elements[childIndex] = this._elements[parentIndex]
      this._elements[parentIndex] = temp
      
      childIndex = parentIndex
      parentIndex = this._parentIndex(childIndex)
    }
    
  }
  
  _siftDown(index) {
    let parentIndex = index
    while (true) {
      let leftIndex = this._leftChildIndex(parentIndex)
      let rightIndex = this._rightChildIndex(parentIndex)
      let candidate = parentIndex
      
      if (leftIndex < this._elements.length && 
          this._sort(this._elements[leftIndex], this._elements[candidate])) {
        candidate = leftIndex
      }
            
      if (rightIndex < this._elements.length && 
          this._sort(this._elements[rightIndex], this._elements[candidate])) {
        candidate = rightIndex
      }
      
      if (parentIndex === candidate) {
        return
      }
      
      let temp = this._elements[parentIndex]
      this._elements[parentIndex] = this._elements[candidate]
      this._elements[candidate] = temp
      
      parentIndex = candidate
    }
  }
  
  _leftChildIndex(parentIndex) {
    return 2 * parentIndex + 1
  }
  
  _rightChildIndex(parentIndex) {
    return 2 * parentIndex + 2
  }
  
  _parentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  
  insert(element) {
    this._elements.push(element)
    this._siftUp(this._elements.length - 1)
  }
  
  remove() {
    if (this._elements.length < 1) {
      return null
    }
    
    let temp = this._elements[0]
    this._elements[0] = this._elements[this._elements.length - 1]
    this._elements[this._elements.length - 1] = temp
    
    let element = this._elements.pop()
    this._siftDown(0)
    return element
  }
}
```

## 1196. How Many Apples Can You Put into the Basket
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var maxNumberOfApples = function(arr) {
    const buckets = Array(1001).fill(0)
    for (const a of arr) {
        buckets[a]++
    }
    
    let max = 0
    let currWeight = 0
    
    for (let i = 0; i < buckets.length; i++) {
        if (buckets[i] === 0) continue
        
        while (buckets[i]) {
            if (currWeight + i > 5000) return max
            currWeight += i
            max++
            buckets[i]--
        }
        
    }
    
    return max
};
```

## 1029. Two City Scheduling
```javascript
// Quick Select
var twoCitySchedCost = function(costs) {
    let cost = 0
    const n = Math.floor(costs.length / 2)
    quickSelect(costs, n)
    
    for (let i = 0; i < costs.length; i++) 
        cost += i < n ? costs[i][0] : costs[i][1]
    
    return cost
};

const quickSelect = (arr, k) => {
    const _quickSelect = (start, end) => {
        if (start >= end) return start
        
        const randomIndex = random(start, end)
        swap(arr, randomIndex, end)
        
        const partitionIndex = partition(arr, start, end)
        if (partitionIndex === k)
            return k
        
        if (partitionIndex > k) {
            return _quickSelect(start, partitionIndex - 1)
        } else {
            return _quickSelect(partitionIndex + 1, end)
        }
    }
    
    return _quickSelect(0, arr.length - 1)
}

const partition = (arr, start, end) => {
    const pivotElement = arr[end][0] - arr[end][1]
    let j = start - 1
    
    for (let i = start; i < end; i++) {
        if (arr[i][0] - arr[i][1] <= pivotElement) {
            swap(arr, i, ++j)
        }
    }
    
    swap(arr, ++j, end)
    return j
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min

// Sort
/**
 * @param {number[][]} costs
 * @return {number}
 */
var twoCitySchedCost = function(costs) {
    costs.sort((a, b) => {
        const diffA = a[0] - a[1]
        const diffB = b[0] - b[1]
        return diffA - diffB
    })
    
    let cost = 0
    let i = 0
    for (let j = costs.length / 2; j < costs.length; j++) {
        cost += costs[i++][0]
        cost += costs[j][1]
    }
    
    return cost
};
```

## 1005. Maximize Sum Of Array After K Negations
```javascript
// Counting Sort
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var largestSumAfterKNegations = function(A, K) {
    const sortedA = sort(A)
    
    let i = 0
    while (i < sortedA.length && K) {
        if (sortedA[i] === 0 || sortedA[i] > 0) break
        sortedA[i] *= -1
        i++
        K--
    }
    
    if (sortedA[i - 1] < sortedA[i]) {
        i--
    }
    
    if (K % 2 !== 0) {
        sortedA[i] *= -1
    }
    
    return getSum(sortedA)
};

const getSum = arr => {
    let sum = 0
    for (const a of arr) {
        sum += a
    }
    
    return sum
}

const sort = arr => {
    const buckets = Array(201).fill(0)
    for (const a of arr) {
        buckets[a + 100]++
    }
    
    const result = []
    for (let i = 0; i < buckets.length; i++) {
        while (buckets[i]--) {
            result.push(i - 100)
        }
    }
    
    return result
}

// Heap
var largestSumAfterKNegations = function(A, K) {
    const heap = new Heap(A)
    
    while (K--) {
        const top = heap.remove()
        heap.insert(-top)
    }
    
    return heap._elements.reduce((r, e) => r + e, 0)
};

class Heap {
  constructor(elements, sort = ((a, b) => { return a < b })) {
    this._elements = elements
    this._sort = sort
    this._heapify()
  }
  
  _heapify() {
    for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
      this._siftDown(i);
    }
  }
  
  _siftUp(index) {
    let childIndex = index
    let parentIndex = this._parentIndex(childIndex)
    
    while (childIndex > 0 && 
           this._sort(this._elements[childIndex], this._elements[parentIndex])) {
      let temp = this._elements[childIndex]
      this._elements[childIndex] = this._elements[parentIndex]
      this._elements[parentIndex] = temp
      
      childIndex = parentIndex
      parentIndex = this._parentIndex(childIndex)
    }
    
  }
  
  _siftDown(index) {
    let parentIndex = index
    while (true) {
      let leftIndex = this._leftChildIndex(parentIndex)
      let rightIndex = this._rightChildIndex(parentIndex)
      let candidate = parentIndex
      
      if (leftIndex < this._elements.length && 
          this._sort(this._elements[leftIndex], this._elements[candidate])) {
        candidate = leftIndex
      }
            
      if (rightIndex < this._elements.length && 
          this._sort(this._elements[rightIndex], this._elements[candidate])) {
        candidate = rightIndex
      }
      
      if (parentIndex === candidate) {
        return
      }
      
      let temp = this._elements[parentIndex]
      this._elements[parentIndex] = this._elements[candidate]
      this._elements[candidate] = temp
      
      parentIndex = candidate
    }
  }
  
  _leftChildIndex(parentIndex) {
    return 2 * parentIndex + 1
  }
  
  _rightChildIndex(parentIndex) {
    return 2 * parentIndex + 2
  }
  
  _parentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  
  insert(element) {
    this._elements.push(element)
    this._siftUp(this._elements.length - 1)
  }
  
  remove() {
    if (this._elements.length < 1) {
      return null
    }
    
    let temp = this._elements[0]
    this._elements[0] = this._elements[this._elements.length - 1]
    this._elements[this._elements.length - 1] = temp
    
    let element = this._elements.pop()
    this._siftDown(0)
    return element
  }
}
```

## 1323. Maximum 69 Number
```javascript
var maximum69Number  = function(num) {
    let curr = num
    let base = 1
    let sixBase = -1
    
    while (curr > 1) {
        if (curr % 10 === 6) {
            sixBase = base
        }
        
        base *= 10
        curr = Math.floor(curr / 10)
    }
    
    return sixBase !== -1 ? num + sixBase * 3 : num
};
```

## 1313. Decompress Run-Length Encoded List
```javascript
var decompressRLElist = function(nums) {
    const result = []
    
    for (let i = 0; i < nums.length - 1; i += 2) {
        let a = nums[i]
        let b = nums[i + 1]
        
        while (a--) result.push(b)
    }
    
    return result
};
```

## 1180. Count Substrings with Only One Distinct Letter
```javascript
var countLetters = function(S) {
    let count = 0
    let i = 0
    let j = 1
    
    while (i < S.length) {
        if (S[i] === S[j]) {
            j++
            continue
        }
        
        const n = j - i
        count += Math.floor((n * (n + 1)) / 2)
        i = j++
    }
    
    return count
};

/**
 * @param {string} S
 * @return {number}
 */
var countLetters = function(S) {
    let count = 0
    let prevChar = ''
    let i = 0
    
    for (let j = 0; j < S.length; j++) {
        const char = S[j]
        if (prevChar !== char) {
            i = j
            prevChar = char
        }
        
        count += j - i + 1
    }
    
    return count
};
```

## 958. Check Completeness of a Binary Tree
```javascript
var isCompleteTree = function(root) {
    let seenNull = false
    const queue = [root]
    while (queue.length) {
        const node = queue.shift()
        if (node === null) {
            seenNull = true
        } else {
            if (seenNull) return false
            queue.push(node.left)
            queue.push(node.right)
        }
    }
    return true
};
```

## 450. Delete Node in a BST
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function(root, key) {
    const _deleteNode = (node) => {
        if (!node) return null
        
        if (node.val === key) {
            if (!node.left && !node.right) {
                return null
            }
            
            if (!node.right) {
                return node.left
            }
            
            if (!node.left) {
                return node.right
            }
            
            const rightMin = getMin(node.right)
            node.val = rightMin
            node.right = deleteNode(node.right, rightMin)
        } else if (node.val < key) {
            node.right = _deleteNode(node.right)
        } else {
            node.left = _deleteNode(node.left)
        }
        
        return node
    }
    
    return _deleteNode(root)
};

const getMin = node => {
    while (node && node.left) {
        node = node.left
    }
    return node.val
}
```

## 1135. Connecting Cities With Minimum Cost
```javascript
// Kruskal's
var minimumCost = function(N, connections) {
    const set = new DisjointSet(N)
    let totalCost = 0
    
    connections.sort((a, b) => a[2] - b[2])
    for (const [start, end, cost] of connections) {
        if (set.find(start) === set.find(end))
            continue
        
        totalCost += cost
        set.union(start, end)
        
        if (set.numOfComponents === 1) 
            return totalCost
    }
    
    return set.numOfComponents === 1 ? totalCost : -1
};

class DisjointSet {
    constructor(N) {
        this.numOfComponents = N
        this.componentSize = Array(N).fill(1)
        this.parent = []
        
        for (let i = 0; i < N; i++)
            this.parent[i] = i
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}

// Prim's
var minimumCost = function(N, connections) {
    const graph = buildGraph(connections)
    const heap = new Heap([[N, 0]], (a, b) => a[1] < b[1])
    const visited = new Set()
    let totalCost = 0
    
    while (heap._elements.length && visited.size < N) {
        const [vertex, cost] = heap.remove()
        if (visited.has(vertex))
            continue
        
        visited.add(vertex)
        totalCost += cost
        
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                if (!visited.has(neighbor[0]))
                    heap.insert(neighbor)
            }
        }
    }
    return visited.size === N ? totalCost : -1
};

const buildGraph = connections => {
    const graph = {}
    
    for (const [start, end, cost] of connections) {
        if (graph[start]) {
            graph[start].push([end, cost])
        } else {
            graph[start] = [[end, cost]]
        }
        
        if (graph[end]) {
            graph[end].push([start, cost])
        } else {
            graph[end] = [[start, cost]]
        }
    }
    
    return graph
}

class Heap {
  constructor(elements, sort = ((a, b) => { return a < b })) {
    this._elements = elements
    this._sort = sort
    this._heapify()
  }
  
  _heapify() {
    for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
      this._siftDown(i);
    }
  }
  
  _siftUp(index) {
    let childIndex = index
    let parentIndex = this._parentIndex(childIndex)
    
    while (childIndex > 0 && 
           this._sort(this._elements[childIndex], this._elements[parentIndex])) {
      let temp = this._elements[childIndex]
      this._elements[childIndex] = this._elements[parentIndex]
      this._elements[parentIndex] = temp
      
      childIndex = parentIndex
      parentIndex = this._parentIndex(childIndex)
    }
    
  }
  
  _siftDown(index) {
    let parentIndex = index
    while (true) {
      let leftIndex = this._leftChildIndex(parentIndex)
      let rightIndex = this._rightChildIndex(parentIndex)
      let candidate = parentIndex
      
      if (leftIndex < this._elements.length && 
          this._sort(this._elements[leftIndex], this._elements[candidate])) {
        candidate = leftIndex
      }
            
      if (rightIndex < this._elements.length && 
          this._sort(this._elements[rightIndex], this._elements[candidate])) {
        candidate = rightIndex
      }
      
      if (parentIndex === candidate) {
        return
      }
      
      let temp = this._elements[parentIndex]
      this._elements[parentIndex] = this._elements[candidate]
      this._elements[candidate] = temp
      
      parentIndex = candidate
    }
  }
  
  _leftChildIndex(parentIndex) {
    return 2 * parentIndex + 1
  }
  
  _rightChildIndex(parentIndex) {
    return 2 * parentIndex + 2
  }
  
  _parentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  
  insert(element) {
    this._elements.push(element)
    this._siftUp(this._elements.length - 1)
  }
  
  remove() {
    if (this._elements.length < 1) {
      return null
    }
    
    let temp = this._elements[0]
    this._elements[0] = this._elements[this._elements.length - 1]
    this._elements[this._elements.length - 1] = temp
    
    let element = this._elements.pop()
    this._siftDown(0)
    return element
  }
}
```

## 860. Lemonade Change
```javascript
var lemonadeChange = function(bills) {
    let fives = 0
    let tens = 0
    
    for (const bill of bills) {
        if (bill === 5) {
            fives++
        } else if (bill === 10) {
            tens++
            fives--
        } else if (tens > 0) {    
            tens--
            fives--    
        } else {
            fives -= 3
        }
        
        if (fives < 0) return false
    }
    
    return true
};
```

## 129. Sum Root to Leaf Numbers
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    const _sumNumbers = (node, pathNum) => {
        if (!node) return
        
        pathNum *= 10
        pathNum += node.val
        
        if (!node.left && !node.right) {
            sum += pathNum
            return
        }
        
        _sumNumbers(node.left, pathNum)
        _sumNumbers(node.right, pathNum)
    }
    
    let sum = 0
    _sumNumbers(root, 0)
    return sum
};
```

## 515. Find Largest Value in Each Tree Row
```javascript
// DFS
var largestValues = function(root) {
    const dfs = (root, level) => {
        if (!root) return
        
        if (levels[level] === undefined) {
            levels[level] = root.val
        } else {
            levels[level] = Math.max(levels[level], root.val) 
        }
        
        dfs(root.left, level + 1)
        dfs(root.right, level + 1)
    }
    
    const levels = []
    dfs(root, 0)
    return levels
};

// BFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function(root) {
    if (!root) return []
    
    const result = []
    const queue = [root]
    while (queue.length) {
        const size = queue.length
        let max = -Infinity
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            max = Math.max(max, node.val)
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        result.push(max)
    }
    return result
};
```

## 513. Find Bottom Left Tree Value
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function(root) {
    let left = null
    const queue = [root]
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            if (i === 0) left = node.val
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
    }
    
    return left
};
```

## 124. Binary Tree Maximum Path Sum
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
    const _maxPathSum = (node) => {
        if (!node) return 0
        
        const left = Math.max(_maxPathSum(node.left), 0)
        const right = Math.max(_maxPathSum(node.right), 0)
        
        max = Math.max(max, node.val + left + right)
        
        return node.val + Math.max(left, right)
    }
    
    let max = -Infinity
    _maxPathSum(root)
    return max
};
```

## 99. Recover Binary Search Tree
```javascript
var recoverTree = function(root) {
    const dfs = root => {
        if (!root) return
        dfs(root.left)
        
        if (prev && prev.val > root.val) {
            if (first === null)
                first = prev
            
            second = root
        }
        prev = root
        
        dfs(root.right)
    }
    
    const swap = (node1, node2) => {
        const temp = node1.val
        node1.val = node2.val
        node2.val = temp
    }
    
    let first = null
    let second = null
    let prev = null
    
    dfs(root)
    swap(first, second)
};
```

## 863. All Nodes Distance K in Binary Tree
```javascript
// BFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} target
 * @param {number} K
 * @return {number[]}
 */
var distanceK = function(root, target, K) {
    const graph = buildGraph(root)
    const result = []
    const queue = [target]
    const visited = new Set([target])
    
    while (queue.length && K >= 0) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (K === 0) {
                result.push(node.val)
            }

            for (const neighbor of graph[node.val]) {
                if (visited.has(neighbor)) continue

                visited.add(neighbor)
                queue.push(neighbor)
            }
        }
        
        K--
    }
    
    return result
};

const buildGraph = root => {
    const dfs = (node, parent) => {
        if (!node) return
        
        if (!graph[node.val])
            graph[node.val] = []
        
        if (parent) {
            graph[node.val].push(parent)
            graph[parent.val].push(node)
        }
        
        dfs(node.left, node)
        dfs(node.right, node)
    }
    
    const graph = {}
    dfs(root)
    return graph
}
```

## 1026. Maximum Difference Between Node and Ancestor
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxAncestorDiff = function(root) {
    const _maxAncestorDiff = (node, max, min) => {
        if (!node) return max - min
        
        max = Math.max(node.val, max)
        min = Math.min(node.val, min)
        
        const leftMax = _maxAncestorDiff(node.left, max, min)
        const rightMax = _maxAncestorDiff(node.right, max, min)
        return Math.max(leftMax, rightMax)
    }
    
    return _maxAncestorDiff(root, -Infinity, Infinity)
};
```

## 979. Distribute Coins in Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var distributeCoins = function(root) {
    const dfs = root => {
        if (!root) return 0
        
        const left = dfs(root.left)
        const right = dfs(root.right)
        moves += Math.abs(left) + Math.abs(right)
        return root.val + left + right - 1
    }
    let moves = 0
    dfs(root)
    return moves
};
```

## 1123. Lowest Common Ancestor of Deepest Leaves
```javascript
var lcaDeepestLeaves = function(root) {
    const dfs = root => {
        if (!root) return [null, 0]
        
        const [lNode, lDepth] = dfs(root.left)
        const [rNode, rDepth] = dfs(root.right)
        
        if (lDepth === rDepth)
            return [root, lDepth + 1]
        
        if (lDepth > rDepth)
            return [lNode, lDepth + 1]
            
        return [rNode, rDepth + 1]
    }
    
    const [node, depth] = dfs(root)
    return node
};
```

## 173. Binary Search Tree Iterator
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 */
var BSTIterator = function(root) {
    this.stack = []
    this.curr = root
    
    this._getNext()
};

/**
 * @return {number}
 */
BSTIterator.prototype.next = function() {
    const node = this.stack.pop()
    
    this.curr = node.right
    this._getNext()
    
    return node.val
};

/**
 * @return {boolean}
 */
BSTIterator.prototype.hasNext = function() {
    return this.stack.length
};


BSTIterator.prototype._getNext = function() {
    while (this.curr) {
        this.stack.push(this.curr)
        this.curr = this.curr.left
    }
};

/** 
 * Your BSTIterator object will be instantiated and called as such:
 * var obj = new BSTIterator(root)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */
```

## 156. Binary Tree Upside Down
```javascript
var upsideDownBinaryTree = function(root) {
    const dfs = node => {
        if (!node) return null
        
        if (!node.left && !node.right) {
            newRoot = node
            return node
        }
        
        const root = dfs(node.left)
        root.left = node.right
        root.right = node
        
        node.left = null
        node.right = null
        return node
    }
    
    let newRoot = null
    dfs(root)
    return newRoot
};
```

## 663. Equal Tree Partition
```javascript
var checkEqualTree = function(root) {
    const sum = node => {
        if (!node) return 0
        
        const left = sum(node.left)
        const right = sum(node.right)
        
        node.sum = node.val + left + right
        
        if (node !== root)
            seen.add(node.sum)
        
        return node.sum
    }
    
    const seen = new Set()
    const total = sum(root)    
    return seen.has(total / 2)
};
```

## 114. Flatten Binary Tree to Linked List
```javascript
var flatten = function(root) {
    if (!root) return
    
    const stack = [root]
    
    while (stack.length) {
        const curr = stack.pop()
        
        if (curr.right)
            stack.push(curr.right)
        
        if (curr.left)
            stack.push(curr.left)
        
        if (stack.length)
            curr.right = stack[stack.length - 1]
        
        curr.left = null
    }
};
```

## 1104. Path In Zigzag Labelled Binary Tree
```javascript
var pathInZigZagTree = function(label) {
    const result = []
    
    let level = 1
    while (label >= 2 ** level)
        level++
    
    while (label !== 0) {
        result.push(label)
        max = 2 ** level - 1
        min = 2 ** (level - 1)
        label = Math.floor((max + min - label) / 2)
        level--
    }
    
    return result.reverse()
};
```

## 1120. Maximum Average Subtree
```javascript
var maximumAverageSubtree = function(root) {
    const dfs = root => {
        if (!root) return [0, 0]
        
        const [leftSum, leftCount] = dfs(root.left)
        const [rightSum, rightCount] = dfs(root.right)
        const sum = root.val + leftSum + rightSum
        const count = 1 + leftCount + rightCount
        const avg = sum / count
        maxAvg = Math.max(maxAvg, avg)
        return [sum, count]
    }
    
    let maxAvg = 0
    dfs(root)
    return maxAvg
};
```

## 654. Maximum Binary Tree
```javascript
// O(n^2)
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
    const _constructMaximumBinaryTree = (left, right) => {
        if (left > right) return null
        
        let maxIndex = left
        for (let i = left + 1; i <= right; i++) {
            if (nums[maxIndex] < nums[i]) {
                maxIndex = i
            }
        }
        
        const root = new TreeNode(nums[maxIndex])
        root.left = _constructMaximumBinaryTree(left, maxIndex - 1)
        root.right = _constructMaximumBinaryTree(maxIndex + 1, right)
        return root
    }
    
    return _constructMaximumBinaryTree(0, nums.length - 1)
};

// O(n)
var constructMaximumBinaryTree = function(nums) {
    const stack = []
    
    for (let i = 0; i < nums.length; i++) {
        const node = new TreeNode(nums[i])
        
        while (stack.length && stack[stack.length - 1].val < node.val)
            node.left = stack.pop()
        
        if (stack.length)
            stack[stack.length - 1].right = node
        
        stack.push(node)
    }
    
    return stack.length ? stack[0] : null
};
```

## 951. Flip Equivalent Binary Trees
```javascript
var flipEquiv = function(root1, root2) {
    const dfs = (node1, node2) => {
        if (!node1 && !node2)
            return true
        
        if (!node1 || !node2 || node1.val !== node2.val)
            return false
        
        const node1Left = node1.left ? node1.left.val : null
        const node2Left = node2.left ? node2.left.val : null
        
        return dfs(node1.left, node2.left) && dfs(node1.right, node2.right) ||
               dfs(node1.left, node2.right) && dfs(node1.right, node2.left)
    }
    
    return dfs(root1, root2)
};
```

## 865. Smallest Subtree with all the Deepest Nodes
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var subtreeWithAllDeepest = function(root) {
    const dfs = root => {
        if (!root) return [null, 0]
        
        const [leftNode, leftDepth] = dfs(root.left)
        const [rightNode, rightDepth] = dfs(root.right)
        
        if (leftDepth === rightDepth)
            return [root, leftDepth + 1]
        
        if (leftDepth > rightDepth)
            return [leftNode, leftDepth + 1]
        
        return [rightNode, rightDepth + 1]
    }
    
    return dfs(root)[0]
};
```

## 103. Binary Tree Zigzag Level Order Traversal
```javascript
// Deque
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
    if (!root) return []
    
    const levels = []
    const deque = [root]
    let flag = true

    while (deque.length) {
        const size = deque.length
        const row = []

        for (let i = 0; i < size; i++) {
            const node = deque.shift()
            flag ? row.push(node.val) : row.unshift(node.val)
            
            if (node.left) deque.push(node.left)
            if (node.right) deque.push(node.right)
        }
        
        flag = !flag
        levels.push(row)
    }
    
    return levels
};

// Reverse Array
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
    if (!root) return []
    const result = []
    
    const queue = [root]
    let level = 0
    while (queue.length) {
        const size = queue.length
        const row = []
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            row.push(node.val)
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        
        if (level & 1) row.reverse()
        level++
        result.push(row)
    }
    
    return result
};
```

## 641. Design Circular Deque
```javascript
/**
 * Initialize your data structure here. Set the size of the deque to be k.
 * @param {number} k
 */
var MyCircularDeque = function(k) {
    this.capacity = k
    this.front = 0
    this.rear = 0
    this.count = 0
    this.elements = Array(k).fill(null)
};

/**
 * Adds an item at the front of Deque. Return true if the operation is successful. 
 * @param {number} value
 * @return {boolean}
 */
MyCircularDeque.prototype.insertFront = function(value) {
    if (this.isFull())
        return false
    
    this.elements[this.front] = value
    this.front = (this.front + 1) % this.capacity
    this.count++
    return true
};

/**
 * Adds an item at the rear of Deque. Return true if the operation is successful. 
 * @param {number} value
 * @return {boolean}
 */
MyCircularDeque.prototype.insertLast = function(value) {
    if (this.isFull())
        return false
    
    this.rear = (this.rear - 1 + this.capacity) % this.capacity
    this.elements[this.rear] = value
    this.count++
    return true
};

/**
 * Deletes an item from the front of Deque. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularDeque.prototype.deleteFront = function() {
    if (this.isEmpty())
        return false
    
    this.front = (this.front - 1 + this.capacity) % this.capacity
    this.count--
    return true
};

/**
 * Deletes an item from the rear of Deque. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularDeque.prototype.deleteLast = function() {
    if (this.isEmpty())
        return false
    
    this.rear = (this.rear + 1) % this.capacity
    this.count--
    return true
};

/**
 * Get the front item from the deque.
 * @return {number}
 */
MyCircularDeque.prototype.getFront = function() {
    return this.isEmpty() ? -1 : this.elements[(this.front - 1 + this.capacity) % this.capacity]
};

/**
 * Get the last item from the deque.
 * @return {number}
 */
MyCircularDeque.prototype.getRear = function() {
    return this.isEmpty() ? -1 : this.elements[this.rear]
};

/**
 * Checks whether the circular deque is empty or not.
 * @return {boolean}
 */
MyCircularDeque.prototype.isEmpty = function() {
    return this.count === 0
};

/**
 * Checks whether the circular deque is full or not.
 * @return {boolean}
 */
MyCircularDeque.prototype.isFull = function() {
    return this.count === this.capacity
};

/** 
 * Your MyCircularDeque object will be instantiated and called as such:
 * var obj = new MyCircularDeque(k)
 * var param_1 = obj.insertFront(value)
 * var param_2 = obj.insertLast(value)
 * var param_3 = obj.deleteFront()
 * var param_4 = obj.deleteLast()
 * var param_5 = obj.getFront()
 * var param_6 = obj.getRear()
 * var param_7 = obj.isEmpty()
 * var param_8 = obj.isFull()
 */
```

## 247. Strobogrammatic Number II
```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var findStrobogrammatic = function(n) {
    const _findStrobogrammatic = (low, high) => {
        if (low > high) {
            result.push(curr.join(''))
            return
        }
        
        for (const [key, value] of map) {
            if (low === 0 && key === 0 && n !== 1 || 
                low === high && key !== value) continue
            
            curr[low] = key
            curr[high] = value
            
            _findStrobogrammatic(low + 1, high - 1)
        }
    }
    
    const map = [[0, 0], [1, 1], [6, 9], [8, 8], [9, 6]]
    const result = []
    const curr = Array(n)
    _findStrobogrammatic(0, n - 1)
    return result
};
```

## 1065. Index Pairs of a String
```javascript
var indexPairs = function(text, words) {
    const trie = new Trie(words)
    const result = []
    
    for (let i = 0; i < text.length; i++) {
        let curr = trie.root
        for (let j = i; j < text.length; j++) {
            if (!curr.children[text[j]])
                break
            
            curr = curr.children[text[j]]
            if (curr.isEnd)
                result.push([i, j])
        }
    }
    
    return result
};

class Trie {
    constructor(words) {
        this.root = new TrieNode()
        
        for (const word of words)
            this.insert(word)
    }

    insert(word) {
        let curr = this.root
        for (const char of word) {
            if (!curr.children[char])
                curr.children[char] = new TrieNode(char)
            
            curr = curr.children[char]
        }
        
        curr.isEnd = true
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 105. Construct Binary Tree from Preorder and Inorder Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    const _buildTree = (left, right) => {
        if (left > right) {
            return null
        }
        
        const val = preorder[i++]
        const node = new TreeNode(val)
        
        const mid = map[val]
        node.left = _buildTree(left, mid - 1)
        node.right = _buildTree(mid + 1, right)
        return node
    }
    
    const map = {}
    for (let i = 0; i < inorder.length; i++) {
        map[inorder[i]] = i
    }
    
    let i = 0
    return _buildTree(0, preorder.length - 1)
};
```

## 106. Construct Binary Tree from Inorder and Postorder Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    const _buildTree = (left, right) => {
        if (left > right) return null
        
        const root = new TreeNode(postorder[postIndex])
        postIndex--
        
        const mid = map[root.val]
        root.right = _buildTree(mid + 1, right)
        root.left = _buildTree(left, mid - 1)
        return root
    }
    
    const map = {}
    for (let i = 0; i < inorder.length; i++) {
        map[inorder[i]] = i
    }
    
    let postIndex = postorder.length - 1
    return _buildTree(0, inorder.length - 1)
};
```

## 1008. Construct Binary Search Tree from Preorder Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
var bstFromPreorder = function(preorder) {
    const _bstFromPreorder = (leftBound, rightBound) => {
        if (i >= preorder.length) return null
        
        const val = preorder[i]
        if (leftBound >= val || rightBound <= val) return null
        
        const node = new TreeNode(val)
        i++
        
        node.left = _bstFromPreorder(leftBound, val)
        node.right = _bstFromPreorder(val, rightBound)
        return node
    }
    
    let i = 0
    return _bstFromPreorder(-Infinity, Infinity)
};
```

## 623. Add One Row to Tree
```javascript
var addOneRow = function(root, v, d) {
    if (d === 1) {
        const newRoot = new TreeNode(v)
        newRoot.left = root
        return newRoot
    }
    
    const queue = [root]
    let level = 1
    
    while (queue.length && level < d) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (level === d - 1) {
                const tempLeft = node.left
                node.left = new TreeNode(v)
                node.left.left = tempLeft
                
                const tempRight = node.right
                node.right = new TreeNode(v)
                node.right.right = tempRight
            } else {
                if (node.left) queue.push(node.left)
                if (node.right) queue.push(node.right)
            }
        }
        level++
    }
    return root
};
```

## 333. Largest BST Subtree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var largestBSTSubtree = function(root) {
    const _largestBSTSubtree = node => {
        if (!node) return [true, Infinity, -Infinity, 0]
        
        let [leftIsBST, leftMin, leftMax, leftSize] = _largestBSTSubtree(node.left)
        let [rightIsBST, rightMin, rightMax, rightSize] = _largestBSTSubtree(node.right)
        
        if (leftIsBST && rightIsBST && leftMax < node.val && node.val < rightMin) {
            result = Math.max(result, 1 + leftSize + rightSize)
            
            leftMin = leftMin === Infinity ? node.val : leftMin
            rightMax = rightMax === -Infinity ? node.val : rightMax
            
            return [true, leftMin, rightMax, 1 + leftSize + rightSize]
        }
        
        return [false, Infinity, -Infinity, 0]
    }
    
    let result = 0
    _largestBSTSubtree(root)
    return result
};
```

## 545. Boundary of Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var boundaryOfBinaryTree = function(root) {
    const result = [root.val]
    getLeftBoundary(root.left, result)
    getLeaves(root, result)
    getRightBoundary(root.right, result)
    return result
};

const getLeaves = (root, result) => {
    const _getLeaves = node => {
        if (!node) return
        
        if (root !== node && !node.left && !node.right) {
            result.push(node.val)
        }
        
        _getLeaves(node.left)
        _getLeaves(node.right)
    }
    
    _getLeaves(root)
}

const getLeftBoundary = (node, result) => {
    const _getLeftBoundary = node => {
        if (!node) return
        if (!node.left && !node.right) return
        
        result.push(node.val)
        
        if (node.left) {
            _getLeftBoundary(node.left)
        } else if (node.right) {
            _getLeftBoundary(node.right)
        }
    }
    
    _getLeftBoundary(node)
}

const getRightBoundary = (node, result) => {
    const _getRightBoundary = node => {
        if (!node) return
        if (!node.left && !node.right) return
        
        if (node.right) {
            _getRightBoundary(node.right)
        } else if (node.left) {
            _getRightBoundary(node.left)
        }
        
        result.push(node.val)
    }
    
    _getRightBoundary(node)
}
```

## 662. Maximum Width of Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var widthOfBinaryTree = function(root) {
    if (!root) return 0
    
    let maxWidth = 0
    
    const queue = [[root, 0]]
    while (queue.length) {
        const size = queue.length    
        const offset = queue[0][1]
        maxWidth = Math.max(maxWidth, queue[size - 1][1] - offset + 1)
        
        for (let i = 0; i < size; i++) {
            const [node, position] = queue.shift()
            const currPosition = position - offset
            
            if (node.left) 
                queue.push([node.left, currPosition * 2])
            if (node.right) 
                queue.push([node.right, currPosition * 2 + 1])
        }
    }
    return maxWidth
};
```

## 742. Closest Leaf in a Binary Tree
```javascript
// BFS
var findClosestLeaf = function(root, k) {
    const graph = buildGraph(root)
    const nodeK = getNode(root, k)
    const queue = [nodeK]
    const seen = new Set([nodeK.val])

    while (queue.length) {
        const next = queue.shift()
        
        if (!next.left && !next.right)
            return next.val
        
        for (const neighbor of graph[next.val]) {
            if (seen.has(neighbor.val)) continue
            seen.add(neighbor.val)
            queue.push(neighbor)
        }
    }
};

const buildGraph = root => {
    const dfs = (node, parent) => {
        if (!node) return
        
        if (parent) {
            if (!graph[node.val])
                graph[node.val] = []

            if (!graph[parent.val])
                graph[parent.val] = []
            
            graph[node.val].push(parent)
            graph[parent.val].push(node)
        }
        
        dfs(node.left, node)
        dfs(node.right, node)
    }
    
    const graph = {}
    dfs(root)
    return graph
}

const getNode = (node, k) => {
    if (!node)
        return null
    
    if (node.val === k)
        return node
    
    const left = getNode(node.left, k)
    if (left) return left
    
    const right = getNode(node.right, k)
    if (right) return right
}
```

## 297. Serialize and Deserialize Binary Tree
```javascript
// DFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    const dfs = (node) => {
        if (!node) {
            result.push('#')
            return
        }
        
        result.push(node.val)
        dfs(node.left)
        dfs(node.right)
    }
    
    const result = []
    dfs(root) 
    return result.join(',')
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    const dfs = () => {
        if (arr[i] === '#') {
            i++
            return null
        } 
        
        const node = new TreeNode(+arr[i])
        i++
        
        node.left = dfs()
        node.right = dfs()
        return node
    }
    
    const arr = data.split(',')
    let i = 0
    return dfs(0)
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */

// BFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    if (!root) return []
    
    const result = []
    const queue = [root]
    
    while (queue.length) {
        const size = queue.length
        
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (node === null) {
                result.push('x')
                continue
            }
            
            result.push(node.val)
            queue.push(node.left)
            queue.push(node.right)
        }
    }
    
    return result.join(',')
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    if (!data.length) return null
    
    let i = 0
    const nodes = data.split(',')
    const root = new TreeNode(+nodes[i++])
    const queue = [root]
    
    while (queue.length) {
        const node = queue.shift()
        
        if (nodes[i] !== 'x') {
            node.left = new TreeNode(+nodes[i])
            queue.push(node.left)
        }
        i++

        if (nodes[i] !== 'x') {
            node.right = new TreeNode(+nodes[i])
            queue.push(node.right)
        }
        i++
    } 
    
    return root
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

## 298. Binary Tree Longest Consecutive Sequence
```javascript
var longestConsecutive = function(root) {
    const _longestConsecutive = (node, curr) => {
        if (!node) return
        
        max = Math.max(max, curr)
        
        if (node.left && node.left.val === node.val + 1) {
            _longestConsecutive(node.left, curr + 1)
        } else {
            _longestConsecutive(node.left, 1)
        }
        
        if (node.right && node.right.val === node.val + 1) {
            _longestConsecutive(node.right, curr + 1)
        } else {
            _longestConsecutive(node.right, 1)
        }        
    }
    
    let max = 0
    _longestConsecutive(root, 1)
    return max
};
```

## 428. Serialize and Deserialize N-ary Tree
```javascript
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

class Codec {
  	constructor() {
        
    }
  
    /** 
     * @param {Node} root
     * @return {string}
     */
    // Encodes a tree to a single string.
    serialize = function(root) {
        const _serialize = root => {
            if (!root) return
            
            result.push(root.val)
            result.push(root.children.length)
            
            for (const child of root.children) {
                _serialize(child)
            }
        }
        
        const result = []
        _serialize(root)
        return result.join(',')
    };

    /** 
     * @param {string} data 
     * @return {Node}
     */
    // Decodes your encoded data to tree.
    deserialize = function(data) {
        const _deserialize = () => {
            if (i >= nodes.length)
                return null
            
            const val = nodes[i++]
            const childCount = nodes[i++]
            
            const node = new Node(val)
            node.children = []
            for (let j = 0; j < childCount; j++) {
                node.children.push(_deserialize())
            }
            
            return node
        }
        
        const nodes = data.split(',')
        let i = 0
        return _deserialize()
    };

}
// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

## 449. Serialize and Deserialize BST
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    const preOrder = root => {
        if (!root) return
        
        result.push(root.val)
        preOrder(root.left)
        preOrder(root.right)
    }
    
    const result = []
    preOrder(root)
    return result
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    const _deserialize = (low, high) => {
        if (i >= data.length) return null
        
        const val = data[i]
        if (val < low || val > high)
            return null
        
        i++
        const node = new TreeNode(val)
        node.left = _deserialize(low, val)
        node.right = _deserialize(val, high)
        return node
    }
    
    let i = 0
    return _deserialize(-Number.MAX_VALUE, Number.MAX_VALUE)
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

## 652. Find Duplicate Subtrees
```javascript
// O(n^2)
var findDuplicateSubtrees = function(root) {
    const dfs = root => {
        if (!root) return '#'
        
        const temp = `${root.val}` + dfs(root.left) + dfs(root.right)
        
        map[temp] = 1 + (map[temp] || 0)
        
        if (map[temp] === 2)
            result.push(root)
        
        return temp
    }
    
    const result = []
    const map = {}
    dfs(root)
    
    return result
};

// O(n)
var findDuplicateSubtrees = function(root) {
    const dfs = root => {
        if (!root) return 0
        
        const serial = root.val + ',' + dfs(root.left) + ',' + dfs(root.right)
        
        if (!trees[serial]) trees[serial] = id++
        const uid = trees[serial]
        
        counts[uid] = 1 + (counts[uid] || 0)
        if (counts[uid] === 2)
            result.push(root)
        
        return uid
    }
    
    const trees = {}
    const counts = {}
    const result = []
    let id = 1
    
    dfs(root)
    return result
};
```

## 1245. Tree Diameter
```javascript
// DFS
var treeDiameter = function(edges) {
    const graph = buildGraph(edges)
    const [, endNode] = longestPath(graph, 0)
    const [length, ] = longestPath(graph, endNode)
    return length
};

const longestPath = (graph, startNode) => {
    const _longestPath = (vertex, parent, length) => {
        if (length > maxLength) {
            maxLength = length
            endNode = vertex
        }
        
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                if (neighbor === parent) continue
                _longestPath(neighbor, vertex, length + 1)
            }
        }
    }
    
    let maxLength = 0
    let endNode = null
    _longestPath(startNode, null, 0)
    return [maxLength, endNode]
}

const buildGraph = edges => {
    const graph = {}
    
    for (const [v1, v2] of edges) {
        if (!graph[v1]) graph[v1] = []
        if (!graph[v2]) graph[v2] = []
        
        graph[v1].push(v2)
        graph[v2].push(v1)
    }
    
    return graph
}

// BFS
/**
 * @param {number[][]} edges
 * @return {number}
 */
var treeDiameter = function(edges) {
    const graph = buildGraph(edges)
    let queue = []
    getLeaves(graph, queue)
    
    let level = 0
    while (queue.length) {
        const nextQueue = []
        const visited = new Set()
        for (const [node, parent] of queue) {
            for (const neighbor of graph[node]) {
                if (neighbor === parent || visited.has(`${neighbor}-${node}`)) continue
                visited.add(`${neighbor}-${node}`)
                nextQueue.push([neighbor, node])
            }
        }
        
        queue = nextQueue
        level++
    }
    
    return Math.max(level - 1, 0)
};

const getLeaves = (graph, queue) => {
    for (let i = 0; i < graph.length; i++) {
        if (graph[i].length === 1) {
            queue.push([i, null])
        }
    }
}

const buildGraph = edges => {
    const graph = Array(edges.length + 1).fill().map(a => [])
    
    for (const [u, v] of edges) {
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}
```

## 1100. Find K-Length Substrings With No Repeated Characters
```javascript
var numKLenSubstrNoRepeats = function(S, K) {
    if (S.length < K) return 0
    
    const seen = new Set()
    let count = 0
    let left = 0
    let right = 0
    
    while (right < S.length) {
        while (seen.has(S[right]))
            seen.delete(S[left++])

        seen.add(S[right])
        
        if (right - left + 1 === K) {
            count++
            seen.delete(S[left++])
        }
        
        right++
    }
    
    return count
};
```

## 487. Max Consecutive Ones II
```javascript
// Sliding Window
var findMaxConsecutiveOnes = function(nums) {
    let length = 0
    let zeroCount = 0
    let left = 0
    let right = 0
    
    while (right < nums.length) {
        if (nums[right] === 0)
            zeroCount++
        
        if (zeroCount === 2) {
            length = Math.max(length, right - left)

            while (zeroCount === 2) {
                if (nums[left] === 0)
                    zeroCount--
                
                left++
            }
        }
        
        right++
    }
    
    length = Math.max(length, right - left)
    return length
};

// Follow Up
var findMaxConsecutiveOnes = function(nums) {
    let length = 0
    let lastZeroIndex = null
    let left = 0
    let right = 0
    
    while (right < nums.length) {
        if (nums[right] === 0) {
            if (lastZeroIndex !== null) {
                length = Math.max(right - left, length)
                left = lastZeroIndex + 1                
            }
            lastZeroIndex = right
        }
        
        right++
    }
    
    length = Math.max(right - left, length)
    return length
};
```

## 1004. Max Consecutive Ones III
```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var longestOnes = function(A, K) {
    let maxLen = 0
    let zeroCount = 0
    let left = 0
    for (let right = 0; right < A.length; right++) {
        if (A[right] === 0) {
            zeroCount++
        }
        
        while (zeroCount > K) {
            if (A[left] === 0) {
                zeroCount--
            }
            
            left++
        }
        
        maxLen = Math.max(maxLen, right - left + 1)
    }
    
    return maxLen
};
```

## 76. Minimum Window Substring
```javascript
var minWindow = function(s, t) {
    if (t.length > s.length || s.length === 0 || t.length === 0) return ''

    const map = {}
    for (const char of t)
      map[char] = 1 + (map[char] || 0)

    let minLength = -1
    let start = 0
    let end = 0

    let count = t.length
    let left = 0
    for (let right = 0; right < s.length; right++) {
        const char = s[right]
        
        if(map[char]-- > 0)
            count--
        
        while (count === 0) {
            if (minLength === -1 || right - left < minLength) {
                minLength = right - left
                start = left
                end = right
            }
            
            const char = s[left++]
            if (map[char]++ === 0)
                count++
        }
    }
    
    return minLength === -1 ? '' : s.slice(start, end + 1)
};
```

## 995. Minimum Number of K Consecutive Bit Flips
```javascript
// O(nk)
// O(1)
var minKBitFlips = function(A, K) {
    let count = 0
    for (let i = 0; i < A.length; i++) {
        if (!A[i]) {
            if (i + K - 1 >= A.length) 
                return -1
            
            for (let j = i; j < i + K; j++)
                A[j] ^= 1
            
            count++
        }
    }
    
    return count
};
```

## 424. Longest Repeating Character Replacement
```javascript
var characterReplacement = function(s, k) {
    const charCounts = {}
    let maxLength = 0
    let maxCount = 0
    let left = 0
    let right = 0
    
    while (right < s.length) {
        const char = s[right]
        
        if (!charCounts[char])
            charCounts[char] = 0
        
        charCounts[char]++
        maxCount = Math.max(maxCount, charCounts[char])
        
        if (right - left + 1 - maxCount > k) {
            const leftChar = s[left]
            charCounts[leftChar]--
            left++
        }
        maxLength = Math.max(maxLength, right - left + 1)
        right++
    }
    
    return maxLength
};
```

## 1151. Minimum Swaps to Group All 1's Together
```javascript
var minSwaps = function(data) {
    let windowSize = 0
    for (const num of data)
        if (num) windowSize++
    
    let numOfZeros = 0
    for (let i = 0; i < windowSize; i++)
        if (!data[i]) numOfZeros++
    
    let minSwaps = numOfZeros
    for (let i = windowSize; i < data.length; i++) {
        if (!data[i - windowSize]) numOfZeros--
        if (!data[i]) numOfZeros++
        minSwaps = Math.min(minSwaps, numOfZeros)
    }
    
    return minSwaps
};
```

## 567. Permutation in String
```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
    if (s1.length > s2.length) return false
    
    const count1 = new Array(26).fill(0)
    for (const char of s1) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        count1[index]++
    }
    
    const count2 = new Array(26).fill(0)
    let left = 0
    for (let right = 0; right < s2.length; right++) {
        const index = s2[right].charCodeAt(0) - 'a'.charCodeAt(0)
        count2[index]++
        
        if (right - left + 1 < s1.length) continue
        
        if (isEqual(count1, count2)) return true
        
        const leftIndex = s2[left].charCodeAt(0) - 'a'.charCodeAt(0)
        count2[leftIndex]--
        left++
    }
    
    return false
};

const isEqual = (arr1, arr2) => {
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) return false
    }
    return true
}
```

## 1078. Occurrences After Bigram
```javascript
var findOcurrences = function(text, first, second) {
    const words = text.split(' ')
    const result = []
    
    for (let i = 0; i < words.length - 2; i++) {
        if (words[i] === first && words[i + 1] === second) {
            result.push(words[i + 2])
        }
    }
    
    return result
};
```

## 438. Find All Anagrams in a String
```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function(s, p) {
    if (s.length < p.length) return []
    
    const result = []
    
    const pCount = new Array(26).fill(0)
    for (const char of p) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        pCount[index]++
    }
    
    const sCount = new Array(26).fill(0)
    let left = 0
    for (let right = 0; right < s.length; right++) {
        const rightCharIndex = indexForChar(s[right])
        sCount[rightCharIndex]++
        
        while (sCount[rightCharIndex] > pCount[rightCharIndex]) {
            const leftCharIndex = indexForChar(s[left])
            sCount[leftCharIndex]--
            left++
        }
        
        if (equal(sCount, pCount)) {
            result.push(left)
        }    
    }
    
    return result
};

const equal = (arr1, arr2) => {
    if (arr1.length !== arr2.length) {
        return false
    }
    
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false
        }
    }
    return true
}

const indexForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
```

## 1052. Grumpy Bookstore Owner
```javascript
var maxSatisfied = function(customers, grumpy, X) {
    let s = 0
    for (let i = 0; i < grumpy.length; i++) {
        if (grumpy[i] === 0) {
            s += customers[i]
            customers[i] = 0
        }
    }
    
    let maxS = 0
    let currS = 0
    
    for (let i = 0; i < customers.length; i++) {
        currS += customers[i]
        if (i >= X) currS -= customers[i - X]
        maxS = Math.max(maxS, currS)
    }
    
    return s + maxS
};
```

## 1208. Get Equal Substrings Within Budget
```javascript
var equalSubstring = function(s, t, maxCost) {
    let maxLength = 0
    let left = 0
    for (let right = 0; right < s.length; right++) {
        maxCost -= distance(t[right], s[right])
        
        while (maxCost < 0) {
            maxCost += distance(t[left], s[left])
            left++
        }
        
        maxLength = Math.max(maxLength, right - left + 1)
    }
    
    return maxLength
};

const distance = (char1, char2) => Math.abs(char1.charCodeAt(0) - char2.charCodeAt(0))
```

## 295. Find Median from Data Stream
```javascript
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
    this.highers = new Heap([], (a, b) => a < b)
    this.lowers = new Heap([], (a, b) => a > b)
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    if (this.lowers.length() === 0 || num < this.lowers.peek()) {
        this.lowers.insert(num)
    } else {
        this.highers.insert(num)
    }
    
    this.rebalanceHeaps()
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    const biggerHeap = this.highers.length() < this.lowers.length() ? this.lowers : this.highers
    const smallerHeap = this.highers.length() < this.lowers.length() ? this.highers : this.lowers

    if (biggerHeap.length() === smallerHeap.length()) {
        return (biggerHeap.peek() + smallerHeap.peek()) / 2
    } else {
        return biggerHeap.peek()
    }
        
};

/** 
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

MedianFinder.prototype.rebalanceHeaps = function() {
    const biggerHeap = this.highers.length() < this.lowers.length() ? this.lowers : this.highers
    const smallerHeap = this.highers.length() < this.lowers.length() ? this.highers : this.lowers

    if (biggerHeap.length() - smallerHeap.length() >= 2) {
        smallerHeap.insert(biggerHeap.remove())
    }
} 

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 239. Sliding Window Maximum
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    if (!nums.length) return []
    
    const result = []
    const deque = []
    
    for (let i = 0; i < nums.length; i++) {
        while (deque.length && deque[0] < i - k + 1) 
            deque.shift()
        
        while (deque.length && nums[deque[deque.length - 1]] < nums[i])
            deque.pop()
        
        deque.push(i)
        
        if (i >= k - 1) 
            result.push(nums[deque[0]])
    }
    
    return result
};
```

## 995. Minimum Number of K Consecutive Bit Flips
```javascript
var minKBitFlips = function(A, K) {
    let count = 0
    const queue = []
    
    for (let i = 0; i < A.length; i++) {
        if (A[i] !== queue.length % 2 ? 0 : 1) {
            count++
            queue.push(i + K - 1)
        }
        
        if (queue.length && queue[0] <= i)
            queue.shift()
    }
    
    return queue.length ? -1 : count
};
```

## 1306. Jump Game III
```javascript
// BFS
var canReach = function(arr, start) {
    const visited = new Set()
    const queue = [start]
    
    while (queue.length) {
        const next = queue.shift()
        
        if (arr[next] === 0)
            return true
        
        visited.add(next)
        
        const left = next - arr[next] 
        if (!visited.has(left) && left < arr.length)
            queue.push(left)
        
        const right = next + arr[next]
        if (!visited.has(right) && right >= 0)
            queue.push(right)
    }
    return false
};

// DFS
var canReach = function(arr, start) {
    const _canReach = i => {
        if (i < 0 || i >= arr.length || visited.has(i))
            return false
        
        visited.add(i)
        return arr[i] === 0 || _canReach(i + arr[i]) || _canReach(i - arr[i])
    }
    
    const visited = new Set()
    return _canReach(start)
};
```

## 752. Open the Lock
```javascript
// Bidirectional BFS
/**
 * @param {string[]} deadends
 * @param {string} target
 * @return {number}
 */
var openLock = function(deadends, target) {
    const deadendsSet = new Set(deadends)
    
    const start = '0000'
    const startQueue = [start]
    const startSet = new Set([start])
    let startSteps = 0
    
    const endQueue = [target]
    const endSet = new Set([target])
    let endSteps = 0
    
    if (deadendsSet.has(start) || deadendsSet.has(target)) {
        return -1
    }
    
    while (startQueue.length && endQueue.length) {
        if (bfs(startQueue, startSet, endSet, deadendsSet)) {
            return startSteps + endSteps
        }
        startSteps++
        
        if (bfs(endQueue, endSet, startSet, deadendsSet)) {
            return startSteps + endSteps
        }
        endSteps++
    }
    
    return -1
};

const bfs = (queue1, visited1, visited2, invalidSet) => {
    const size = queue1.length
    for (let i = 0; i < size; i++) {
        const node = queue1.shift()
        
        if (visited2.has(node)) {
            return true
        }
        
        for (const neighbor of getNeighbors(node)) {
            if (invalidSet.has(neighbor) || visited1.has(neighbor)) continue
            visited1.add(neighbor)
            queue1.push(neighbor)
        }
    }
    
    return false
}

const getNeighbors = node => {
    const neighbors = []
    
    const charArr = node.split('')
    for (let i = 0; i < node.length; i++) {
        const digit = +charArr[i]
        
        // get left turn
        let left = digit - 1
        if (left < 0) {
            left = 9
        }
        charArr[i] = left
        neighbors.push(charArr.join(''))
        
        // get right turn
        const right = (digit + 1) % 10
        charArr[i] = right
        neighbors.push(charArr.join(''))
        
        charArr[i] = node[i]
    }
    
    return neighbors
}

// A*
/**
 * @param {string[]} deadends
 * @param {string} target
 * @return {number}
 */
var openLock = function(deadends, target) {
    const queue = new Heap([[[0, 0, 0, 0], 0, heuristic('0000', target)]], (a, b) => {
        const [, aTurns, aHeuristic] = a
        const [, bTurns, bHeuristic] = b
        return aTurns + aHeuristic < bTurns + bHeuristic
    })
    
    const visited = new Set(deadends)
    while (queue.length()) {
        const [combo, turns] = queue.remove()
        
        const comboStr = combo.join('')
        if (comboStr === target) return turns
        
        if (visited.has(comboStr)) continue
        visited.add(comboStr)

        const neighbors = []
        for (let i = 0; i < combo.length; i++) {
            const nextCombo = combo.slice()
            const num = combo[i]
            nextCombo[i] = ((num + 1) % 10)
            queue.insert([nextCombo.slice(), 
                          turns + 1, 
                          heuristic(nextCombo, target)])

            nextCombo[i] = num === 0 ? 9 : num - 1
            queue.insert([nextCombo.slice(), 
                          turns + 1, 
                          heuristic(nextCombo, target)])
        }
    }
    
    return -1
};

const heuristic = (combo, target) => {
    let distance = 0
    for (let i = 0; i < combo.length; i++) {
        const max = Math.max(target[i], combo[i])
        const min = Math.min(target[i], combo[i])
        distance += Math.min(max - min, min + 10 - max)
    }
    return distance
}

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 934. Shortest Bridge
```javascript
/**
 * @param {number[][]} A
 * @return {number}
 */
var shortestBridge = function(A) {
    const rowLen = A.length
    const colLen = A[0].length
    
    const queue = []
    outer: for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (A[row][col] === 1) {
                floodFill(A, row, col)
                break outer
            }
        }
    }
    
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (A[row][col] === 2) {
                queue.push([row, col])
            }
        }
    }
    
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    let steps = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()
            
            for (const [deltaRow, deltaCol] of dirs) {
                const nextRow = deltaRow + row
                const nextCol = deltaCol + col

                if (nextRow < 0 || nextRow >= rowLen || 
                    nextCol < 0 || nextCol >= colLen || 
                    A[nextRow][nextCol] === 2) continue
                
                if (A[nextRow][nextCol] === 1) {
                    return steps
                }
                
                A[nextRow][nextCol] = 2
                queue.push([nextRow, nextCol])
            }   
        }
        steps++
    }
};

const floodFill = (matrix, startRow, startCol) => {
    const rowLen = matrix.length
    const colLen = matrix[0].length
    
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    
    const queue = [[startRow, startCol]]
    matrix[startRow][startCol] = 2
    
    while (queue.length) {
        const [row, col] = queue.shift()
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen || 
                matrix[nextRow][nextCol] !== 1) continue
            
            matrix[nextRow][nextCol] = 2
            queue.push([nextRow, nextCol])
        }
    }
}
```

## 1236. Web Crawler
```javascript
/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * function HtmlParser() {
 *
 *		@param {string} url
 *     	@return {string[]}
 *     	this.getUrls = function(url) {
 *      	...
 *     	};
 * };
 */

/**
 * @param {string} startUrl
 * @param {HtmlParser} htmlParser
 * @return {string[]}
*/
var crawl = function(startUrl, htmlParser) {
    const hostname = getHostname(startUrl)
    const queue = [startUrl]
    const result = []
    const visited = new Set([startUrl])
    
    while (queue.length) {
        const url = queue.shift()
        
        result.push(url)
        
        for (const neighbor of htmlParser.getUrls(url)) {
            if (visited.has(neighbor)) continue
            visited.add(neighbor)
            
            const neighborHostname = getHostname(neighbor)
            if (neighborHostname === hostname) queue.push(neighbor)
        }
    }
    
    return result
};

const getHostname = str => {
    const url = new URL(str)
    return url.hostname
}
```

## 1311. Get Watched Videos by Your Friends
```javascript
/**
 * @param {string[][]} watchedVideos
 * @param {number[][]} friends
 * @param {number} id
 * @param {number} level
 * @return {string[]}
 */
var watchedVideosByFriends = function(watchedVideos, friends, id, level) {
    const counts = {}
    
    const queue = [id]
    const visited = new Set([id])
    let dist = 0
    while (queue.length && dist <= level) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (dist === level) {
                for (const video of watchedVideos[node]) {
                    counts[video] = 1 + (counts[video] || 0)
                }
            }
            
            for (const neighbor of friends[node]) {
                if (visited.has(neighbor)) continue
                visited.add(neighbor)
                queue.push(neighbor)
            }
        }
        dist++
    }
    
    return Object.keys(counts).sort((a, b) => {
        if (counts[a] === counts[b]) {
            return a.localeCompare(b)
        }
        return counts[a] - counts[b]
    })
};
```

## 785. Is Graph Bipartite?
```javascript
// BFS
var isBipartite = function(graph) {
    const color = {}
    for (let node = 0; node < graph.length; node++) {
        if (color[node]) continue
        
        color[node] = 0
        const queue = [node]
        
        while (queue.length) {
            const vertex = queue.shift()

            for (const neighbor of graph[vertex]) {
                if (!color[neighbor]) {
                    color[neighbor] = 1 - color[vertex]
                    queue.push(neighbor)
                    continue
                }
                
                if (color[neighbor] === color[vertex])
                    return false
            }
        }
    }
    return true
};

// DFS Iterative
var isBipartite = function(graph) {
    const color = {}
    for (let node = 0; node < graph.length; node++) {
        if (color[node]) continue
        
        color[node] = 0
        const stack = [node]
        
        while (stack.length) {
            const vertex = stack.pop()

            for (const neighbor of graph[vertex]) {
                if (!color[neighbor]) {
                    color[neighbor] = 1 - color[vertex]
                    stack.push(neighbor)
                    continue
                }
                
                if (color[neighbor] === color[vertex])
                    return false
            }
        }
    }
    return true
};

// DFS Recursive
/**
 * @param {number[][]} graph
 * @return {boolean}
 */
var isBipartite = function(graph) {
    const colorGraph = (node, color) => {
        colors[node] = color
        
        for (const neighbor of graph[node]) {
            if (colors[neighbor] === color) {
                return false
            }
            
            if (colors[neighbor] !== undefined) {
                continue
            }
            
            if (!colorGraph(neighbor, color ^ 1)) {
                return false
            }
        }
        
        return true
    }
    
    const n = graph.length
    const colors = new Array(n)
    for (let node = 0; node < n; node++) {
        if (colors[node] !== undefined) continue
        if (!colorGraph(node, 0)) {
            return false
        }
    }
    
    return true
};
```

## 1162. As Far from Land as Possible
```javascript
var maxDistance = function(grid) {
    const queue = []
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 1) {
                queue.push([row, col])
            }
        }
    }
    
    let dist = 0
    while (queue.length) {
        dist++
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()
            
            for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                const nextRow = row + dx
                const nextCol = col + dy
                
                if (nextRow < 0 || nextCol < 0 || 
                    nextRow >= grid.length || nextCol >= grid[0].length || 
                    grid[nextRow][nextCol] !== 0) continue
                
                queue.push([nextRow, nextCol])
                grid[nextRow][nextCol] = dist
            }
        }
    }
    
    return dist === 1 ? -1 : dist - 1
};
```

## 1091. Shortest Path in Binary Matrix
```javascript
// BFS
var shortestPathBinaryMatrix = function(grid) {
    const queue = [[0, 0]]
    const destination = [grid.length - 1, grid[0].length - 1]
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]
    
    let dist = 1
    while (queue.length) {
        const size = queue.length
        
        for (let i = 0; i < size; i++) {
            const [x, y] = queue.shift()

            if (x === destination[0] && y === destination[1])
                return dist
            
            if (grid[x][y] === 1) continue
            grid[x][y] = 1
            
            for (const [dx, dy] of dirs) {
                const nx = dx + x
                const ny = dy + y
                
                if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || grid[nx][ny] === 1)
                    continue
                
                queue.push([nx, ny])
            }
        }
        dist++
    }
    
    return -1
};

// A*
/**
 * @param {number[][]} grid
 * @return {number}
 */
var shortestPathBinaryMatrix = function(grid) {
    if (grid[0][0] === 1) return -1
    
    const rowLen = grid.length
    const colLen = grid[0].length
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1], [-1, -1], [1, 1], [-1, 1], [1, -1]]
    
    const queue = new Heap([[0, 0, 1, heuristic(0, 0, rowLen - 1, colLen - 1)]], (a, b) => {
        const [, , aDist, aHeuristic] = a
        const [, , bDist, bHeuristic] = b
        const aF = aDist + aHeuristic
        const bF = bDist + bHeuristic
        return aF < bF
    })
    
    const dists = Array(rowLen).fill().map(a => Array(colLen).fill(Infinity))
    while (queue.length()) {
        const size = queue.length()
        for (let i = 0; i < size; i++) {
            const [row, col, dist] = queue.remove()
            
            if (row === rowLen - 1 && col === colLen - 1) {
                return dist
            }
            
            if (dists[row][col] <= dist) continue
            dists[row][col] = dist
            
            for (const [dRow, dCol] of dirs) {
                const nextRow = dRow + row
                const nextCol = dCol + col
                
                if (nextRow < 0 || nextRow >= rowLen || 
                    nextCol < 0 || nextCol >= colLen ||
                   grid[nextRow][nextCol] === 1) continue
                
                queue.insert([nextRow, 
                              nextCol, 
                              dist + 1, 
                              heuristic(nextRow, nextCol, rowLen - 1, colLen - 1)])
            }
        }
    }
    
    return -1
};

const heuristic = (x1, y1, x2, y2) => {
    return Math.max(x2 - x1, y2 - y1)
}

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 127. Word Ladder
```javascript
// BFS
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
    const wordSet = new Set(wordList)
    const queue = [beginWord]
    const alphabet = 'abcdefghijklmnopqrstuvwxyz'
    let dist = 1
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const word = queue.shift()
            
            if (word === endWord) 
                return dist
            
            for (let j = 0; j < word.length; j++) {
                for (const letter of alphabet) {
                    if (word[j] === letter) continue
                    const nextWord = word.slice(0, j) + letter + word.slice(j + 1)
                    
                    if (wordSet.has(nextWord)) {
                        queue.push(nextWord)
                        wordSet.delete(nextWord)
                    }
                }
            }
        }
        
        dist++
    }
    
    return 0
};

// Bidirectional BFS
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
    const words = new Set(wordList)
    if (!words.has(endWord)) return 0
    
    let beginSet = new Set([beginWord])
    let endSet = new Set([endWord])
    
    let level = 1
    
    while (beginSet.size && endSet.size) {
        if (beginSet.size > endSet.size) {
            const temp = beginSet
            beginSet = endSet
            endSet = temp
        }
        
        level++
        if (bfs(beginSet, endSet, words)) {
            return level
        }
    }
    
    return 0
};

const bfs = (beginSet, endSet, words) => {
    const getNeighbors = word => {
        const neighbors = []
        for (let i = 0; i < word.length; i++) {
            for (let code = 'a'.charCodeAt(0); code <= 'z'.charCodeAt(0); code++) {
                const char = String.fromCharCode(code)
                if (word[i] === char) continue
                
                const nextWord = word.slice(0, i) + char + word.slice(i + 1)
                neighbors.push(nextWord)
            }
        }
        return neighbors
    }
    
    const neighborSet = new Set()
    for (const node of beginSet) {    
        for (const neighbor of getNeighbors(node)) {
            if (endSet.has(neighbor)) return true
            
            if (!words.has(neighbor)) continue
            words.delete(neighbor)
            neighborSet.add(neighbor)
        }
    }
    
    beginSet.clear()
    for (const word of neighborSet) {
        beginSet.add(word)
    }
    
    return false
}
```

## 1197. Minimum Knight Moves
```javascript
// BFS
var minKnightMoves = function(x, y) {
    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]
    const queue = [[0, 0]]
    const visited = new Set()
    let dist = 0
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()
            
            if (row === x && col === y)
                return dist
            
            for (const [dx, dy] of dirs) {
                const nx = row + dx
                const ny = col + dy
                const key = `${nx}-${ny}`
                
                if (Math.abs(nx) + Math.abs(ny) > 300) continue
                
                if (visited.has(key)) continue
                visited.add(key)
                
                queue.push([nx, ny])
            }
        }
        dist++
    }
};

// Bidirectional BFS
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var minKnightMoves = function(x, y) {
    const startQueue = [[0, 0]]
    const endQueue = [[x, y]]
    
    const startVisited = new Set([`0-0`])
    const endVisited = new Set([`${x}-${y}`])
    
    let startSteps = 0
    let endSteps = 0
    
    while (true) {
        let isFound = bfs(startQueue, startVisited, endVisited)
        if (isFound) return startSteps + endSteps
        startSteps++
        
        isFound = bfs(endQueue, endVisited, startVisited)
        if (isFound) return startSteps + endSteps
        endSteps++
    }
};

const bfs = (queue, visited1, visited2) => {
    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]
    const size = queue.length
    for (let i = 0; i < size; i++) {
        const [row, col] = queue.shift()
        
        if (visited2.has(`${row}-${col}`)) 
            return true
        
        for (const [dx, dy] of dirs) {
            const nx = row + dx
            const ny = col + dy
            const key = `${nx}-${ny}`
            
            if (visited1.has(key)) continue
            visited1.add(key)
            
            queue.push([nx, ny])
        }
    }
    
    return false
}

// A*
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var minKnightMoves = function(x, y) {
    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]
    
    const visited = new Set(['0-0'])
    const queue = new Heap([[0, 0, 0, 0, heuristic(0, 0, x, y)]], (a, b) => {
        const [aRow, aCol, aMoves, aSteps, aPriority] = a
        const [bRow, bCol, bMoves, bSteps, bPriority] = b
        return aPriority < bPriority
    })
    
    while (queue.length()) {
        const size = queue.length()
        for (let i = 0; i < size; i++) {
            const [row, col, moves, steps, priority] = queue.remove()

            if (row === x && col === y) {
                return moves
            }

            for (const [dRow, dCol] of dirs) {
                const nextRow = dRow + row
                const nextCol = dCol + col

                if (visited.has(`${nextRow}-${nextCol}`)) continue
                visited.add(`${nextRow}-${nextCol}`)
                
                const gn = steps + 3
                const hn = heuristic(nextRow, nextCol, x, y)
                const fn = gn + hn
                queue.insert([nextRow, nextCol, moves + 1, gn, fn])
            }
        }
    }
};

const heuristic = (x1, y1, x2, y2) => {
    return Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2)
}

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 909. Snakes and Ladders
```javascript
var snakesAndLadders = function(board) {
    const n = board.length    
    const lastPos = n * n - 1
    
    const arr = []
    let reverse = true
    let currRow = n - 1
    let currCol = 0    
    for (let index = 0; index < n * n; index++) {
        arr[index] = board[currRow][currCol]
        
        if (reverse && currCol === n - 1) {
            reverse = false
            currRow--
            continue
        }
        
        if (!reverse && !currCol) {
            reverse = true
            currRow--
            continue
        }
        
        reverse ? currCol++ : currCol--
    }
    
    const visited = Array(n * n).fill(false)
    const startPos = arr[0] > -1 ? arr[0] - 1 : 0
    const queue = [[startPos, 0]]
    visited[startPos] = true
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [pos, steps] = queue.shift()
            if (pos === lastPos)
                return steps
            
            for (let nextPos = pos + 1; nextPos <= Math.min(pos + 6, lastPos); nextPos++) {
                const endingPos = arr[nextPos] > -1 ? arr[nextPos] - 1 : nextPos
                if (visited[endingPos]) continue
                visited[endingPos] = true
                queue.push([endingPos, steps + 1])
            }
        }
    }
    return -1
};
```

## 542. 01 Matrix
```javascript
// BFS
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const rowLen = matrix.length
    const colLen = matrix[0].length
    
    const visited = Array(rowLen).fill().map(a => Array(colLen).fill(0))
    const queue = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (matrix[row][col] === 0) {
                visited[row][col] = 1
                queue.push([row, col])
            }
        }
    }
    
    let dist = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()
            matrix[row][col] = dist
            
            for (const [dRow, dCol] of dirs) {
                const nextRow = row + dRow
                const nextCol = col + dCol
                
                if (nextRow < 0 || nextRow >= rowLen ||
                    nextCol < 0 || nextCol >= colLen || 
                    visited[nextRow][nextCol] === 1) continue
                
                visited[nextRow][nextCol] = 1
                queue.push([nextRow, nextCol])
            }
        }
        dist++
    }
    
    return matrix
};

// DP
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
    const rowLen = matrix.length
    const colLen = matrix[0].length
    
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (matrix[row][col] === 0) continue
            
            let min = Infinity
            for (const [dRow, dCol] of [[-1, 0], [0, -1]]) {
                const nextRow = row + dRow
                const nextCol = col + dCol
                
                if (nextRow < 0 || nextCol < 0) continue
                min = Math.min(min, matrix[nextRow][nextCol])
            }
            matrix[row][col] = 1 + min
        }
    }
    
    for (let row = rowLen - 1; row >= 0; row--) {
        for (let col = colLen - 1; col >= 0; col--) {
            if (matrix[row][col] === 0) continue
            
            let min = Infinity
            for (const [dRow, dCol] of [[1, 0], [0, 1]]) {
                const nextRow = row + dRow
                const nextCol = col + dCol
                
                if (nextRow >= rowLen || nextCol >= colLen) continue
                min = Math.min(min, matrix[nextRow][nextCol])
            }
            matrix[row][col] = Math.min(matrix[row][col], 1 + min)
        }
    }
    
    return matrix
};
```

## 310. Minimum Height Trees
```javascript
// TopSort BFS
var findMinHeightTrees = function(n, edges) {
    if (n <= 1) return [0]
    
    const graph = {}
    
    for (const [u, v] of edges) {
        if (!graph[u]) graph[u] = new Set()
        if (!graph[v]) graph[v] = new Set()
        graph[u].add(v)
        graph[v].add(u)
    }
    
    const leaves = []
    const pairs = Object.entries(graph)
    for (const [vertex, neighbors] of pairs) {
        if (neighbors.size === 1) {
            leaves.push(vertex)
        }
    }
    
    let count = n
    while (count > 2) {
        const size = leaves.length
        count -= size
        for (let i = 0; i < size; i++) {
            const vertex = leaves.shift()
            
            if (!graph[vertex]) continue
            for (const neighbor of graph[vertex]) {
                graph[neighbor].delete(+vertex)

                if (graph[neighbor].size === 1) {
                    leaves.push(neighbor)
                }
            }
        }
    }
    
    return leaves
};

// DFS 
var findMinHeightTrees = function(n, edges) {
    if (n <= 1) return [0]
    
    const graph = {}
    
    for (const [u, v] of edges) {
        if (!graph[u]) graph[u] = new Set()
        if (!graph[v]) graph[v] = new Set()
        graph[u].add(v)
        graph[v].add(u)
    }
    
    const x = maxPath(0, graph)[0]
    const path = maxPath(x, graph)
    
    if (path.length % 2 === 0) {
        return [path[Math.floor(path.length / 2) - 1], path[Math.floor(path.length / 2)]]
    } else {
        return [path[Math.floor(path.length / 2)]]
    }
};

const maxPath = (vertex, graph) => {
    const _maxPath = vertex => {
        visited.add(vertex)
        
        if (!graph[vertex]) return []
        
        const paths = []
        for (const neighbor of graph[vertex]) {
            if (visited.has(neighbor)) continue
            paths.push(_maxPath(neighbor))
        }

        let maxPath = []
        for (const path of paths) {
            if (maxPath.length < path.length) {
                maxPath = path   
            }
        }
        
        maxPath.push(vertex)
        return maxPath
    }
    
    const visited = new Set([vertex])
    return _maxPath(vertex)
}
```

## 490. The Maze
```javascript
// BFS
/**
 * @param {number[][]} maze
 * @param {number[]} start
 * @param {number[]} destination
 * @return {boolean}
 */
var hasPath = function(maze, start, destination) {
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    
    const queue = [start]
    const visited = new Set(`${start[0]}-${start[1]}`)
    
    while (queue.length) {
        const [row, col] = queue.shift()
        
        if (row === destination[0] && col === destination[1]) {
            return true
        }
        
        for (const [deltaRow, deltaCol] of dirs) {
            let nextRow = row
            let nextCol = col
            
            while (isValid(maze, nextRow, nextCol)) {
                nextRow += deltaRow
                nextCol += deltaCol
            }
            
            nextRow -= deltaRow
            nextCol -= deltaCol
            
            if (visited.has(`${nextRow}-${nextCol}`)) continue
            visited.add(`${nextRow}-${nextCol}`)
            
            queue.push([nextRow, nextCol])
        }
    }
    
    return false
};

const isValid = (maze, row, col) => {
    if (row < 0 || row >= maze.length || 
        col < 0 || col >= maze[0].length || 
        maze[row][col] === 1) return false
    return true
}

// DFS
var hasPath = function(maze, start, destination) {
    const _hasPath = (row, col) => {
        if (row === dr && col === dc) return true
        
        for (const [dx, dy] of dirs) {
            let nr = row
            let nc = col

            while (isValid(maze, nr, nc)) {
                nr += dx
                nc += dy
            }
            
            nr -= dx
            nc -= dy

            if (maze[nr][nc] === -1) continue
            maze[nr][nc] = -1
            
            if (_hasPath(nr, nc)) return true
        }
        return false
    }
    
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const [dr, dc] = destination
    return _hasPath(start[0], start[1])
};

const isValid = (maze, row, col) => {
    return row >= 0 && col >= 0 && 
           row < maze.length && col < maze[0].length && 
           maze[row][col] !== 1
}
```

## 529. Minesweeper
```javascript
// BFS
/**
 * @param {character[][]} board
 * @param {number[]} click
 * @return {character[][]}
 */
var updateBoard = function(board, click) {
    const [clickRow, clickCol] = click
    if (board[clickRow][clickCol] === 'M') {
        board[clickRow][clickCol] = 'X'
        return board
    }
    
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [-1, -1], [1, 1], [1, -1], [-1, 1]]
    const queue = [click]
    while (queue.length) {
        const [row, col] = queue.shift()
        if (board[row][col] !== 'E') continue
        
        const neighbors = []
        let mines = 0
        for (const [dRow, dCol] of dirs) {
            const nextRow = row + dRow
            const nextCol = col + dCol
            
            if (nextRow < 0 || nextRow >= board.length || 
                nextCol < 0 || nextCol >= board[0].length) continue
            
            if (board[nextRow][nextCol] === 'M') {
                mines++
            } else if (board[nextRow][nextCol] === 'E') {
                neighbors.push([nextRow, nextCol])
            }            
        }
        
        if (mines > 0) {
            board[row][col] = `${mines}`
        } else {
            board[row][col] = 'B'
            queue.push(...neighbors)
        }
    }
    
    return board
};

// DFS
var updateBoard = function(board, click) {
    const [cr, cc] = click
    if (board[cr][cc] === 'M') {
        board[cr][cc] = 'X'
        return board
    }
    
    const dirs = [[1, 0], [-1, 0], [0, -1], [0, 1], [1, 1], [-1, 1], [-1, -1], [1, -1]]
    dfs(board, cr, cc, dirs)
    return board
};

const dfs = (board, row, col, dirs) => {
    if (board[row][col] !== 'E') return
    
    board[row][col] = adjMineCount(board, row, col, dirs)
    if (board[row][col] !== 'B') return
    
    for (const [dx, dy] of dirs) {
        const nr = row + dx
        const nc = col + dy
        if (isValid(board, nr, nc)) dfs(board, nr, nc, dirs)
    }
}

const isValid = (board, row, col) => {
    return row >= 0 && col >= 0 && row < board.length && col < board[0].length
}

const adjMineCount = (board, row, col, dirs) => {
    let count = 0
    
    for (const [dx, dy] of dirs) {
        const nr = row + dx
        const nc = col + dy
        if (isValid(board, nr, nc) && board[nr][nc] === 'M') count++
    }
    
    return !count ? 'B' : `${count}`
}
```

## 417. Pacific Atlantic Water Flow
```javascript
// BFS
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var pacificAtlantic = function(matrix) {    
    if (!matrix.length) return []
    
    const n = matrix.length
    const m = matrix[0].length
    const pVisited = Array(n).fill().map(a => Array(m).fill(false))
    const aVisited = Array(n).fill().map(a => Array(m).fill(false))
    
    const pQueue = []
    for (let row = 0; row < n; row++) pQueue.push([row, 0])
    for (let col = 0; col < m; col++) pQueue.push([0, col])
    bfs(pQueue, pVisited, matrix)
        
    const aQueue = []
    for (let row = 0; row < n; row++) aQueue.push([row, m - 1])
    for (let col = 0; col < m; col++) aQueue.push([n - 1, col])
    bfs(aQueue, aVisited, matrix)
    
    return intersection(pVisited, aVisited)
};

const bfs = (queue, visited, matrix) => {
    while (queue.length) {
        const [row, col] = queue.shift()

        if (visited[row][col]) continue
        visited[row][col] = true

        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const nr = dx + row
            const nc = dy + col

            if (isValid(nr, nc, matrix) && matrix[row][col] <= matrix[nr][nc])
                queue.push([nr, nc])
        }
    }
}

const intersection = (m1, m2) => {
    const result = []
    for (let row = 0; row < m1.length; row++) {
        for (let col = 0; col < m1[0].length; col++) {
            if (m1[row][col] && m2[row][col])
                result.push([row, col])
        }
    }
    return result
}

const isValid = (row, col, matrix) => {
    return row >= 0 && col >= 0 && row < matrix.length && col < matrix[0].length
}
```

## 1129. Shortest Path with Alternating Colors
```javascript
/**
 * @param {number} n
 * @param {number[][]} red_edges
 * @param {number[][]} blue_edges
 * @return {number[]}
 */
var shortestAlternatingPaths = function(n, red_edges, blue_edges) {
    const result = Array(n).fill(-1)
    const graph = buildGraph(n, red_edges, blue_edges)
    
    const queue = [[0, '']]
    const visited = new Set([`${0}-r`, `${0}-b`])
    
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [vertex, vColor] = queue.shift()
            
            if (result[vertex] === -1)
                result[vertex] = level
            
            for (const [neighbor, nColor] of graph[vertex]) {
                if (nColor === vColor) continue
                
                if (visited.has(`${neighbor}-${nColor}`)) continue
                visited.add(`${neighbor}-${nColor}`)
                
                queue.push([neighbor, nColor])
            }    
        }
        level++   
    }
    
    return result
};

const buildGraph = (n, red_edges, blue_edges) => {
    const graph = Array(n).fill().map(a => [])
    
    for (const [u, v] of red_edges) {
        graph[u].push([v, 'r'])
    }
    
    for (const [u, v] of blue_edges) {
        graph[u].push([v, 'b'])
    }
    
    return graph
}
```

## 505. The Maze II
```javascript
// Dijkstra's
/**
 * @param {number[][]} maze
 * @param {number[]} start
 * @param {number[]} destination
 * @return {number}
 */
var shortestDistance = function(maze, start, destination) {
    const dirs = [[1, 0], [-1, 0], [0, -1], [0, 1]]   
    const dists = Array(maze.length).fill().map(a => Array(maze[0].length).fill(Infinity))
    const queue = new Heap([[start[0], start[1]]], (a, b) => {
        const [aRow, aCol] = a
        const [bRow, bCol] = b
        return dists[aRow][aCol] < dists[bRow][bCol]
    })
    dists[start[0]][start[1]] = 0
    
    while (queue.length()) {
        const [row, col] = queue.remove()
                        
        for (const [dRow, dCol] of dirs) {
            let nextRow = row
            let nextCol = col
            let nextDist = 0
            while (nextRow >= 0 && nextRow < maze.length && 
                   nextCol >= 0 && nextCol < maze[0].length && 
                   maze[nextRow][nextCol] !== 1) {
                nextRow += dRow
                nextCol += dCol
                nextDist++
            }
            
            nextRow -= dRow
            nextCol -= dCol
            nextDist--
            
            if (dists[nextRow][nextCol] <= dists[row][col] + nextDist) continue
            dists[nextRow][nextCol] = dists[row][col] + nextDist
            
            if (nextRow === destination[0] && nextCol === destination[1]) {
                return dists[nextRow][nextCol]
            }
            
            queue.insert([nextRow, nextCol])
        }
    }
    
    return -1
};

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 815. Bus Routes
```javascript
var numBusesToDestination = function(routes, S, T) {
    if (S === T) return 0
    
    const graph = {}
    for (const [bus, route] of routes.entries()) {
        for (const stop of route) {
            if (!graph[stop]) {
                graph[stop] = []
            }
            graph[stop].push(bus)
        }
    }
    
    const visited = new Set()
    const queue = [[S, 0]]
    
    while (queue.length) {
        const [stop, rides] = queue.shift()
        
        for (const bus of graph[stop]) {
            if (visited.has(bus)) continue
            visited.add(bus)
            for (const stop of routes[bus]) {
                if (stop === T) return rides + 1
                queue.push([stop, rides + 1])
            }
        }    
    }
    
    return -1
};
```

## 1293. Shortest Path in a Grid with Obstacles Elimination
```javascript
var shortestPath = function(grid, k) {
    const m = grid.length
    const n = grid[0].length
    const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]
    
    const queue = [[0, 0, k]]
    const dists = { '0-0': k }
    let steps = 0
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col, obCount] = queue.shift()

            if (row === m - 1 && col === n - 1) return steps
            
            for (const [dx, dy] of dirs) {
                const nr = row + dx
                const nc = col + dy

                if (isValid(m, n, nr, nc)) {
                    const nextObCount = obCount - grid[nr][nc]
                    const key = `${nr}-${nc}`
                    
                    if (dists[key] >= nextObCount || nextObCount < 0) continue
                    dists[key] = nextObCount
                    
                    queue.push([nr, nc, nextObCount])
                }
            }   
        }
        steps++
    }
    return -1
};

const isValid = (m, n, row, col) => row >= 0 && col >= 0 && row < m && col < n
```

## 1345. Jump Game IV
```javascript
var minJumps = function(arr) {
    const map = {}
    for (const [index, num] of arr.entries()) {
        if (!map[num]) map[num] = []
        map[num].push(index)
    }
    
    let steps = 0
    const queue = [0]
    const visited = new Set()
    
    while (queue) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const index = queue.shift()
            
            if (index === arr.length - 1)
                return steps
            
            const neighbors = [index - 1, index + 1].concat(map[arr[index]] || [])
            for (const neighbor of neighbors) {
                if (neighbor < 0 || neighbor >= arr.length) continue
                if (visited.has(neighbor)) continue
                visited.add(neighbor)
                queue.push(neighbor)
            }
            map[arr[index]] = []
        }
        steps++
    }
};
```

## 353. Design Snake Game
```javascript
/**
 * Initialize your data structure here.
        @param width - screen width
        @param height - screen height 
        @param food - A list of food positions
        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].
 * @param {number} width
 * @param {number} height
 * @param {number[][]} food
 */
var SnakeGame = function(width, height, food) {
    this.width = width
    this.height = height
    
    this.food = food
    this.foodIndex = 0
    
    this.score = 0
    
    this.snakeDeque = [[0, 0]]
    this.snakeSet = new Set('0-0')
};

/**
 * Moves the snake.
        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down 
        @return The game's score after the move. Return -1 if game over. 
        Game over when snake crosses the screen boundary or bites its body. 
 * @param {string} direction
 * @return {number}
 */
SnakeGame.prototype.move = function(direction) {
    if (this.score === -1) return -1
    
    const [currRow, currCol] = this.snakeDeque[0]
    
    let nextRow = currRow
    let nextCol = currCol
    
    switch (direction) {
        case 'U':
            nextRow -= 1
            break
        case 'L':
            nextCol -= 1
            break
        case 'R':
            nextCol += 1
            break
        case 'D':
            nextRow += 1
            break
    }
    
    const [tailRow, tailCol] = this.snakeDeque.pop()
    this.snakeSet.delete(`${tailRow}-${tailCol}`)
    
    // if out of bounds return -1
    if (nextRow < 0 || nextRow >= this.height || 
        nextCol < 0 || nextCol >= this.width) {
        return -1
    }
    
    // if snake hits itself return -1
    if (this.snakeSet.has(`${nextRow}-${nextCol}`)) {
        return -1
    }
    
    if (this.foodIndex < this.food.length) {
        // if next position on food, move food index forward, inc score, add back tail
        const [foodRow, foodCol] = this.food[this.foodIndex]
        if (nextRow === foodRow && nextCol === foodCol) {
            this.foodIndex++
            this.score++
            
            this.snakeDeque.push([tailRow, tailCol])
            this.snakeSet.add(`${tailRow}-${tailCol}`)
        }
    }
    
    this.snakeDeque.unshift([nextRow, nextCol])
    this.snakeSet.add(`${nextRow}-${nextCol}`)
    
    return this.score
};

/** 
 * Your SnakeGame object will be instantiated and called as such:
 * var obj = new SnakeGame(width, height, food)
 * var param_1 = obj.move(direction)
 */
```

## 355. Design Twitter
```javascript
/**
 * Initialize your data structure here.
 */
var Twitter = function() {
    this.followMap = {}
    this.userMap = {}
    this.limit = 10
};

let timeStamp = 0

class Tweet {
    constructor(tweetId, userId) {
        this.tweetId = tweetId
        this.userId = userId
        this.timeStamp = timeStamp++
    }
}

/**
 * Compose a new tweet. 
 * @param {number} userId 
 * @param {number} tweetId
 * @return {void}
 */
Twitter.prototype.postTweet = function(userId, tweetId) {
    const tweet = new Tweet(tweetId, userId)
    
    if (!this.userMap[userId])
        this.createUser(userId)
    
    this.userMap[userId].unshift(tweet)
    
    if (this.userMap[userId].length > this.limit)
        this.userMap[userId].pop()
};

/**
 * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. 
 * @param {number} userId
 * @return {number[]}
 */
Twitter.prototype.getNewsFeed = function(userId) {
    const pq = new Heap([], (tweet1, tweet2) => tweet1.timeStamp < tweet2.timeStamp)
    
    
    if (!this.followMap[userId]) return []
    
    for (const followId of this.followMap[userId]) {
        if (!this.userMap[followId]) continue
        for (const tweet of this.userMap[followId]) {
            if (pq.length() < this.limit) {
                pq.insert(tweet)
            } else {
                if (tweet.timeStamp <= pq.peek().timeStamp)
                    break

                pq.insert(tweet)
                pq.remove()
            }   
        }
    }
    
    const result = []
    
    while (result.length >= 0 && pq.length())
        result.unshift(pq.remove().tweetId)
    
    return result
};

/**
 * Follower follows a followee. If the operation is invalid, it should be a no-op. 
 * @param {number} followerId 
 * @param {number} followeeId
 * @return {void}
 */
Twitter.prototype.follow = function(followerId, followeeId) {
    if (!this.followMap[followerId])
        this.followMap[followerId] = new Set([followerId])
    
    this.followMap[followerId].add(followeeId)
};

/**
 * Follower unfollows a followee. If the operation is invalid, it should be a no-op. 
 * @param {number} followerId 
 * @param {number} followeeId
 * @return {void}
 */
Twitter.prototype.unfollow = function(followerId, followeeId) {
    if (!this.followMap[followerId] || followerId === followeeId) return
    this.followMap[followerId].delete(followeeId)
};

Twitter.prototype.createUser = function(userId) {
    if (!this.userMap[userId])
        this.userMap[userId] = []
    
    this.follow(userId, userId)
}

/** 
 * Your Twitter object will be instantiated and called as such:
 * var obj = new Twitter()
 * obj.postTweet(userId,tweetId)
 * var param_2 = obj.getNewsFeed(userId)
 * obj.follow(followerId,followeeId)
 * obj.unfollow(followerId,followeeId)
 */

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 921. Minimum Add to Make Parentheses Valid
```javascript
/**
 * @param {string} S
 * @return {number}
 */
var minAddToMakeValid = function(S) {
    let balance = 0
    let min = 0
    
    for (const s of S) {
        s === '(' ? balance++ : balance--
        if (balance < 0) {
            balance++
            min++
        }        
    }
    
    return min + balance
};
```

## 402. Remove K Digits
```javascript
/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function(num, k) {
    const stack = []

    for (const digit of num) {
       while (stack.length && 
              stack[stack.length - 1] > digit &&
              k) {
           stack.pop()
           k--
       }
        
        stack.push(digit)
    }
    
    while (stack.length && k) {
        stack.pop()
        k--
    }
    
    while (stack.length && stack[0] === '0') {
        stack.shift()
    }
    
    const result = stack.join('')
    return result.length ? result : '0'
};
```

## 636. Exclusive Time of Functions
```javascript
var exclusiveTime = function(n, logs) {
    const stack = []
    const arr = Array(n).fill(0)
    
    for (const log of logs) {
        const [id, state, time] = log.split(':')
        
        if (state === 'start') {
            stack.push([id, state, time])
        } else {
            const [pid, pstate, ptime] = stack.pop()
            delta = time - ptime + 1
            arr[id] += delta
            
            if (stack.length)
                arr[stack[stack.length - 1][0]] -= delta
        }
    }
    
    return arr
};
```

## 394. Decode String
```javascript
// Stack
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function(s) {
    const stack = []
    let currString = []
    let currCount = 0
    
    for (const char of s) {
        if (char === '[') {
            stack.push(currString)
            stack.push(currCount)
            currCount = 0
            currString = []
        } else if (char === ']') {
            const prevCount = stack.pop()
            const prevString = stack.pop()
            
            for (let i = 0; i < prevCount; i++) {
                for (const char of currString) {
                    prevString.push(char)
                }
            }
            
            currString = prevString
        } else if (isNaN(char)) {
            currString.push(char)
        } else {
            currCount *= 10
            currCount += +char
        }
    }
    
    return currString.join('')
};

// DFS 
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function(s) {
    const _decodeString = () => {
        if (i >= s.length) return ''
        
        const curr = []
        let count = 0
        while (i < s.length) {
            if (isDigit(s[i])) {
                count *= 10
                count += +s[i]
                i++
            } else if (s[i] === '[') {
                i++
                const next = _decodeString()
                while (count > 0) {
                    curr.push(next)
                    count--
                }
            } else if (s[i] === ']') {
                i++
                return curr.join('')
            } else {
                curr.push(s[i])
                i++
            }
        }
        
        return curr.join('')
    }
    
    let i = 0
    return _decodeString()
};

const isDigit = char => '0' <= char && char <= '9'
```

## 150. Evaluate Reverse Polish Notation
```javascript
var evalRPN = function(tokens) {
    const stack = []
    let result = 0
    
    for (const token of tokens) {
        const num = parseInt(token)
        
        if (!isNaN(num)) {
            stack.push(num)
        } else {
            const num1 = stack.pop()
            const num2 = stack.pop()
            
            switch(token) {
                case '+':
                    stack.push(num2 + num1)
                    break
                case '-':
                    stack.push(num2 - num1)
                    break
                case '*':
                    stack.push(num2 * num1)
                    break
                case '/':
                    stack.push(Math.trunc(num2 / num1))
                    break
            }
        }
    }
    
    return stack.pop()
};
```

## 331. Verify Preorder Serialization of a Binary Tree
```javascript
// Time - O(n)
// Space - O(n)
var isValidSerialization = function(preorder) {
    const nodes = preorder.split(',')
    
    let slots = 1
    
    for (const node of nodes) {
        slots--
        
        if (slots < 0) return false
        
        if (node !== '#') {
            slots += 2
        }
    }
    
    return slots === 0
};

// Time O(n)
// Space O(1)
var isValidSerialization = function(preorder) {
    let slots = 1
    
    for (let i = 0; i < preorder.length; i++) {
        if (preorder[i] !== ',') continue
        slots--

        if (slots < 0) return false

        if (preorder[i - 1] !== '#') slots += 2
    }
    
    slots += (preorder[preorder.length - 1] === '#') ? -1 : 1
    return slots === 0
};

// Stack
var isValidSerialization = function(preorder) {
    const chars = preorder.split(',')
    const stack = []
    
    for (const char of chars) {
        while (char === '#' && stack.length && stack[stack.length - 1] === '#') {
            stack.pop()
            if (!stack.length) return false
            stack.pop()
        }
        stack.push(char)
    }
    
    return stack.length === 1 && stack[stack.length - 1] === '#'
};
```

## 71. Simplify Path
```javascript
var simplifyPath = function(path) {
    const stack = []
    for (const dir of path.split('/')) {
        if (dir === '' || dir === '.') {
            continue
        }
        
        if (dir === '..') {
            stack.pop()
            continue
        }
        
        stack.push(dir)
    }
    
    return `/${stack.join('/')}`
};
```

## 1249. Minimum Remove to Make Valid Parentheses
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var minRemoveToMakeValid = function(s) {
    const charArr = s.split('')
    const stack = []
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i)
        } else if (s[i] === ')') {
            if (!stack.length) {
                charArr[i] = ''
                continue
            }
            stack.pop()
        }
    }
    
    while (stack.length) {
        charArr[stack.pop()] = ''
    }
    
    return charArr.join('')
};
```

## 1190. Reverse Substrings Between Each Pair of Parentheses
```javascript
// O(n^2)
/**
 * @param {string} s
 * @return {string}
 */
var reverseParentheses = function(s) {
    const charArr = s.split('')
    const stack = []
    
    for (let i = 0; i < s.length; i++) {
        if (charArr[i] === '(') {
            stack.push(i)
            continue
        }
        
        if (charArr[i] === ')') {
            const start = stack.pop()
            
            charArr[start] = ''
            charArr[i] = ''
            
            reverse(charArr, start + 1, i - 1)
        }
    }
    
    return charArr.join('')
};

const reverse = (arr, start, end) => {
    while (start < end) {
        const temp = arr[start]
        arr[start] = arr[end]
        arr[end] = temp
        
        start++
        end--
    }
}

// O(n)
/**
 * @param {string} s
 * @return {string}
 */
var reverseParentheses = function(s) {
    const pairs = Array(s.length).fill(null)
    const stack = []
    
    for (let i = 0; i < s.length; i++) {
        const char = s[i]
        if (char === '(') {
            stack.push(i)
        } else if (char === ')') {
            const j = stack.pop()
            pairs[i] = j
            pairs[j] = i
        }
    }
    
    const result = []
    let d = 1
    for (let i = 0; i < s.length; i += d) {
        const char = s[i]
        if (char === '(' || char === ')') {
            d = -d
            i = pairs[i]
        } else {
            result.push(char)
        }
    }
    
    return result.join('')
};
```

## 946. Validate Stack Sequences
```javascript
// O(n) Space
var validateStackSequences = function(pushed, popped) {
    const stack = []
    let j = 0
    for (const ele of pushed) {
        stack.push(ele)
        
        while (stack.length && j < popped.length && stack[stack.length - 1] === popped[j]) {
            stack.pop()
            j++
        }
    }
    
    return j === popped.length
};

// O(1) Space
var validateStackSequences = function(pushed, popped) {
    let i = 0
    let j = 0
    for (const ele of pushed) {
        pushed[i++] = ele
        
        while (i > 0 && pushed[i - 1] === popped[j]) {
            i--
            j++
        }
    }
    
    return i === 0
};
```

## 341. Flatten Nested List Iterator
```javascript
// O(n) initalization
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
    const dfs = node => {
        if (!node) return

        for (const list of node) {
            if (list.isInteger()) {
                this.elements.push(list.getInteger())
            } else {
                dfs(list.getList())
            }
        }
    }
    
    this.elements = []
    this.currIndex = 0
    dfs(nestedList)
};

/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
    return this.currIndex < this.elements.length
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
    return this.elements[this.currIndex++]
};

/**
 * Your NestedIterator will be called like this:
 * var i = new NestedIterator(nestedList), a = [];
 * while (i.hasNext()) a.push(i.next());
*/

// O(1) initalization
// O(n) next
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
    this.stack = nestedList.reverse()
    this.loadNext()
};


/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
    return this.stack.length
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
    const next = this.stack.pop().getInteger()
    this.loadNext()
    return next
};

NestedIterator.prototype.loadNext = function() {
    while (this.stack.length && !this.stack[this.stack.length - 1].isInteger()) {
        for (const list of this.stack.pop().getList().reverse()) {
            this.stack.push(list)
        }
    }
}

/**
 * Your NestedIterator will be called like this:
 * var i = new NestedIterator(nestedList), a = [];
 * while (i.hasNext()) a.push(i.next());
*/
```

## 735. Asteroid Collision
```javascript
var asteroidCollision = function(asteroids) {
    const stack = []
    
    for (const asteroid of asteroids) {
        if (!stack.length || 
            Math.sign(stack[stack.length - 1]) === Math.sign(asteroid) || 
            Math.sign(stack[stack.length - 1]) === -1 && Math.sign(asteroid) === 1) {
            stack.push(asteroid)
            continue
        }
        
        let flag = true
        while (stack[stack.length - 1] && Math.sign(stack[stack.length - 1]) !== Math.sign(asteroid)) {
            if (Math.abs(stack[stack.length - 1]) === Math.abs(asteroid)) {
                stack.pop()
                flag = false
                break
            }
            
            if (Math.abs(stack[stack.length - 1]) > Math.abs(asteroid)) {
                flag = false
                break
            }
            
            stack.pop()
        }
        
        if (flag) stack.push(asteroid)
    }
    
    return stack
};
```

## 1254. Number of Closed Islands
```javascript
// Two Pass
var closedIsland = function(grid) {
    let count = 0
    fillBorder(grid)
    
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 0) {
                fill(grid, i, j)
                count++
            }
        }
    }
    
    return count
};

const fillBorder = grid => {
    for (let i = 0; i < grid.length; i++) {
        if (grid[i][0] === 0) 
            fill(grid, i, 0)
        
        if (grid[i][grid[0].length - 1] === 0)
            fill(grid, i, grid[0].length - 1)
    }

    for (let i = 0; i < grid[0].length - 1; i++) {
        if (grid[0][i] === 0)
            fill(grid, 0, i)
        
        if (grid[grid.length - 1][i] === 0)
            fill(grid, grid.length - 1, i)
    }
}

const fill = (grid, row, col) => {
    if (row < 0 || col < 0 || 
        row >= grid.length || col >= grid[0].length || 
        grid[row][col] === 1) return
    
    grid[row][col] = 1
    
    fill(grid, row + 1, col)
    fill(grid, row - 1, col)
    fill(grid, row, col + 1)
    fill(grid, row, col - 1)
}

// One Pass
var closedIsland = function(grid) {
    let count = 0
    
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (!grid[i][j] && dfs(grid, i, j)) count++
        }
    }
    
    return count
};

const dfs = (grid, row, col) => {
    if (row < 0 || col < 0 || 
        row >= grid.length || col >= grid[0].length || 
        grid[row][col] === 1) return true
    
    if (isBorder(grid, row, col)) return false
    
    grid[row][col] = 1
    
    let isClosed = true
    isClosed &= dfs(grid, row + 1, col)
    isClosed &= dfs(grid, row - 1, col)
    isClosed &= dfs(grid, row, col + 1)
    isClosed &= dfs(grid, row, col - 1)
    return isClosed
}

const isBorder = (grid, row, col) => {
    return row === 0 || row === grid.length - 1 || col === 0 || col === grid[0].length - 1
}
```

## 1020. Number of Enclaves
```javascript
var numEnclaves = function(A) {
    let count = 0
    
    for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
            if (!A[i][j]) continue
            
            const result = dfs(A, i, j)
            if (result === Infinity) continue
            count += result
        }
    }
    
    return count
};

const dfs = (grid, row, col) => {
    if (isOutOfBounds(grid, row, col) || !grid[row][col]) return 0
    if (isBorder(grid, row, col)) return Infinity
    
    grid[row][col] = 0
    
    return dfs(grid, row + 1, col) + 
           dfs(grid, row - 1, col) + 
           dfs(grid, row, col + 1) + 
           dfs(grid, row, col - 1) + 1
}

const isOutOfBounds = (grid, row, col) => {
    return row < 0 || col < 0 || row >= grid.length || col >= grid[0].length
}

const isBorder = (grid, row, col) => {
    return row === 0 || col === 0 || row >= grid.length - 1 || col >= grid[0].length - 1
}
```

## 851. Loud and Rich
```javascript
var loudAndRich = function(richer, quiet) {
    const graph = buildGraph(richer, quiet.length)
    const result = Array(quiet.length).fill(null)
    
    for (let vertex = 0; vertex < quiet.length; vertex++) {
        dfs(graph, vertex, result, quiet)
    }
    
    return result
};

const dfs = (graph, vertex, result, quiet) => {
    if (result[vertex] !== null) return result[vertex]
    
    result[vertex] = vertex
    
    for (const n of graph[vertex]) {
        if (quiet[dfs(graph, n, result, quiet)] < quiet[result[vertex]]) {
            result[vertex] = result[n]
        }
    }
    
    return result[vertex]
}

const buildGraph = (edges, n) => {
    const graph = {}
    
    for (let i = 0; i < n; i++) {
        graph[i] = []
    }
    
    for (const [u, v] of edges) {
        graph[v].push(u)
    }
    
    return graph
}
```

## 1080. Insufficient Nodes in Root to Leaf Paths
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} limit
 * @return {TreeNode}
 */
var sufficientSubset = function(root, limit) {
    const _sufficientSubset = (node, sum) => {
        if (!node) return null
        
        sum += node.val
        
        if (isLeaf(node)) 
            return sum < limit ? null : node
        
        node.left = _sufficientSubset(node.left, sum)
        node.right = _sufficientSubset(node.right, sum)
        
        return isLeaf(node) ? null : node
    }
    
    return _sufficientSubset(root, 0)
};

const isLeaf = node => !node.left && !node.right
```

## 886. Possible Bipartition
```javascript
/**
 * @param {number} N
 * @param {number[][]} dislikes
 * @return {boolean}
 */
var possibleBipartition = function(N, dislikes) {
    const graph = buildGraph(N + 1, dislikes)
    const colors = Array(N + 1).fill()
    
    for (let vertex = 1; vertex <= N; vertex++) {
        if (colors[vertex] !== undefined) continue
        if (!color(graph, colors, vertex)) {
            return false
        }
    }
    
    return true
};

const color = (graph, colors, vertex) => {
    const stack = [vertex]
    colors[vertex] = 0
    
    while (stack.length) {
        const vertex = stack.pop()
        
        for (const neighbor of graph[vertex]) {
            if (colors[neighbor] === undefined) {
                colors[neighbor] = 1 - colors[vertex]
                stack.push(neighbor)
            } else if (colors[neighbor] === colors[vertex]) {
                return false
            }
        }
    }
    
    return true
}

const buildGraph = (N, edges) => {
    const graph = Array(N).fill().map(a => [])
    
    for (const [u, v] of edges) {
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}
```

## 802. Find Eventual Safe States
```javascript
/**
 * @param {number[][]} graph
 * @return {number[]}
 */
var eventualSafeNodes = function(graph) {
    const dfs = vertex => {
        if (colors[vertex] === 2) return false
        if (colors[vertex] === 1) return true
        colors[vertex] = 1
        
        for (const neighbor of graph[vertex]) {
            if (dfs(neighbor)) return true
        }
        
        colors[vertex] = 2
    }
    
    const result = []
    const colors = Array(graph.length).fill(0)
    for (let vertex = 0; vertex < graph.length; vertex++) {
        if (dfs(vertex)) continue
        result.push(vertex)
    }
    
    return result
};
```

## 1059. All Paths from Source Lead to Destination
```javascript
// Black White Gray Coloring
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} source
 * @param {number} destination
 * @return {boolean}
 */
var leadsToDestination = function(n, edges, source, destination) {
    const graph = buildGraph(edges, n)
    return dfs(graph, source, destination, n)
};

const dfs = (graph, source, destination, n) => {
    const _dfs = vertex => {
        if (!graph[vertex]) return vertex === destination
        
        colors[vertex] = 1
        
        for (const neighbor of graph[vertex]) {
            if (colors[neighbor] === 1) return false
            if (colors[neighbor] === 0 && !_dfs(neighbor)) return false
        }
        
        colors[vertex] = 2
        return true
    }
    
    const colors = Array(n).fill(0)
    return _dfs(source)
}

const buildGraph = (edges, n) => {
    const graph = Array(n).fill(null)
    
    for (const [u, v] of edges) {
        if (!graph[u]) graph[u] = []
        graph[u].push(v)
    }
    
    return graph
}

// TopSort
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} source
 * @param {number} destination
 * @return {boolean}
 */
var leadsToDestination = function(n, edges, source, destination) {
    const [graph, degrees] = buildGraph(edges, n)
    return topSort(graph, degrees, source, destination)
};

const topSort = (graph, degrees, source, destination) => {
    if (degrees[destination] !== 0) return false
    
    const queue = [destination]
    while (queue.length) {
        const vertex = queue.shift()
        if (vertex === source) return true
        
        for (const neighbor of graph[vertex]) {
            degrees[neighbor]--
            if (degrees[neighbor] === 0) {
                queue.push(neighbor)
            }
        }
    }
    return false
}

const buildGraph = (edges, n) => {
    const graph = Array(n).fill(null)
    const degrees = Array(n).fill(0)
    
    for (const [u, v] of edges) {
        if (!graph[v]) graph[v] = []
        graph[v].push(u)
        degrees[u]++
    }
    
    return [graph, degrees]
}
```

## 971. Flip Binary Tree To Match Preorder Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number[]} voyage
 * @return {number[]}
 */
var flipMatchVoyage = function(root, voyage) {
    const _flipMatchVoyage = (node) => {
        if (!node) return true
        
        if (node.val !== voyage[i]) {
            return false
        }
        i++
        
        if (node.left && node.left.val !== voyage[i]) {
            const temp = node.left
            node.left = node.right
            node.right = temp
            nodes.push(node.val)
        }
        
        return _flipMatchVoyage(node.left) && _flipMatchVoyage(node.right)
    }
    
    const nodes = []
    let i = 0
    
    if (!_flipMatchVoyage(root)) {
        return [-1]
    }
    
    return nodes
};
```

## 491. Increasing Subsequences
```javascript
var findSubsequences = function(nums) {
    const _findSubsequences = (curr, seq) => {
        if (seq.length > 1) {
            result.push(seq.slice())
        }
        
        const seen = new Set()
        for (let i = curr; i < nums.length; i++) {
            if (nums[i] < seq[seq.length - 1]) continue
            if (seen.has(nums[i])) continue
            seen.add(nums[i])
            seq.push(nums[i])
            _findSubsequences(i + 1, seq)
            seq.pop()
        }
    }
    
    const result = []
    _findSubsequences(0, [])
    return result
};
```

## 531. Lonely Pixel I
```javascript
// Iterative O(mn) space
var findLonelyPixel = function(picture) {
    const n = picture.length
    const m = picture[0].length
    
    const rowCount = Array(n).fill(0)
    const colCount = Array(m).fill(0)
    
    let count = 0
    
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < m; col++) {
            if (picture[row][col] === 'B') {
                rowCount[row]++
                colCount[col]++
            }
        }
    }

    for (let row = 0; row < n; row++) {
        if (rowCount[row] !== 1) continue
        for (let col = 0; col < m; col++) {
            if (picture[row][col] === 'B' && colCount[col] === 1) {
                count++
                continue
            }
        }
    }
    
    return count
};
```

## 439. Ternary Expression Parser
```javascript
// Stack
var parseTernary = function(expression) {
    const stack = []
    
    for (let i = expression.length - 1; i >= 0; i--) {
        const char = expression[i]
        
        if (char === ':')
            continue
        
        if (char === '?') {    
            const bool = expression[--i]
            const t = stack.pop()
            const f = stack.pop()
            
            bool === 'T' ? stack.push(t) : stack.push(f)
            continue
        }
        
        stack.push(char)
    }
    
    return stack.pop()
};
```

## 959. Regions Cut By Slashes
```javascript
// DFS
/**
 * @param {string[]} grid
 * @return {number}
 */
var regionsBySlashes = function(grid) {
    const n = grid.length
    const m = grid[0].length
    
    const matrix = Array(n * 3).fill(0).map(row => Array(m * 3).fill(1))
    fillSlashes(matrix, grid)
    return countComponents(matrix)
};

const fillSlashes = (matrix, grid) => {
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            const mRow = row * 3
            const mCol = col * 3
            if (grid[row][col] === '/') {
                matrix[mRow][mCol + 2] = 0
                matrix[mRow + 1][mCol + 1] = 0
                matrix[mRow + 2][mCol] = 0
            } else if (grid[row][col] === '\\') {
                matrix[mRow][mCol] = 0
                matrix[mRow + 1][mCol + 1] = 0
                matrix[mRow + 2][mCol + 2] = 0
            }
        }
    }
}

const countComponents = matrix => {
    const fill = (row, col) => {
        if (row < 0 || col < 0 || 
            row >= matrix.length || col >= matrix[0].length ||
            matrix[row][col] === 0) return
        
        matrix[row][col] = 0
        
        fill(row + 1, col)
        fill(row - 1, col)
        fill(row, col + 1)
        fill(row, col - 1)
    }
    
    let count = 0
    
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] === 1) {
                count++
                fill(i, j)
            }
        }
    }
    
    return count
}

// Union Find
/**
 * @param {string[]} grid
 * @return {number}
 */
var regionsBySlashes = function(grid) {
    const k = 3
    const n = grid.length
        
    // Build matrix
    const matrix = new Array(n * k).fill().map(a => new Array(n * k).fill(0))
    const m = matrix.length
    
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === ' ') continue
            
            const adjustedRow = row * k
            const adjustedCol = col * k
            
            if (grid[row][col] === '/') {
                let currCol = adjustedCol + k - 1
                for (let currRow = adjustedRow; currRow < adjustedRow + k; currRow++) {
                    matrix[currRow][currCol] = 1
                    currCol--
                }
            } else if (grid[row][col] === '\\') {
                let currCol = adjustedCol
                for (let currRow = adjustedRow; currRow < adjustedRow + k; currRow++) {
                    matrix[currRow][currCol] = 1
                    currCol++
                }
            }
        }
    }
    
    // Get regions
    const dirs = [[1, 0], [0, 1]]
    const unionFind = new UnionFind(m * m)
    let slashCount = 0
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < m; col++) {
            if (matrix[row][col] === 1) {
                slashCount++
                continue
            }
            
            for (const [deltaRow, deltaCol] of dirs) {
                const nextRow = deltaRow + row
                const nextCol = deltaCol + col
                
                if (nextRow < 0 || nextRow >= m || 
                    nextCol < 0 || nextCol >= m) continue
                
                if (matrix[nextRow][nextCol] === 1) continue
                
                unionFind.union(row * m + col, nextRow * m + nextCol)
            }
        }
    }
    
    return unionFind.numOfComponents - slashCount
};

class UnionFind {
    constructor(size) {
        this.numOfComponents = size
        
        this.sizes = []
        this.parents = []
        for (let i = 0; i < size; i++) {
            this.sizes.push(1)
            this.parents.push(i)
        }
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] = this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentB] = this.sizes[parentA]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
}
```

## 988. Smallest String Starting From Leaf
```javascript
var smallestFromLeaf = function(root, path = []) {
    if (!root) return '|'

    path.push(String.fromCharCode(root.val + 97))

    if (!root.left && !root.right) {
        const str = path.slice().reverse().join('')
        path.pop()
        return str
    }

    const left = smallestFromLeaf(root.left, path)
    const right = smallestFromLeaf(root.right, path)
    path.pop()

    return left < right ? left : right
};
```

## 1267. Count Servers that Communicate
```javascript
var countServers = function(grid) {
    const m = grid.length
    const n = grid[0].length
    
    const rowCounts = Array(m).fill(0)
    const colCounts = Array(n).fill(0)
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col]) {
                rowCounts[row]++
                colCounts[col]++
            }
        }
    }
    
    let count = 0
    for (let row = 0; row < m; row++)
        for (let col = 0; col < n; col++)
            if (grid[row][col] && (rowCounts[row] > 1 || colCounts[col] > 1))
                count++
    
    return count
};
```

## 399. Evaluate Division
```javascript
// DFS
var calcEquation = function(equations, values, queries) {
    const graph = buildGraph(equations, values)
    
    const result = []
    for (const [u, v] of queries) {
        result.push(dfs(graph, u, v))
    }
    return result
};

const buildGraph = (edges, weights) => {
    const graph = {}
    
    for (let i = 0; i < edges.length; i++) {
        const [u, v] = edges[i]
        if (!graph[u]) graph[u] = []
        if (!graph[v]) graph[v] = []
        
        graph[u].push([v, weights[i]])
        graph[v].push([u, 1 / weights[i]])
    }
    
    return graph
}

const dfs = (graph, start, end) => {
    const _dfs = (vertex, product) => {
        if (vertex === end) return product
        
        if (graph[vertex]) {
            for (const [neighbor, weight] of graph[vertex]) {
                if (seen.has(neighbor)) continue
                seen.add(neighbor)
                const result = _dfs(neighbor, product * weight)
                if (result !== -1) return result
            }
        }
        return -1
    }
    
    if (!graph[start] || !graph[end]) return -1
    
    const seen = new Set([start])
    return _dfs(start, 1)
}

// Path Compression
var calcEquation = function(equations, values, queries) {
    const graph = buildGraph(equations, values)
    
    const result = []
    for (const [u, v] of queries) {
        result.push(dfs(graph, u, v))
    }
    return result
};

const buildGraph = (edges, weights) => {
    const graph = {}
    
    for (let i = 0; i < edges.length; i++) {
        const [u, v] = edges[i]
        if (!graph[u]) graph[u] = new Set()
        if (!graph[v]) graph[v] = new Set()
        
        graph[u].add(JSON.stringify([v, weights[i]]))
        graph[v].add(JSON.stringify([u, 1 / weights[i]]))
    }
    
    return graph
}

const dfs = (graph, start, end) => {
    const _dfs = (vertex, product) => {
        if (vertex === end) {
            graph[start].add(JSON.stringify([end, product]))
            graph[end].add(JSON.stringify([start, 1 / product]))
            return product
        }
        
        if (graph[vertex]) {
            for (const val of graph[vertex]) {
                const [neighbor, weight] = JSON.parse(val)
                if (seen.has(neighbor)) continue
                seen.add(neighbor)
                const result = _dfs(neighbor, product * weight)                
                if (result !== -1) return result
            }
        }
        return -1
    }
    
    if (!graph[start] || !graph[end]) return -1
    
    const seen = new Set([start])
    return _dfs(start, 1)
}
```

## 1102. Path With Maximum Minimum Value
```javascript
// Greedy BFS
var maximumMinimumPath = function(A) {
    const m = A.length
    const n = A[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const heap = new Heap([], (a, b) => a[0] > b[0])
    heap.insert([A[0][0], 0, 0])
    let min = A[0][0]
    
    const seen = Array(m).fill(0).map(e => Array(n).fill(0))
    while (heap.length()) {
        const [val, row, col] = heap.remove()
        min = Math.min(min, val)
        
        if (row === m - 1 && col === n - 1)
            return min
        
        for (const [x, y] of dirs) {
            const dx = x + row
            const dy = y + col
            
            if (dx < 0 || dy < 0 || dx >= m || dy >= n) continue
            
            if (seen[dx][dy]) continue
            seen[dx][dy] = 1
            
            heap.insert([A[dx][dy], dx, dy])
        }
    }
    
    return min
};

class Heap {
    constructor(elements = [], sortBy = (a, b) => { a < b }) {
        this.elements = elements
        this.sortBy = sortBy
        this.heapify()
    }
    
    heapify() {
        for (let i = Math.floor(this.elements.length / 2) - 1; 0 <= i; i--) {
          this.siftDown(i)
        }
    }
    
    insert(val) {
        this.elements.push(val)
        this.siftUp()
    }
    
    remove() {
        if (!this.elements.length) return null
        
        const temp = this.elements[0]
        this.elements[0] = this.elements[this.elements.length - 1]
        this.elements[this.elements.length - 1] = temp
        
        const element = this.elements.pop()
        this.siftDown()
        return element
    }
    
    siftDown(index = 0) {
        let parent = index
        while (true) {
            const left = this.leftChildIndex(parent)
            const right = this.rightChildIndex(parent)
            let candidate = parent
            
            if (left < this.elements.length && this.sortBy(this.elements[left], this.elements[candidate])) {
                candidate = left
            }
            
            if (right < this.elements.length && this.sortBy(this.elements[right], this.elements[candidate])) {
                candidate = right
            }
            
            if (candidate === parent)
                return
            
            const temp = this.elements[candidate]
            this.elements[candidate] = this.elements[parent]
            this.elements[parent] = temp
            
            parent = candidate
        }
    }
    
    siftUp() {
        let child = this.elements.length - 1
        let parent = this.parentIndex(child)
        
        while (child > 0 && this.sortBy(this.elements[child], this.elements[parent])) {
            const temp = this.elements[child]
            this.elements[child] = this.elements[parent]
            this.elements[parent] = temp
            
            child = parent
            parent = this.parentIndex(child)
        }
    }
    
    leftChildIndex(index) {
        return index * 2 + 1
    }
    
    rightChildIndex(index) {
        return index * 2 + 2
    }
    
    parentIndex(index) {
        return Math.floor((index - 1) / 2)
    }
    
    length() {
        return this.elements.length
    }
}

// Union Find
/**
 * @param {number[][]} A
 * @return {number}
 */
var maximumMinimumPath = function(A) {
    const edges = []
    for (let row = 0; row < A.length; row++) {
        for (let col = 0; col < A[0].length; col++) {
            edges.push([row, col, A[row][col]])
        }
    }
    
    edges.sort((a, b) => b[2] - a[2])
    
    const visited = Array(A.length).fill(0).map(a => Array(A[0].length).fill(0))
    const unionFind = new UnionFind(edges.length)
    let min = A[0][0]
    const start = 0
    const end = A.length * A[0].length - 1
        
    for (const [row, col, val] of edges) {
        min = Math.min(min, val)
        visited[row][col] = 1
        
        const v1 = row * A[0].length + col
        for (const [dRow, dCol] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const newRow = row + dRow
            const newCol = col + dCol
            
            if (newRow < 0 || newCol < 0 || 
                newRow >= A.length || newCol >= A[0].length ||
                visited[newRow][newCol] === 0) continue
            
            const v2 = newRow * A[0].length + newCol
            unionFind.union(v1, v2)
        }
        
        if (unionFind.connected(start, end)) break
    }
    
    return min
};

class UnionFind {
    constructor(n) {
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        
        for (let i = 0; i < n; i++) {
            this.parents[i] = i
        }
    }
    
    connected(a, b) {
        return this.find(a) === this.find(b) 
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB)
            return
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
    }
    
    find(a) {
        let root = this.parents[a]
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (root !== a) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
}
```

## 1198. Find Smallest Common Element in All Rows
```javascript
// Map
var smallestCommonElement = function(mat) {
    const map = Array(10 ** 4).fill(0)
    
    for (let j = 0; j < mat[0].length; j++) {
        for (let i = 0; i < mat.length; i++) {
            map[mat[i][j]]++
            
            if (map[mat[i][j]] === mat.length) {
                return mat[i][j]
            }
        }
    }
    
    return -1
};

// Binary Search
var smallestCommonElement = function(mat) {
    for (let col = 0; col < mat[0].length; col++) {
        const ele = mat[0][col]
        
        let found = true
        for (let row = 1; row < mat.length; row++) {
            if (binarySearch(mat[row], ele)) {
                continue
            } else {
                found = false
                break
            }
        }
        
        if (found) return ele
    }
    
    return -1
};

const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length - 1
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        if (arr[mid] === target) {
            return true
        }
        
        if (arr[mid] > target) {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    
    return false
}
```

## 162. Find Peak Element
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
    let left = 0
    let right = nums.length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left
};
```

## 74. Search a 2D Matrix
```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
    const m = matrix.length
    const n = matrix[0].length
    
    let left = 0
    let right = m * n - 1
    
    while (left <= right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        const row = Math.trunc(mid / n)
        const col = mid % n
        
        if (matrix[row][col] === target) {
            return true
        }
        
        if (matrix[row][col] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return false
};
```

## 702. Search in a Sorted Array of Unknown Size
```javascript
var search = function (reader, target) {
    let left = 0
    let right = 1
    
    while (reader.get(right) < target) {
        left = right + 1
        right *= 2
    }
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (reader.get(mid) === target)
            return mid
        
        if (reader.get(mid) < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1
};
```

## 528. Random Pick with Weight
```javascript
/**
 * @param {number[]} w
 */
var Solution = function(w) {
    this.sums = w
    
    for (let i = 1; i < this.sums.length; i++) {
        this.sums[i] = this.sums[i - 1] + this.sums[i]
    }
};

/**
 * @return {number}
 */
Solution.prototype.pickIndex = function() {
    const randomIndex = Math.floor(Math.random() * this.sums[this.sums.length - 1])
    
    let left = 0
    let right = this.sums[this.sums.length - 1]
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (this.sums[mid] <= randomIndex) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(w)
 * var param_1 = obj.pickIndex()
 */
```

## 1283. Find the Smallest Divisor Given a Threshold
```javascript
var smallestDivisor = function(nums, threshold) {
    let left = 0
    let right = 10 ** 6
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (belowThreshold(nums, threshold, mid)) {
            right = mid
        } else {
            left = mid + 1
        }
    }
    
    return left
};

const belowThreshold = (nums, threshold, divisor) => {
    let sum = 0
    
    for (const num of nums) {
        sum += Math.ceil(num / divisor)
    }
    
    return sum <= threshold
}
```

## 1111. Maximum Nesting Depth of Two Valid Parentheses Strings
```javascript
/**
 * @param {string} seq
 * @return {number[]}
 */
var maxDepthAfterSplit = function(seq) {
    const result = []
    let depth = 0
    for (const char of seq) {
        if (char === '(') {
            depth++
        }
        
        result.push(depth % 2)
        
        if (char == ')') {
            depth--
        }
    }
    
    return result
};
```

## 1300. Sum of Mutated Array Closest to Target
```javascript
/**
 * @param {number[]} arr
 * @param {number} target
 * @return {number}
 */
var findBestValue = function(arr, target) {
    let left = 0
    let right = Math.max(...arr) + 1
    
    let closest = Infinity
    let closestSum = Infinity
    
    while (left <= right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        const midSum = mutatedSum(arr, mid)
        
        if (Math.abs(closestSum - target) > Math.abs(midSum - target)) {
            closest = mid
            closestSum = midSum
        }
        
        if (midSum === target) {
            return mid
        } else if (midSum < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return closest
};

const mutatedSum = (arr, val) => {
    let sum = 0
    
    for (const num of arr) {
        sum += Math.min(num, val)
    }
    
    return sum
}
```

## 1351. Count Negative Numbers in a Sorted Matrix
```javascript
// O(mn)
var countNegatives = function(grid) {
    let count = 0
    
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] < 0) count++
        }
    }
    
    return count
};

// O(mn) Optimized

```

## 455. Assign Cookies
```javascript
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    g.sort((a, b) => a - b)
    s.sort((a, b) => a - b)
    
    let count = 0
    
    let j = 0
    for (let i = 0; i < g.length; i++) {
        while (j < s.length && s[j] < g[i]) j++
        
        if (j >= s.length)
            return count
        
        count++
        j++
    }
    
    return count
};
```

## 874. Walking Robot Simulation
```javascript
var robotSim = function(commands, obstacles) {
    const dirs = [[0, 1], [-1, 0], [0, -1], [1, 0]]
    let dir = 0
    
    let pos = [0, 0]
    let maxDist = 0
    
    const obs = new Set()
    for (const obstacle of obstacles) {
        obs.add(`${obstacle[0]}-${obstacle[1]}`)
    }
    
    for (let command of commands) {
        if (command === -2) {
            dir = (dir + 1) % 4
            continue
        }
        
        if (command === -1) {
            dir = ((dir - 1) + 4) % 4
            continue
        }
        
        let prev = pos
        while (command--) {
            prev = pos
            pos = [pos[0] + dirs[dir][0], pos[1] + dirs[dir][1]]
            
            if (obs.has(`${pos[0]}-${pos[1]}`)) {
                pos = prev
                break
            }
        }
        
        maxDist = Math.max(maxDist, pos[0] ** 2 + pos[1] ** 2)
    }
    
    return maxDist
};
```

## 1282. Group the People Given the Group Size They Belong To
```javascript
// Two Pass
var groupThePeople = function(groupSizes) {
    const buckets = Array(groupSizes.length + 1).fill(0).map(a => Array(0).fill([]))
    for (const [id, groupSize] of groupSizes.entries()) {
        buckets[groupSize].push(id)
    }
    
    const result = []
    for (const [size, bucket] of buckets.entries()) {
        for (let i = 0; i < bucket.length; i += size) {
            result.push(bucket.slice(i, i + size))
        }
    }
    
    return result
};

// One Pass
/**
 * @param {number[]} groupSizes
 * @return {number[][]}
 */
var groupThePeople = function(groupSizes) {
    const result = []
    const map = {}
    
    for (let i = 0; i < groupSizes.length; i++) {
        const size = groupSizes[i]
        if (!map[size]) map[size] = []
        map[size].push(i)
        
        if (map[size].length === size) {
            result.push(map[size])
            map[size] = []
        }
    }
    
    return result
};
```

## 861. Score After Flipping Matrix
```javascript
var matrixScore = function(A) {
    for (let row = 0; row < A.length; row++) {
        if (A[row][0] === 0)
            flipRow(A, row)
    }
    
    for (let col = 1; col < A[0].length; col++) {
        if (shouldFlip(A, col)) {
            flipCol(A, col)
        }
    }
    
    let sum = 0
    for (let row = 0; row < A.length; row++) {
        sum += numFromBin(A, row)
    }
    
    return sum
};

const numFromBin = (matrix, row) => {
    let num = 0
    
    for (let col = 0; col < matrix[0].length; col++) {
        if (matrix[row][col] === 1) {
            num += Math.pow(2, matrix[0].length - col - 1)
        }
    }
    
    return num
}

const shouldFlip = (matrix, col) => {
    let zeroCount = 0
    let oneCount = 0
    for (let row = 0; row < matrix.length; row++) {
        if (matrix[row][col] === 1) {
            oneCount++
        } else {
            zeroCount++
        }
    }
    
    return oneCount < zeroCount
}

const flipRow = (matrix, row) => {
    for (let col = 0; col < matrix[0].length; col++) {
        matrix[row][col] ^= 1
    }
}

const flipCol = (matrix, col) => {
    for (let row = 0; row < matrix.length; row++) {
        matrix[row][col] ^= 1
    }
}
```

## 1296. Divide Array in Sets of K Consecutive Numbers
```javascript
var isPossibleDivide = function(nums, k) {
    if (nums.length % k !== 0) return false
    
    const counts = {}
    for (const num of nums) {
        counts[num] = 1 + (counts[num] || 0)
    }
        
    for (const key of Object.keys(counts)) {
        const num = +key
        const count = counts[num]
        
        if (count <= 0) continue
        
        const ocurr = count
        for (let i = num; i < num + k; i++) {
            counts[i] = (counts[i] || 0) - ocurr
            
            if (counts[i] < 0) return false
        }
    }
    return true
};
```

## 1253. Reconstruct a 2-Row Binary Matrix
```javascript
var reconstructMatrix = function(upper, lower, colsum) {
    const result = Array(2).fill(0).map(n => Array(colsum.length).fill(0))
    
    for (let i = 0; i < colsum.length; i++) {
        const sum = colsum[i]
        
        if (sum === 2) {
            upper--
            lower--
            result[0][i] = 1
            result[1][i] = 1
        } else if (sum === 1) {
            if (upper > lower) {
                upper--
                result[0][i] = 1
            } else {
                lower--
                result[1][i] = 1
            }
        }
        
        if (upper < 0 || lower < 0) return []
    }
    
    if (upper !== 0 || lower !== 0) return []
    return result
};
```

## 452. Minimum Number of Arrows to Burst Balloons
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function(points) {
    if (!points.length) return 0
    
    points.sort((a, b) => a[1] - b[1])
    
    let count = 1
    let prev = points[0][1]
    
    for (let i = 1; i < points.length; i++) {
        if (prev < points[i][0]) {
            count++
            prev = points[i][1]
        }
    }
    
    return count
};
```

## 846. Hand of Straights
```javascript
/**
 * @param {number[]} hand
 * @param {number} W
 * @return {boolean}
 */
var isNStraightHand = function(hand, W) {
    if (hand.length % W !== 0) return false
    
    hand.sort((a, b) => a - b)
    
    const map = {}
    for (const h of hand) {
        map[h] = 1 + (map[h] || 0) 
    }
    
    const result = []
    for (const h of hand) {
        if (map[h] === 0) continue
        
        let curr = h
        for (let i = 0; i < W; i++) {
            if (!map[curr]) return false
            
            map[curr]--
            curr++
        }
    }
    
    return true
};
```

## 1094. Car Pooling
```javascript
/**
 * @param {number[][]} trips
 * @param {number} capacity
 * @return {boolean}
 */
var carPooling = function(trips, capacity) {
    const stops = Array(1001).fill(0)
    for (const [count, start, end] of trips) {
        stops[start] += count
        stops[end] -= count
    }
    
    for (const stop of stops) {
        capacity -= stop
        if (capacity < 0) return false
    }
    
    return true
};
```

## 1338. Reduce Array Size to The Half
```javascript
var minSetSize = function(arr) {
    const counts = {}
    let maxNum = 0
    for (const num of arr) {
        counts[num] = 1 + (counts[num] || 0)
        maxNum = Math.max(maxNum, counts[num])
    }
    
    const buckets = Array(maxNum + 1).fill(0)
    for (const val of Object.values(counts)) {
        buckets[val] += 1
    }
    
    const freqs = []
    for (let i = buckets.length - 1; i >= 0; i--) {
        while (buckets[i]--) {
            freqs.push(i)
        }
    }
    
    let half = Math.floor(arr.length / 2)
    let setSize = 0
    for (const freq of freqs) {
        setSize++
        half -= freq
        
        if (half <= 0) break
    }
    
    return setSize
};
```

## 1090. Largest Values From Labels
```javascript
var largestValsFromLabels = function(values, labels, num_wanted, use_limit) {
    const pairs = []
    for (let i = 0; i < values.length; i++) {
        pairs.push([values[i], labels[i]])
    }
    
    pairs.sort((a, b) => b[0] - a[0])
    
    const labelCount = {}
    let sum = 0
    for (const [val, label] of pairs) {
        if (labelCount[label] >= use_limit) continue
        labelCount[label] = (labelCount[label] || 0) + 1
        
        sum += val
        if (--num_wanted === 0) break
    }
    
    return sum
};
```

## 930. Binary Subarrays With Sum
```javascript
// O(n) space
var numSubarraysWithSum = function(A, S) {
    const sumMap = { 0: 1 }
    let result = 0
    let currSum = 0
    
    for (const num of A) {
        currSum += num
        result += (sumMap[currSum - S] || 0)
        sumMap[currSum] = (sumMap[currSum] || 0) + 1
    }
    return result
};
```

## 360. Sort Transformed Array
```javascript
var sortTransformedArray = function(nums, a, b, c) {
    const result = Array(nums.length).fill(0)
    let start = 0
    let end = nums.length - 1
    let i = a >= 0 ? nums.length - 1 : 0
    
    while (start <= end) {
        const startNum = quad(nums[start], a, b, c)
        const endNum = quad(nums[end], a, b, c)
        if (a >= 0) {
            if (startNum >= endNum) {
                result[i--] = startNum
                start++
            } else {
                result[i--] = endNum
                end--
            }
        } else {
            if (startNum <= endNum) {
                result[i++] = startNum
                start++
            } else {
                result[i++] = endNum
                end--
            }
        }
    }
    
    return result
};

const quad = (num, a, b, c) => (a * num ** 2) + (b * num) + c
```

## 1093. Statistics from a Large Sample
```javascript
var sampleStats = function(count) {
    let min
    let max

    let sum = 0
    let numCount = 0
    
    let mode = 0
    let modeCount = 0
    
    for (let i = 0; i < count.length; i++) {
        if (!count[i]) continue
        
        if (min === undefined) min = i
        max = i
        
        sum += i * count[i]
        numCount += count[i]
        
        if (modeCount < count[i]) {
            modeCount = count[i]
            mode = i
        }
    }
    
    const mean = sum / numCount
    
    const isEven = numCount % 2 === 0
    const mid = Math.floor(numCount / 2)
    let v1 = -1
    let v2 = -1
    let k = 0
    
    for (let i = 0; i < count.length; i++) {
        if (count[i] === 0) continue
        
        k += count[i]
        
        if (isEven) {
            if (k >= mid && v1 === -1) {
                v1 = i
            }

            if (k >= mid + 1) {
                v2 = i
                break
            }
        } else {
            if (k >= mid) {
                v1 = i
                v2 = i
                break
            }            
        }
    }
    const median = (v1 + v2) / 2
    return [min, max, mean, median, mode]
};
```

## 826. Most Profit Assigning Work
```javascript
var maxProfitAssignment = function(difficulty, profit, worker) {
    const pairs = []
    for (let i = 0; i < difficulty.length; i++) {
        pairs.push([difficulty[i], profit[i]])
    }
    
    pairs.sort((a, b) => a[0] - b[0])
    worker.sort((a, b) => a - b)
    
    let sum = 0
    let i = 0
    let best = 0
    
    for (const w of worker) {
        while (i < pairs.length && pairs[i][0] <= w) {
            if (best < pairs[i][1]) {
                best = pairs[i][1]
            }
            i++
        }
        
        sum += best
    }
    
    return sum
};
```

## 986. Interval List Intersections
```javascript
/**
 * @param {number[][]} firstList
 * @param {number[][]} secondList
 * @return {number[][]}
 */
var intervalIntersection = function(firstList, secondList) {
    const result = []
    let i = 0
    let j = 0
    
    while (i < firstList.length && j < secondList.length) {
        const [firstStart, firstEnd] = firstList[i]
        const [secondStart, secondEnd] = secondList[j]
        
        const intersectionStart = Math.max(firstStart, secondStart)
        const intersectionEnd = Math.min(firstEnd, secondEnd)
        
        if (intersectionStart <= intersectionEnd) {
            const intersection = [intersectionStart, intersectionEnd]
            result.push(intersection)
        }
        
        if (firstEnd < secondEnd) {
            i++
        } else {
            j++
        }
    }
    
    return result
};
```

## 15. 3Sum
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    nums.sort((a, b) => a - b)
    
    const result = []
    
    for (let i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue
        
        let left = i + 1
        let right = nums.length - 1
        
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right]
            
            if (sum === 0) {
                result.push([nums[i], nums[left], nums[right]])
                
                while (left < right && nums[left] === nums[left + 1]) {
                    left++
                }
                
                while (left < right && nums[right] === nums[right - 1]) {
                    right--
                }
                
                left++
                right--
            } else if (sum < 0) {
                left++
            } else {
                right--
            }
        }
    }
    
    return result
};
```

## 16. 3Sum Closest
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
    nums.sort((a, b) => a - b)
    
    let closest = Infinity
    for (let i = 0; i < nums.length - 2; i++) {
        let left = i + 1
        let right = nums.length - 1
        
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right]
            
            if (sum === target) {
                return target
            }
            
            if (Math.abs(sum - target) < Math.abs(closest - target)) {
                closest = sum
            }
            
            if (sum < target) {
                left++
            } else {
                right--
            }
        }
    }
    
    return closest
};
```

## 259. 3Sum Smaller
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumSmaller = function(nums, target) {
    nums.sort((a, b) => a - b)
    
    let count = 0
    
    for (let i = 0; i < nums.length - 2; i++) {
        let left = i + 1
        let right = nums.length - 1

        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right]
            
            if (sum < target) {
                count += right - left
                left++
            } else {
                right--
            }
        }
    }
    
    return count
};
```

## 454. 4Sum II
```javascript
var fourSumCount = function(A, B, C, D) {
    const freq = {}
    let count = 0
    for (const a of A) {
        for (const b of B) {
            const sum = a + b
            freq[sum] = 1 + (freq[sum] || 0) 
        }
    }
    
    for (const c of C) {
        for (const d of D) {
            const sum = c + d
            if (freq[-sum]) count += freq[-sum]
        }
    }
    
    return count
};
```

## 713. Subarray Product Less Than K
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function(nums, k) {
    let count = 0
    let product = 1
    let left = 0
    for (let right = 0; right < nums.length; right++) {
        product *= nums[right]
        
        while (left <= right && product >= k) {
            product /= nums[left]
            left++
        }
        
        count += right - left + 1
    }
    
    return count
};
```

## 80. Remove Duplicates from Sorted Array II
```javascript
var removeDuplicates = function(nums) {
    let left = 2
    
    for (let right = 2; right < nums.length; right++) {
        if (nums[right] !== nums[left - 2]) {
            nums[left++] = nums[right]
        }
    }
    
    return left
};
```

## 1023. Camelcase Matching
```javascript
// Two Pointer
var camelMatch = function(queries, pattern) {
    return queries.map(query => isMatch(query, pattern))
};

const isMatch = (query, pattern) => {
    let p = 0
    for (const char of query) {
        if (char === pattern[p]) {
            p++
            continue
        }
        
        if (char >= 'a' && char <= 'z') {
            continue
        }
        
        return false
    }
    
    return p === pattern.length
}
```

## 379. Design Phone Directory
```javascript
// Set
/**
 * Initialize your data structure here
        @param maxNumbers - The maximum numbers that can be stored in the phone directory.
 * @param {number} maxNumbers
 */
var PhoneDirectory = function(maxNumbers) {
    this.released = new Set()
    this.max = maxNumbers
    this.next = 0
};

/**
 * Provide a number which is not assigned to anyone.
        @return - Return an available number. Return -1 if none is available.
 * @return {number}
 */
PhoneDirectory.prototype.get = function() {
    if (this.next < this.max) {
        const number = this.next++
        return number
    }
    
    const number = this.released.values().next().value
    if (number === undefined) return -1
    this.released.delete(number)
    return number
};

/**
 * Check if a number is available or not. 
 * @param {number} number
 * @return {boolean}
 */
PhoneDirectory.prototype.check = function(number) {
    return this.released.has(number) || (this.next <= number && number < this.max)
};

/**
 * Recycle or release a number. 
 * @param {number} number
 * @return {void}
 */
PhoneDirectory.prototype.release = function(number) {
    if (number < this.next) this.released.add(number)
};

/** 
 * Your PhoneDirectory object will be instantiated and called as such:
 * var obj = new PhoneDirectory(maxNumbers)
 * var param_1 = obj.get()
 * var param_2 = obj.check(number)
 * obj.release(number)
 */
```

## 1352. Product of the Last K Numbers
```javascript

var ProductOfNumbers = function() {
    this.p = []
    this.add(0)
};

/** 
 * @param {number} num
 * @return {void}
 */
ProductOfNumbers.prototype.add = function(num) {
    if (num < 1) {
        this.p = [1]
        return
    }
    
    const last = this.p[this.p.length - 1]
    this.p.push(num * last)
};

/** 
 * @param {number} k
 * @return {number}
 */
ProductOfNumbers.prototype.getProduct = function(k) {
    if (k >= this.p.length) return 0
    return this.p[this.p.length - 1] / this.p[this.p.length - k - 1]
};

/** 
 * Your ProductOfNumbers object will be instantiated and called as such:
 * var obj = new ProductOfNumbers()
 * obj.add(num)
 * var param_2 = obj.getProduct(k)
 */
```

## 1370. Increasing Decreasing String
```javascript
var sortString = function(s) {
    const charCounts = Array(26).fill(0)
    for (const char of s) {
        charCounts[posForChar(char)]++
    }
    
    const result = []
    while (result.length !== s.length) {
        for (let i = 0; i < charCounts.length; i++) {
            if (!charCounts[i]) continue
            result.push(charForPos(i))
            charCounts[i]--
        }
        
        for (let i = charCounts.length - 1; i >= 0; i--) {
            if (!charCounts[i]) continue
            result.push(charForPos(i))
            charCounts[i]--
        }
    }
    
    return result.join('')
};

const posForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
const charForPos = pos => String.fromCharCode(pos + 'a'.charCodeAt(0))
```

## 1356. Sort Integers by The Number of 1 Bits
```javascript
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var sortByBits = function(arr) {
    const memo = {}
    return arr.sort((a, b) => numOfOnes(a, memo) - numOfOnes(b, memo) || a - b)
};

const numOfOnes = (num, memo) => {
    if (memo[num]) return memo[num]
    
    let bin = num
    let count = 0
    
    while (bin) {
        count++
        bin &= bin - 1
    }
    
    memo[num] = count
    return count
}
```

## 1329. Sort the Matrix Diagonally
```javascript
/**
 * @param {number[][]} mat
 * @return {number[][]}
 */
var diagonalSort = function(mat) {
    const map = {}
    
    for (let row = 0; row < mat.length; row++) {
        for (let col = 0; col < mat[0].length; col++) {
            const diagID = row - col
            if (!map[diagID]) map[diagID] = Array(101).fill(0)
            map[diagID][mat[row][col]]++
        }
    }
    
    for (const [key, buckets] of Object.entries(map)) {
        const sortedArr = []
        for (let num = buckets.length - 1; num >= 0; num--) {
            while (buckets[num]--) {
                sortedArr.push(num)
            }
        }
        
        map[key] = sortedArr
    }
    
    for (let row = 0; row < mat.length; row++) {
        for (let col = 0; col < mat[0].length; col++) {
            const diagID = row - col
            mat[row][col] = map[diagID].pop()
        }
    }
    
    return mat
};
```

## 1333. Filter Restaurants by Vegan-Friendly, Price and Distance
```javascript
var filterRestaurants = function(restaurants, veganFriendly, maxPrice, maxDistance) {
    return restaurants
            .filter(([i, r, v, p, d]) => d <= maxDistance && p <= maxPrice && v >= veganFriendly)
            .sort((r1, r2) => r2[1] - r1[1] || r2[0] - r1[0])
            .map(r => r[0])
};
```

## 274. H-Index
```javascript
// Comparison Sort
var hIndex = function(citations) {    
    citations.sort((a, b) => b - a)
    
    let h = 0
    for (let i = 0; i < citations.length; i++) {
        if (citations[i] > i) h++
    }
    
    return h
};

// Counting Sort
var hIndex = function(citations) {
    const n = citations.length
    const counts = Array(n + 1).fill(0)
    
    for (const citation of citations) {
        if (citation >= n) {
            counts[n]++
        } else {
            counts[citation]++
        }
    }
    
    let count = 0
    for (let i = counts.length - 1; i >= 0; i--) {
        count += counts[i]
        if (count >= i) return i
    }
    
    return 0
};
```

## 1244. Design A Leaderboard
```javascript
// Object Sorting
var Leaderboard = function() {
    this.playerMap = {}
    this.scoreMap = {}
};

/** 
 * @param {number} playerId 
 * @param {number} score
 * @return {void}
 */
Leaderboard.prototype.addScore = function(playerId, score) {
    this.removeOldScore(playerId)
    this.playerMap[playerId] = score + (this.playerMap[playerId] || 0)
    this.addNewScore(playerId)
};

/** 
 * @param {number} K
 * @return {number}
 */
Leaderboard.prototype.top = function(K) {
    let sum = 0
    let count = 0
    
    const scores = Object.entries(this.scoreMap)
    for (let i = scores.length - 1; i >= 0; i--) {
        const [score, players] = scores[i]
        
        sum += +score * players.size
        count += players.size
        
        if (count > K) {
            const diff = K - count
            sum -= Math.abs(+score * diff)
            break
        }

        if (count === K) break    
    }
    
    return sum
};

/** 
 * @param {number} playerId
 * @return {void}
 */
Leaderboard.prototype.reset = function(playerId) {
    this.removeOldScore(playerId)
    this.playerMap[playerId] = 0
    this.addNewScore(playerId)
};

Leaderboard.prototype.removeOldScore = function(playerId) {
    const oldScore = this.playerMap[playerId]
    if (this.scoreMap[oldScore])
        this.scoreMap[oldScore].delete(playerId)
}

Leaderboard.prototype.addNewScore = function(playerId) {
    const newScore = this.playerMap[playerId]
    if (!this.scoreMap[newScore])
        this.scoreMap[newScore] = new Set()
    
    this.scoreMap[newScore].add(playerId)
}

/** 
 * Your Leaderboard object will be instantiated and called as such:
 * var obj = new Leaderboard()
 * obj.addScore(playerId,score)
 * var param_2 = obj.top(K)
 * obj.reset(playerId)
 */

// Quick Select

var Leaderboard = function() {
    this.map = {}
};

/** 
 * @param {number} playerId 
 * @param {number} score
 * @return {void}
 */
Leaderboard.prototype.addScore = function(playerId, score) {
    this.map[playerId] = score + (this.map[playerId] || 0)
};

/** 
 * @param {number} K
 * @return {number}
 */
Leaderboard.prototype.top = function(K) {
    const scores = Object.entries(this.map)
    const index = quickSelect(scores, scores.length - K)
    
    let sum = 0
    for (let i = index; i < scores.length; i++) {
        sum += scores[i][1]
    }
    return sum
};

/** 
 * @param {number} playerId
 * @return {void}
 */
Leaderboard.prototype.reset = function(playerId) {
    this.map[playerId] = 0
};

const quickSelect = (arr, K) => {
    let left = 0
    let right = arr.length - 1
    
    while (left !== right) {
        const randomIndex = random(left, right)
        
        swap(arr, randomIndex, right)
        
        const partitionIndex = partition(arr, left, right)
        if (partitionIndex === K) return partitionIndex
        
        if (partitionIndex > K) {
            right = partitionIndex - 1
        } else {
            left = partitionIndex + 1
        }
    }
    
    return left
}

const random = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

const partition = (arr, left, right) => {
    let pivotElement = arr[right][1]
    let i = left - 1
    
    for (let j = left; j < right; j++) {
        if (arr[j][1] <= pivotElement) {
            swap(arr, ++i, j)
        }
    }
    
    swap(arr, ++i, right)
    return i
}

/** 
 * Your Leaderboard object will be instantiated and called as such:
 * var obj = new Leaderboard()
 * obj.addScore(playerId,score)
 * var param_2 = obj.top(K)
 * obj.reset(playerId)
 */
```

## 1366. Rank Teams by Votes
```javascript
/**
 * @param {string[]} votes
 * @return {string}
 */
var rankTeams = function(votes) {
    const buckets = Array(26).fill().map(a => Array(votes[0].length).fill(0))
    for (let i = 0; i < votes.length; i++) {
       for (let j = 0; j < votes[i].length; j++) {
           const index = votes[i][j].charCodeAt(0) - 'A'.charCodeAt(0)
           buckets[index][j]++
       }
    }
    
    const teams = votes[0].split('')
    teams.sort((a, b) => {
        const aIndex = a.charCodeAt(0) - 'A'.charCodeAt(0)
        const bIndex = b.charCodeAt(0) - 'A'.charCodeAt(0)
        for (let i = 0; i < buckets[aIndex].length; i++) {
            if (buckets[aIndex][i] === buckets[bIndex][i]) {
                continue
            }
            
            return buckets[bIndex][i] - buckets[aIndex][i]
        }
        
        return a.localeCompare(b)
    })
    
    return teams.join('')
};
```

## 1387. Sort Integers by The Power Value
```javascript
/**
 * @param {number} lo
 * @param {number} hi
 * @param {number} k
 * @return {number}
 */

const dp = { 1: 0 }

var getKth = function(lo, hi, k) {
    const result = []
    
    while (lo <= hi) {
        result.push([lo, power(lo++, dp)])
    }
    
    return quickSelect(result, k - 1)
};

const power = (num, dp) => {
    if (dp[num] || num === 1)
        return dp[num]
    
    if (num % 2) {
        dp[num] = 1 + power(3 * num + 1, dp)
    } else {
        dp[num] = 1 + power(Math.floor(num / 2), dp)
    }
    
    return dp[num]
}

const quickSelect = (arr, k) => {
    let left = 0
    let right = arr.length - 1
    
    while (left !== right) {
        const randomIndex = random(left, right)
        swap(arr, randomIndex, right)
        
        const partitionIndex = partition(arr, left, right)
        if (partitionIndex === k) {
            return arr[partitionIndex][0]
        }
        
        if (partitionIndex > k) {
            right = partitionIndex - 1
        } else {
            left = partitionIndex + 1
        }
    }
    
    return arr[left][0]
}

const random = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min
}

const partition = (arr, start, end) => {
    let pivot = arr[end]
    
    let i = start - 1
    for (let j = start; j < end; j++) {
        if (arr[j][1] < pivot[1] || (arr[j][1] === pivot[1] && arr[j][0] < pivot[0])) {
            swap(arr, ++i, j)
        }
    }
    
    swap(arr, ++i, end)
    return i
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 1239. Maximum Length of a Concatenated String with Unique Characters
```javascript
/**
 * @param {string[]} arr
 * @return {number}
 */
var maxLength = function(arr) {
    const _maxLength = (i, mask) => {
        if (i >= arr.length) {
            return countOnes(mask)
        }
        
        const key = `${i}-${mask}`
        if (memo[key] !== undefined) {
            return memo[key]
        }
        
        let max = _maxLength(i + 1, mask)
        
        const currMask = getMask(arr[i])
        if (currMask && allUnique(mask, currMask)) {
            max = Math.max(max, _maxLength(i + 1, mask | currMask))
        }
        
        memo[key] = max
        return max
    }
    
    const memo = {}
    return _maxLength(0, 0)
};

const getMask = str => {
    let mask = 0
    for (const char of str) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        // if mask has repeat char return invalid mask
        if (mask & 1 << index) {
            return 0
        }

        mask |= 1 << index
    }
    
    return mask
}

const allUnique = (mask1, mask2) => {
    return countOnes(mask1 & mask2) === 0
}

const countOnes = mask => {
    let count = 0
    
    while (mask) {
        mask &= (mask - 1)
        count++
    }
    
    return count
}
```

## 1215. Stepping Numbers
```javascript
// DFS
/**
 * @param {number} low
 * @param {number} high
 * @return {number[]}
 */
var countSteppingNumbers = function(low, high) {
    const _countSteppingNumbers = num => {
        if (num >= low && num <= high) result.push(num)
        if (num > high || num === 0) return
        
        const last = num % 10
        const next = num * 10 + last + 1
        const prev = num * 10 + last - 1        
        
        if (last !== 0) _countSteppingNumbers(prev)
        if (last !== 9) _countSteppingNumbers(next)
    }
    
    const result = []
    for (let i = 0; i <= 9; i++) {
        _countSteppingNumbers(i)
    }
    
    result.sort((a, b) => a - b)
    return result
};

// BFS
/**
 * @param {number} low
 * @param {number} high
 * @return {number[]}
 */
var countSteppingNumbers = function(low, high) {
    const result = []
    const queue = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    while (queue.length) {
        const num = queue.shift()

        if (low <= num && num <= high)
            result.push(num)
        
        if (num > high || num === 0) continue
        
        const last = num % 10
        const next = num * 10 + last + 1
        const prev = num * 10 + last - 1
        
        if (last !== 0) queue.push(prev)
        if (last !== 9) queue.push(next)
    }
    
    result.sort((a, b) => a - b)
    return result
};
```

## 267. Palindrome Permutation II
```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var generatePalindromes = function(s) {
    if (!s.length) return []
    
    const charCounts = Array(128).fill(0)
    let oddCount = 0
    for (const char of s) {
        const pos = char.charCodeAt(0)
        charCounts[pos]++
        charCounts[pos] & 1 ? oddCount++ : oddCount--
    }
    
    if (oddCount > 1) return []
    
    let oddChar = ''
    for (let i = 0; i < 128; i++) {
        if (charCounts[i] & 1) {
            oddChar = String.fromCharCode(i)
            charCounts[i]--
            break
        }
    }
    
    const halfLen = Math.floor(s.length / 2)
    const result = []
    _generatePalindromes(result, charCounts, oddChar, [], halfLen)
    return result
};

const _generatePalindromes = (result, charCounts, oddChar, curr, halfLen) => {
    if (halfLen === curr.length) {
        const palindrome = [...curr, oddChar, ...curr.slice().reverse()]
        result.push(palindrome.join(''))
        return
    }
    
    for (let i = 0; i < 128; i++) {
        if (charCounts[i] <= 0) continue
        charCounts[i] -= 2
        curr.push(String.fromCharCode(i))
        _generatePalindromes(result, charCounts, oddChar, curr, halfLen)
        curr.pop()
        charCounts[i] += 2
    }
}
```

## 842. Split Array into Fibonacci Sequence
```javascript
/**
 * @param {string} S
 * @return {number[]}
 */
var splitIntoFibonacci = function(S) {
    const _splitIntoFibonacci = currIndex => {
        if (currIndex === S.length) {
            return result.length > 2 ? true : false
        }
        
        let currNum = 0
        for (let i = currIndex; i < S.length; i++) {
            if (i > currIndex && currNum === 0) return false
            
            currNum *= 10
            currNum += +S[i]
            
            if (currNum > max) return false

            if (result.length < 2 || result[result.length - 1] + result[result.length - 2] === currNum) {
                result.push(currNum)

                if (_splitIntoFibonacci(i + 1)) 
                    return true

                result.pop(currNum)
            }
        }
        
        return false
    }
    
    const max = Math.pow(2, 31) - 1
    const result = []
    _splitIntoFibonacci(0)
    return result
};
```

## 306. Additive Number
```javascript
// Approach 1
var isAdditiveNumber = function(num) {
    const _isAdditiveNumber = (list, currIndex) => {
        if (currIndex === num.length) {
            return list.length > 2
        }
        
        let currNum = 0
        for (let i = currIndex; i < num.length; i++) {
            if (i > currIndex && currNum === 0) return false
            
            currNum *= 10
            currNum += +num[i]

            if (list.length < 2 || (list[list.length - 1] + list[list.length - 2] === currNum)) {
                list.push(currNum)
                if (_isAdditiveNumber(list, i + 1)) 
                    return true
                
                list.pop()
            }
        }
        return false
    }
    
    return _isAdditiveNumber([], 0)
};

// Approach 2
/**
 * @param {string} num
 * @return {boolean}
 */
var isAdditiveNumber = function(num) {
    const _isAdditiveNumber = (curr, start) => {
        if (curr.length > 2) return
        
        if (curr.length === 2) {
            return isValid(+curr[0], +curr[1], start, num)
        }
        
        for (let i = start; i < num.length; i++) {
            const int = num.slice(start, i + 1)
            if (int.length > 1 && int[0] === '0') continue
            
            curr.push(int)
            if (_isAdditiveNumber(curr, i + 1)) {
                return true
            }
            
            curr.pop()
        }
        
        return false
    }
    
    return _isAdditiveNumber([], 0)
};

const isValid = (num1, num2, start, num) => {
    let curr = []
    let count = 0
    
    for (let i = start; i < num.length; i++) {
        curr.push(num[i])
        
        if (curr.length > 1 && curr[0] === '0') 
            return false
        
        const targetNum = num1 + num2
        const currNum = +curr.join('')
        
        if (currNum === targetNum) {
            curr = []
            num1 = num2
            num2 = targetNum
            count++
            continue
        }
        
        if (currNum > targetNum) 
            return false
    }
    
    return curr.length === 0 && count > 0
}
```

## 1342. Number of Steps to Reduce a Number to Zero
```javascript
/**
 * @param {number} num
 * @return {number}
 */
var numberOfSteps  = function(num) {
    let steps = 0
    
    while (num) {
        if (num & 1) {
            num--            
        } else {
            num >>= 1    
        }
        
        steps++
    }
    
    return steps
};
```

## 1381. Design a Stack With Increment Operation
```javascript
/**
 * @param {number} maxSize
 */
var CustomStack = function(maxSize) {
    this.maxSize = maxSize
    this.stack = []
};

/** 
 * @param {number} x
 * @return {void}
 */
CustomStack.prototype.push = function(x) {
    if (this.stack.length < this.maxSize)
        this.stack.push(x)
};

/**
 * @return {number}
 */
CustomStack.prototype.pop = function() {
    return this.stack.length ? this.stack.pop() : -1
};

/** 
 * @param {number} k 
 * @param {number} val
 * @return {void}
 */
CustomStack.prototype.increment = function(k, val) {
    for (let i = 0; i < this.stack.length && i < k; i++)
        this.stack[i] += val
};

/** 
 * Your CustomStack object will be instantiated and called as such:
 * var obj = new CustomStack(maxSize)
 * obj.push(x)
 * var param_2 = obj.pop()
 * obj.increment(k,val)
 */

 // Lazy Inc
/**
 * @param {number} maxSize
 */
var CustomStack = function(maxSize) {
    this.maxSize = maxSize
    this.stack = []
    this.inc = Array(maxSize).fill(0)
};

/** 
 * @param {number} x
 * @return {void}
 */
CustomStack.prototype.push = function(x) {
    if (this.stack.length < this.maxSize)
        this.stack.push(x)
};

/**
 * @return {number}
 */
CustomStack.prototype.pop = function() {
    const i = this.stack.length - 1
    
    if (i < 0)
        return -1
    
    if (i > 0)
        this.inc[i - 1] += this.inc[i]
    
    const result = this.stack.pop() + this.inc[i]
    this.inc[i] = 0
    return result
};

/** 
 * @param {number} k 
 * @param {number} val
 * @return {void}
 */
CustomStack.prototype.increment = function(k, val) {
    const i = Math.min(this.stack.length, k) - 1
    this.inc[i] += val
};

/** 
 * Your CustomStack object will be instantiated and called as such:
 * var obj = new CustomStack(maxSize)
 * obj.push(x)
 * var param_2 = obj.pop()
 * obj.increment(k,val)
 */
```

## 1003. Check If Word Is Valid After Substitutions
```javascript
var isValid = function(S) {
    const stack = []
    
    for (const char of S) {
        if (char === 'c') {
            if (!stack.length || stack.pop() !== 'b') return false
            if (!stack.length || stack.pop() !== 'a') return false
        } else {
            stack.push(char)
        }
    }
    
    return !stack.length
};
```

## 848. Shifting Letters
```javascript
/**
 * @param {string} S
 * @param {number[]} shifts
 * @return {string}
 */
var shiftingLetters = function(S, shifts) {
    const str = S.split('')
    
    let sum = 0
    for (let i = shifts.length - 1; i >= 0; i--) {
        sum += shifts[i]
        str[i] = letterFromShift(str[i], sum)
    }

    return str.join('')
};

const alphabet = 'abcdefghijklmnopqrstuvwxyz'

const letterFromShift = (letter, shift) => {
    const index = letter.charCodeAt(0) - 'a'.charCodeAt(0)
    const shiftIndex = (index + shift) % 26
    return alphabet[shiftIndex]
}
```

## 434. Number of Segments in a String
```javascript
var countSegments = function(s) {
    let count = 0
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== ' ' && (i === 0 || s[i - 1] === ' '))
            count++
    }
    
    return count
};
```

## 1324. Print Words Vertically
```javascript
var printVertically = function(s) {
    const matrix = s.split(' ')
    const maxCol = Math.max(...matrix.map(word => word.length))
    const result = []
    
    for (let col = 0; col < maxCol; col++) {
        const word = []
        for (let row = 0; row < matrix.length; row++) {
            !matrix[row][col] ? word.push(' ') : word.push(matrix[row][col])
        }
        
        while (word[word.length - 1] === ' ') 
            word.pop()
        
        result.push(word.join(''))
    }
    
    return result
};
```

## 1374. Generate a String With Characters That Have Odd Counts
```javascript
var generateTheString = function(n) {    
    return n & 1 ? 'a'.repeat(n) : 'a'.repeat(n - 1) + 'b'
};
```

## 1332. Remove Palindromic Subsequences
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var removePalindromeSub = function(s) {
    if (!s.length) return 0
    return isPalindrome(s) ? 1 : 2
};

const isPalindrome = s => {
    let left = 0
    let right = s.length - 1
    
    while (left < right) {
        if (s[left] !== s[right]) {
            return false
        }
        
        left++
        right--
    }
    
    return true
}
```

## 238. Product of Array Except Self
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    const result = new Array(nums.length).fill(1)
    
    let product = 1
    for (let i = 0; i < nums.length; i++) {
        result[i] *= product
        product *= nums[i]
    }
    
    product = 1
    for (let i = nums.length - 1; i >= 0; i--) {
        result[i] *= product
        product *= nums[i]
    } 
    
    return result
};
```

## 276. Paint Fence
```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var numWays = function(n, k) {
    if (n === 0) return 0
    if (n === 1) return k
    
    let same = k
    let different = k * (k - 1)
    
    let prevSame = same
    let prevDifferent = different
    
    for (let i = 3; i <= n; i++) {
        same = prevDifferent
        different = (prevSame + prevDifferent) * (k - 1)
        prevSame = same
        prevDifferent = different
    }
    
    return same + different
};
```

## 523. Continuous Subarray Sum
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
    const map = { 0: -1 }
    
    let sum = 0
    for (const [index, num] of nums.entries()) {
        sum += num
        
        if (k) sum %= k
        
        if (map[sum] !== undefined) {
            if (index - map[sum] > 1) return true
        } else {
            map[sum] = index
        }
    } 
    
    return false
};
```

## 746. Min Cost Climbing Stairs
```javascript
// Top Down DP
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    const minCost = index => {
        if (index >= cost.length) 
            return 0
        
        if (memo[index] !== undefined)
            return memo[index]
        
        memo[index] = cost[index] + Math.min(minCost(index + 1), 
                                             minCost(index + 2))
        
        return memo[index]
    }
    
    const memo = Array(cost.length).fill()
    return Math.min(minCost(0), minCost(1))
};

// Bottom-Up DP
var minCostClimbingStairs = function(cost) {
    let step1 = cost[0]
    let step2 = cost[1]
    
    for (let i = 2; i < cost.length; i++) {
        const curr = cost[i] + Math.min(step1, step2)
        step1 = step2
        step2 = curr
    }
    
    return Math.min(step1, step2)
};
```

## 1025. Divisor Game
```javascript
// Top Down DP
/**
 * @param {number} N
 * @return {boolean}
 */
var divisorGame = function(N) {
    const _divisorGame = N => {
        if (N <= 1) return false
        if (memo[N] !== undefined) return memo[N]
        
        for (let x = 1; x <= N / 2; x++) {
            if (N % x === 0) {
                if (!_divisorGame(N - x)) {
                    memo[N] = true
                    return true
                }
            }
        }
        
        memo[N] = false
        return false
    }
    
    const memo = new Array(N + 1)
    return _divisorGame(N)
};

// Bottom Up DP
/**
 * @param {number} N
 * @return {boolean}
 */
var divisorGame = function(N) {
    const dp = Array(N + 1).fill(false)
    dp[0] = false
    dp[1] = false
    
    for (let n = 2; n <= N; n++) {
        for (let x = 1; x <= n / 2; x++) {
            if (n % x === 0 && !dp[n - x]) {
                dp[n] = true
                break
            }
        }
    }
    
    return dp[N]
};
```

## 64. Minimum Path Sum
```javascript
// Top Down DP
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    const _minPathSum = (row, col) => {    
        if (row >= m || col >= n)
            return Infinity
            
        if (row === m - 1 && col === n - 1)
            return grid[row][col]
        
        if (memo[row][col])
            return memo[row][col]
        
        memo[row][col] = grid[row][col] + Math.min(_minPathSum(row + 1, col), _minPathSum(row, col + 1))
        return memo[row][col]
    }
    
    if (!grid.length) return 0
    
    const m = grid.length
    const n = grid[0].length
    const memo = Array(m).fill(0).map(n => Array(n).fill(0))
    return _minPathSum(0, 0)
};

// Bottom Up DP N^2 Space
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    const r = grid.length
    const c = grid[0].length
    const dp = Array(r).fill(0).map(n => Array(c).fill(0))
    dp[0][0] = grid[0][0]
    
    for (let row = 1; row < r; row++) {
        dp[row][0] = grid[row][0] + dp[row - 1][0]
    }
    
    for (let col = 1; col < c; col++) {
        dp[0][col] = grid[0][col] + dp[0][col - 1]
    }
    
    for (let row = 1; row < r; row++) {
        for (let col = 1; col < c; col++) {
            dp[row][col] = grid[row][col] + Math.min(dp[row - 1][col], dp[row][col - 1])
        }
    }
    
    return dp[r - 1][c - 1]
};

// Bottom Up DP N Space
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    const r = grid.length
    const c = grid[0].length
    const dp = Array(r).fill(0)
    
    for (let row = 0; row < r; row++) {
        for (let col = 0; col < c; col++) {
            if (row === 0 && col === 0) {
                dp[col] = grid[row][col]
            } else if (row === 0) {
                dp[col] = grid[row][col] + dp[col - 1]
            } else if (col === 0) {
                dp[col] = grid[row][col] + dp[0]
            } else {
                dp[col] = grid[row][col] + Math.min(dp[col], dp[col - 1])
            }
        }
    }
    
    return dp[c - 1]
};

// Bottom Up DP Constant Space
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    const r = grid.length
    const c = grid[0].length
    
    for (let row = 0; row < r; row++) {
        for (let col = 0; col < c; col++) {
            if (row === 0 && col === 0) {
                continue
            } else if (row === 0) {
                grid[row][col] += grid[row][col - 1]
            } else if (col === 0) {
                grid[row][col] += grid[row - 1][col]
            } else {
                grid[row][col] += Math.min(grid[row - 1][col], grid[row][col - 1])
            }
        }
    }
    
    return grid[r - 1][c - 1]
};
```

## 62. Unique Paths
```javascript
// Top Down DP
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    const _uniquePaths = (row, col) => {        
        if (row >= n || col >= m)
            return 0
        
        if (row === n - 1 && col === m - 1)
            return 1
        
        if (memo[row][col])
            return memo[row][col]
        
        memo[row][col] = _uniquePaths(row + 1, col) + _uniquePaths(row, col + 1)
        return memo[row][col]
    }
    
    const memo = Array(n).fill(0).map(n => Array(m).fill(0))
    return _uniquePaths(0, 0)
};

// Bottom Up DP N^2 Space
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    const dp = Array(n).fill(0).map(a => Array(m).fill(0))

    for (let row = 0; row < n; row++) {
        dp[row][0] = 1
    }
    
    for (let col = 0; col < m; col++) {
        dp[0][col] = 1
    }
    
    for (let row = 1; row < n; row++) {
        for (let col = 1; col < m; col++) {
            dp[row][col] = dp[row - 1][col] + dp[row][col - 1]
        }
    }
    
    return dp[n - 1][m - 1]
};

// Bottom UP DP N Space
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    let prev = new Array(n).fill(1)
    
    for (let row = 1; row < m; row++) {
        const curr = new Array(n).fill(1)
        for (let col = 1; col < n; col++) {
            curr[col] = prev[col] + curr[col - 1]
        }
        
        prev = curr
    }
    
    return prev[n - 1]
};
```

## 63. Unique Paths II
```javascript
// Top Down DP
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    const _uniquePathsWithObstacles = (row, col) => {
        if (row < 0 || row >= m || col < 0 || col >= n) {
            return 0
        }
        
        if (obstacleGrid[row][col] === 1) {
            return 0
        }
        
        if (row === m - 1 && col === n - 1) {
            return 1
        }
        
        if (memo[row][col] !== undefined) {
            return memo[row][col]
        }
        
        let count = 0
        count += _uniquePathsWithObstacles(row + 1, col)
        count += _uniquePathsWithObstacles(row, col + 1)
        memo[row][col] = count
        return count
    }
    
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const memo = new Array(m).fill().map(a => new Array(n))
    return _uniquePathsWithObstacles(0, 0)
};

// Bottom Up DP N^2 Space
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const dp = Array(m).fill(0).map(a => Array(n).fill(0))
    
    for (let row = 0; row < m; row++) {
        if (obstacleGrid[row][0] === 1) break
        dp[row][0] = 1
    }
    
    for (let col = 0; col < n; col++) {
        if (obstacleGrid[0][col] === 1) break
        dp[0][col] = 1
    }
    
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            if (obstacleGrid[row][col] === 1) continue
            dp[row][col] = dp[row - 1][col] + dp[row][col - 1]
        }
    }
    
    
    return dp[m - 1][n - 1]
};

// Bottom Up DP N space
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(grid) {
    const r = grid.length
    const c = grid[0].length
    const dp = Array(r).fill(0)
    
    if (grid[0][0]) return 0
    
    for (let row = 0; row < r; row++) {
        for (let col = 0; col < c; col++) {
            if (!row && !col) {
                dp[col] = 1
            } else if (!row) {
                dp[col] = grid[row][col] ? 0 : dp[col - 1]
            } else if (!col) {
                dp[col] = grid[row][col] ? 0 : dp[0]
            } else {
                dp[col] = grid[row][col] ? 0 : dp[col] + dp[col - 1]
            }
        }
    }
    
    return dp[c - 1]
};
```

## 91. Decode Ways
```javascript
// Top Down DP
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    const _numDecodings = i => {
        if (i === s.length) 
            return 1
        
        if (memo[i]) 
            return memo[i]
        
        let ways = 0
        if (s[i] > 0) 
            ways = _numDecodings(i + 1)

        const num = s.slice(i, i + 2)
        if (num > 9 && num < 27)
            ways += _numDecodings(i + 2)
        
        memo[i] = ways
        return ways
    }
    
    const memo = {}
    return _numDecodings(0)
};

// Bottom Up DP O(n) space
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    if (!s.length) return 0
    
    const dp = Array(s.length + 1).fill(0)
    dp[0] = 1
    dp[1] = s[0] == 0 ? 0 : 1
    
    for (let i = 2; i <= s.length; i++) {
        const oneDigit = s[i - 1]
        const twoDigit = s.slice(i - 2, i)
        
        if (oneDigit > 0)
            dp[i] += dp[i - 1]
        
        if (twoDigit >= 10 && twoDigit <= 26)
            dp[i] += dp[i - 2]
        
    }
    
    return dp[dp.length - 1]
};

// Bottom Up DP O(1) space
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    if (!s.length) return 0
    
    let prevWays = 1
    let currWays = s[0] == 0 ? 0 : 1
    
    for (let i = 1; i < s.length; i++) {
        let numOfWays = 0
        
        const oneDigit = +s[i]
        if (oneDigit > 0)
            numOfWays += currWays
        
        const twoDigit = +s.slice(i - 1, i + 1)
        if (twoDigit >= 10 && twoDigit <= 26)
            numOfWays += prevWays
        
        prevWays = currWays
        currWays = numOfWays
    }
    
    return currWays
};
```

## 1277. Count Square Submatrices with All Ones
```javascript
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var countSquares = function(matrix) {
    const m = matrix.length
    const n = matrix[0].length
    
    const dp = Array(m).fill(0).map(arr => Array(n).fill(0))
    let count = 0
    
    for (let row = 0; row < m; row++) {
        dp[row][0] = matrix[row][0]
        count += dp[row][0]
    }
    
    for (let col = 1; col < n; col++) {
        dp[0][col] = matrix[0][col]
        count += dp[0][col]
    }
    
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            if (matrix[row][col] === 0) continue
            dp[row][col] = Math.min(dp[row - 1][col], dp[row][col - 1], dp[row - 1][col - 1]) + 1
            count += dp[row][col]
        }
    }
    
    return count
};
```

## 370. Range Addition
```javascript
/**
 * @param {number} length
 * @param {number[][]} updates
 * @return {number[]}
 */
var getModifiedArray = function(length, updates) {
    const arr = Array(length).fill(0)
    
    for (const [start, end, inc] of updates) {
        arr[start] += inc
        
        if (end < length - 1)
            arr[end + 1] -= inc
    }
    
    for (let i = 1; i < arr.length; i++) {
        arr[i] += arr[i - 1]
    }
    
    return arr
};
```

## 598. Range Addition II
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @param {number[][]} ops
 * @return {number}
 */
var maxCount = function(m, n, ops) {
    let rowMin = m
    let colMin = n
    
    for (const [row, col] of ops) {
        rowMin = Math.min(rowMin, row)
        colMin = Math.min(colMin, col)
    }
    
    return rowMin * colMin
};
```

## 307. Range Sum Query - Mutable
```javascript
// Segment Tree
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.tree = new SegmentTree(nums, ((a, b) => a + b))
};

/** 
 * @param {number} i 
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
    this.tree.update(val, i)
};

/** 
 * @param {number} i 
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
    return this.tree.query(i, j)
};

/** 
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */

class SegmentTree {
    constructor(array, merge) {
        this.n = array.length
        this.merge = merge
        this.elements = new Array(4 * this.n).fill(0)
        
        this.buildTree(array)
    }
    
    buildTree(array) {
        const _buildTree = (treeIndex, rangeStart, rangeEnd) => {
            if (rangeStart > rangeEnd) {
                return
            }
            
            if (rangeStart === rangeEnd) {
                this.elements[treeIndex] = array[rangeStart]
                return
            }

            const rangeMid = Math.floor((rangeEnd - rangeStart) / 2) + rangeStart
            _buildTree(2 * treeIndex + 1, rangeStart, rangeMid)
            _buildTree(2 * treeIndex + 2, rangeMid + 1, rangeEnd)

            this.elements[treeIndex] = this.merge(this.elements[2 * treeIndex + 1], 
                                                  this.elements[2 * treeIndex + 2])
        }
        
        _buildTree(0, 0, this.n - 1)
    }
    
    query(queryStart, queryEnd) {
        const _query = (treeIndex, rangeStart, rangeEnd) => {
            // Total Overlap
            if (queryStart <= rangeStart && rangeEnd <= queryEnd) {
                return this.elements[treeIndex]
            }
            
            // No Overlap
            if (queryStart > rangeEnd || queryEnd < rangeStart) {
                return 0
            }
            
            // Partial Overlap
            const rangeMid = Math.floor((rangeEnd - rangeStart) / 2) + rangeStart
            const queryLeft = _query(2 * treeIndex + 1, rangeStart, rangeMid)
            const queryRight = _query(2 * treeIndex + 2, rangeMid + 1, rangeEnd)
            
            return this.merge(queryLeft, queryRight)
        }
        
        return _query(0, 0, this.n - 1)
    }
    
    update(value, arrayIndex) {
        const _update = (treeIndex, rangeStart, rangeEnd) => {
            if (arrayIndex < rangeStart || arrayIndex > rangeEnd) {
                return
            }
            
            if (rangeStart === rangeEnd) {
                this.elements[treeIndex] = value
                return
            }
            
            const rangeMid = Math.floor((rangeEnd - rangeStart) / 2) + rangeStart
            _update(2 * treeIndex + 1, rangeStart, rangeMid)
            _update(2 * treeIndex + 2, rangeMid + 1, rangeEnd)

            this.elements[treeIndex] = this.merge(this.elements[2 * treeIndex + 1], 
                                                  this.elements[2 * treeIndex + 2])
        }
        
        _update(0, 0, this.n - 1)
    }
}

// Fenwick Tree
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.fenwickTree = new FenwickTree(nums)
};

/** 
 * @param {number} i 
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
    return this.fenwickTree.update(i, val)
};

/** 
 * @param {number} i 
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
    return this.fenwickTree.rangeQuery(i, j)
};

/** 
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */

class FenwickTree {
    constructor(nums) {
        this.nums = nums
        this.tree = [0, ...nums]
        
        for (let i = 1; i < this.tree.length; i++) {
            const parent = i + this.lsb(i)
            if (parent < this.tree.length) {
                this.tree[parent] += this.tree[i]
            }
        }
    }
    
    update(i, val) {
        const diff = val - this.nums[i]
        this.nums[i] = val
        
        i++
        while (i < this.tree.length) {
            this.tree[i] += diff
            i += this.lsb(i)
        }
    }
    
    rangeQuery(i, j) {
        return this.query(j) - this.query(i - 1)
    }
    
    query(i) {
        let sum = 0
        
        i++
        while (i > 0) {
            sum += this.tree[i]
            i -= this.lsb(i)
        }
        return sum
    }
    
    lsb(i) {
        return i & -i
    }
}
```

## 836. Rectangle Overlap
```javascript
// https://leetcode.com/problems/rectangle-overlap/discuss/185809/Template%3A-Interval-Overlapping
/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */
var isRectangleOverlap = function(rec1, rec2) {
    return Math.min(rec2[2], rec1[2]) > Math.max(rec1[0], rec2[0]) &&
           Math.min(rec1[3], rec2[3]) > Math.max(rec2[1], rec1[1])
};
```

## 201. Bitwise AND of Numbers Range
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var rangeBitwiseAnd = function(m, n) {
    let count = 0
    
    while (m !== n) {
        m >>= 1
        n >>= 1
        count++
    }
    
    return m << count
};

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var rangeBitwiseAnd = function(m, n) {
    while (m < n) {
        n &= (n - 1)
    }
    return n
};
```

## 1310. XOR Queries of a Subarray
```javascript
/**
 * @param {number[]} arr
 * @param {number[][]} queries
 * @return {number[]}
 */
var xorQueries = function(arr, queries) {
    const prefix = Array(arr.length).fill(0)
    
    for (const [index, ele] of arr.entries()) {
        prefix[index] = ele ^ prefix[index - 1]
    }
    
    const ans = []
    for (const [left, right] of queries) {
        ans.push(prefix[right] ^ prefix[left - 1])
    }
    
    return ans
};
```

## 1404. Number of Steps to Reduce a Number in Binary Representation to One
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numSteps = function(s) {
    const num = s.split('')
    let steps = 0
    
    outer : while (num.length > 1) {
        steps++
        
        if (num[num.length - 1] === '0') {
            num.pop()
        } else {
            for (let i = num.length - 1; i >= 0; i--) {
                if (num[i] === '1') {
                    num[i] = '0'
                } else {
                    num[i] = '1'
                    continue outer
                }
            }
            num.unshift('1')
        }
    }
    
    return steps
};
```

## 187. Repeated DNA Sequences
```javascript
// Bit Manipulation when L <= 16
/**
 * @param {string} s
 * @return {string[]}
 */
var findRepeatedDnaSequences = function(s, l = 10) {
    const seq = s.split('').map(char => charToNum(char))
    const result = new Set()
    const seen = new Set()
    
    let mask = 0
    for (let i = 0; i < l; i++) {
        mask <<= 2
        mask |= seq[i]
    }
    
    for (let i = l; i < s.length + 1; i++) {
        if (seen.has(mask)) {
            result.add(s.slice(i - l, i))
        } else {
            seen.add(mask)
        }
        
        mask <<= 2
        mask |= seq[i]
        mask &= ~(-1 << (2 * l))
    }
    
    return Array.from(result)
};

const charToNum = char => {
    switch(char) {
        case 'A':
            return 0
        case 'C':
            return 1
        case 'G':
            return 2
        case 'T':
            return 3
    }
}
```

## 1318. Minimum Flips to Make a OR b Equal to c
```javascript
/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */
var minFlips = function(a, b, c) {
    let flips = 0
    
    while (a || b || c) {
        const x = a & 1
        const y = b & 1
        const z = c & 1
        
        if ((x | y) !== z) {
            flips += (x && y) ? 2 : 1
        }
        
        a >>= 1
        b >>= 1
        c >>= 1
    }
        
    return flips
};
```

## 477. Total Hamming Distance
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
    let count = 0
    
    for (let i = 0; i < 32; i++) {
        let zeroCount = 0
        let oneCount = 0
        
        const mask = 1 << i
        for (const num of nums) {
            if (num & mask) {
                oneCount++
            } else {
                zeroCount++
            }
        }
        
        count += oneCount * zeroCount
    }
    
    return count
};
```

## 1297. Maximum Number of Occurrences of a Substring
```javascript
// Hash Map
/**
 * @param {string} s
 * @param {number} maxLetters
 * @param {number} minSize
 * @param {number} maxSize
 * @return {number}
 */
var maxFreq = function(s, maxLetters, minSize, maxSize) {
    const freq = {}
    let max = 0
    
    for (let i = 0; i < s.length - minSize + 1; i++) {
        const str = s.slice(i, i + minSize)
        if (isValid(str, maxLetters)) {
            freq[str] = 1 + (freq[str] || 0)
            max = Math.max(max, freq[str])
        }
    }
    
    return max
};

const isValid = (str, maxLetters) => {
    const set = new Set(str)
    return set.size <= maxLetters
}

// BitMap
/**
 * @param {string} s
 * @param {number} maxLetters
 * @param {number} minSize
 * @param {number} maxSize
 * @return {number}
 */
var maxFreq = function(s, maxLetters, minSize, maxSize) {
    const freq = {}
    let max = 0
    
    outer : for (let i = 0; i < s.length - minSize + 1; i++) {
        const str = s.slice(i, i + minSize)
        let bitMap = 0
        let uniqueCharCount = 0
        
        for (const char of str) {
            const pos = char.charCodeAt(0) - 'a'.charCodeAt(0)
            
            const isSet = bitMap & 1 << pos
            if (!isSet)
                uniqueCharCount++
            
            if (uniqueCharCount > maxLetters)
                continue outer
            
            bitMap |= 1 << pos
        }
        
        freq[str] = 1 + (freq[str] || 0)
        max = Math.max(max, freq[str])   
    }
    
    return max
};
```

## 1169. Invalid Transactions
```javascript
/**
 * @param {string[]} transactions
 * @return {string[]}
 */
var invalidTransactions = function(transactions) {
    const invalid = new Set()

    transactions.sort((a, b) => {
        const aName = a.split(',')[0]
        const bName = b.split(',')[0]
        
        if (aName < bName) return -1
        if (aName > bName) return 1
        return 0
    })
    
    for (let i = 0; i < transactions.length; i++) {
        const [name, time, amount, city] = transactions[i].split(',')
        
        if (amount > 1000)
            invalid.add(transactions[i])
        
        for (let j = i + 1; j < transactions.length; j++) {    
            const [jName, jTime, jAmount, jCity] = transactions[j].split(',')
            
            if (jName !== name) break
            
            if (name === jName && Math.abs(time - jTime) <= 60 && city !== jCity) {
                invalid.add(transactions[i])
                invalid.add(transactions[j])
            }
        }
    }
    
    return Array.from(invalid)
};
```

## 1399. Count Largest Group
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var countLargestGroup = function(n) {
    const memo = Array(10_001).fill(0)
    const map = {}
    let max = 0
    let count = 0
    
    for (let num = 1; num <= n; num++) {
        const sum = sumOfDigits(num, memo)

        if (!map[sum]) map[sum] = []
        map[sum].push(num)

        if (max < map[sum].length) {
            max = map[sum].length
            count = 0
        }

        if (map[sum].length === max) count++
    }
    
    return count
};

const sumOfDigits = (num, memo) => {
    if (memo[num]) return memo[num]
    
    let sum = 0
    
    while (num) {
        const digit = num % 10
        sum += digit
        num = Math.floor(num / 10)
    }
    
    memo[num] = sum
    return memo[num]
}
```

## 157. Read N Characters Given Read4
```javascript
/**
 * Definition for read4()
 * 
 * @param {character[]} buf Destination buffer
 * @return {number} The number of actual characters read
 * read4 = function(buf) {
 *     ...
 * };
 */

/**
 * @param {function} read4()
 * @return {function}
 */
var solution = function(read4) {
    /**
     * @param {character[]} buf Destination buffer
     * @param {number} n Number of characters to read
     * @return {number} The number of actual characters read
     */
    return function(buf, n) {
        let idx = 0
        
        while (n > 0) {
            let buf4 = Array(4).fill('')
            let count = read4(buf4)
            
            if (count === 0) 
                return idx
            
            const end = Math.min(count, n)
            for (let i = 0; i < end; i++) {
                buf[idx] = buf4[i]
                idx++
                n--
            }
        }
        
        return idx
    };
};
```

## 1299. Replace Elements with Greatest Element on Right Side
```javascript
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var replaceElements = function(arr) {
    let max = -1
    for (let i = arr.length - 1; i >= 0; i--) {
        const temp = arr[i]
        arr[i] = max
        max = Math.max(temp, max)
    }
    
    return arr
};
```

## 884. Uncommon Words from Two Sentences
```javascript
/**
 * @param {string} A
 * @param {string} B
 * @return {string[]}
 */
var uncommonFromSentences = function(A, B) {
    const map = {}
    
    for (const a of A.split(' ')) {
        map[a] = 1 + (map[a] || 0)
    }
    
    for (const b of B.split(' ')) {
        map[b] = 1 + (map[b] || 0)
    }
    
    const uncommon = []
    for (const [word, count] of Object.entries(map)) {
        if (count === 1)
            uncommon.push(word)
    }
    
    return uncommon
};
```

## 1200. Minimum Absolute Difference
```javascript
/**
 * @param {number[]} arr
 * @return {number[][]}
 */
var minimumAbsDifference = function(arr) {
    arr.sort((a, b) => a - b)

    let result = []
    let minDiff = Number.MAX_VALUE
    
    for (let i = 0; i < arr.length - 1; i++) {
        const diff = arr[i + 1] - arr[i]
        
        if (diff < minDiff) {
            minDiff = diff
            result = [[arr[i], arr[i + 1]]]
        } else if (diff === minDiff) {
            result.push([arr[i], arr[i + 1]])
        }
    }
    
    return result
};
```

## 908. Smallest Range I
```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var smallestRangeI = function(A, K) {
    let min = Number.MAX_VALUE
    let max = -Number.MAX_VALUE
    
    for (const a of A) {
        min = Math.min(a, min)
        max = Math.max(a, max)
    }
    
    return Math.max((max - K) - (min + K), 0)
};
```

## 1365. How Many Numbers Are Smaller Than the Current Number
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var smallerNumbersThanCurrent = function(nums) {
    const buckets = Array(101).fill(0)
    
    for (const num of nums) {
        buckets[num]++
    }
    
    let count = 0
    for (let i = 0; i < buckets.length; i++) {
        const temp = buckets[i]
        buckets[i] = count
        count += temp
    }
    
    return nums.map(num => buckets[num])
}
```

## 1134. Armstrong Number
```javascript
/**
 * @param {number} N
 * @return {boolean}
 */
var isArmstrong = function(N) {
    let k = 0
    
    let num = N
    while (num) {
        num = Math.floor(num / 10)
        k++
    }
    
    let sum = 0
    num = N
    while (num) {
        const digit = num % 10
        sum += (digit ** k)
        num = Math.floor(num / 10)
    }
    
    return N === sum
};

// Log base 10 to n to get k
/**
 * @param {number} N
 * @return {boolean}
 */
var isArmstrong = function(N) {
    const k = Math.floor(Math.log10(N)) + 1
    let sum = 0
    
    let num = N
    while (num && sum < N) {
        const digit = num % 10
        const result = digit ** k
        sum += result
        num = Math.floor(num / 10)
    }
    
    return sum === N
};
```

## 1309. Decrypt String from Alphabet to Integer Mapping
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var freqAlphabets = function(s) {
    const result = []
    const map = ' abcdefghijklmnopqrstuvwxyz'
    
    let i = 0
    while (i < s.length) {
       if (s[i + 2] === '#') {
           result.push(map[s[i] + s[i+1]])
           i += 3
        } else {
            result.push(map[s[i]])
            i++    
        }
    }
    
    return result.join('')
};
```

## 1304. Find N Unique Integers Sum up to Zero
```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var sumZero = function(n) {
    const result = []
    
    if (n & 1) {
        result.push(0)
        n--
    }
    
    for (let i = 1; i <= n / 2; i++) {
        result.push(i, -i)
    }
    
    return result
};
```

## 1380. Lucky Numbers in a Matrix
```javascript
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var luckyNumbers  = function(matrix) {
    if (!matrix.length) return []
    
    const m = matrix.length
    const n = matrix[0].length
    
    const minRows = Array(m).fill(Number.MAX_VALUE)
    const maxCols = Array(n).fill(-Number.MAX_VALUE)
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            minRows[row] = Math.min(minRows[row], matrix[row][col])
            maxCols[col] = Math.max(maxCols[col], matrix[row][col])
        }
    }

    const result = []
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (minRows[row] === maxCols[col]) {
                result.push(minRows[row])
            }
        }
    }
    
    return result
};
```

## 1413. Minimum Value to Get Positive Step by Step Sum
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var minStartValue = function(nums) {
    let start = 1
    let sum = 0
    
    for (const num of nums) {
        sum += num
        
        if (sum < 1)
            start = Math.max(1 - sum, start)
    }
    
    return start
};
```

## 1331. Rank Transform of an Array
```javascript
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var arrayRankTransform = function(arr) {
    const sorted = arr.slice().sort((a, b) => a - b)
    const map = {}
    
    let rank = 1
    for (const s of sorted) {
        if (map[s]) continue
        map[s] = rank
        rank++
    }
    
    return arr.map(num => map[num])
};
```

## 1009. Complement of Base 10 Integer
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var bitwiseComplement = function(N) {
    if (N === 0) return 1
    
    let num = 0
    let pos = 0
    
    while (N) {
        const bit = N & 1
        num |= (!bit << pos++)
        N >>= 1
    }
    
    return num
}
```

## 1417. Reformat The String
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reformat = function(s) {
    const digits = []
    const letters = []
    
    for (const char of s) {
        if (isNaN(+char)) {
            letters.push(char)
        } else {
            digits.push(char)
        }
    }
    
    if (Math.abs(digits.length - letters.length) > 1)
        return ''
    
    const max = digits.length > letters.length ? digits : letters
    const min = digits.length > letters.length ? letters : digits
    
    const result = []
    for (let i = 0; i < s.length; i += 2) {
        result.push(max.pop())
        result.push(min.pop())
    }
    
    return result.join('')
};
```

## 1346. Check If N and Its Double Exist
```javascript
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var checkIfExist = function(arr) {
    const seen = new Set()
    
    for (const num of arr) {
        if (seen.has(num*2) || seen.has(num/2)) {
            return true
        }
        
        seen.add(num)
    }
    return false
};
```

## 594. Longest Harmonious Subsequence
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLHS = function(nums) {
    const counts = {}
    let max = 0
    
    for (const num of nums) {
        counts[num] = 1 + (counts[num] || 0)
        max = Math.max(max, 
                       counts[num] + counts[num - 1] || 0, 
                       counts[num] + counts[num + 1] || 0)
    }
    
    return max
};
```

## 1317. Convert Integer to the Sum of Two No-Zero Integers
```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var getNoZeroIntegers = function(n) {
    for (let i = 1; i <= Math.ceil(n / 2); i++) {
        if (hasZero(i) || hasZero(n - i))
            continue
        
        return [i, n - i]
    }
};

const hasZero = num => {
    if (num === 0) return true
    
    while (num) {
        if (num % 10 === 0) 
            return true
        
        num = Math.floor(num / 10)
    }
    
    return false
}
```

## 1424. Diagonal Traverse II
```javascript
/**
 * @param {number[][]} nums
 * @return {number[]}
 */
var findDiagonalOrder = function(nums) {
    const levels = []
    
    for (let row = 0; row < nums.length; row++) {
        for (let col = 0; col < nums[row].length; col++) {
            const index = row + col
            if (!levels[index]) 
                levels[index] = []
            
            levels[index].push(nums[row][col])
        }
    }
    
    const result = []
    for (let i = 0; i < levels.length; i++) {
        for (let j = levels[i].length - 1; j >= 0; j--) {
            result.push(levels[i][j])
        }
    }
    
    return result
};
```

## 807. Max Increase to Keep City Skyline
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxIncreaseKeepingSkyline = function(grid) {
    const m = grid.length
    const n = grid[0].length
    
    const maxRow = Array(m).fill(0)
    const maxCol = Array(n).fill(0)
    
    let sum = 0
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            maxRow[row] = Math.max(maxRow[row], grid[row][col])
            maxCol[col] = Math.max(maxCol[col], grid[row][col])
        }
    }
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            sum += Math.min(maxRow[row], maxCol[col]) - grid[row][col]
        }
    }
    
    return sum
};
```

## 1403. Minimum Subsequence in Non-Increasing Order
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minSubsequence = function(nums) {
    const buckets = Array(101).fill(0)
    let totalSum = 0
    for (const num of nums) {
        buckets[num]++
        totalSum += num
    }
    
    const result = []
    let sum = 0
    for (let i = buckets.length - 1; i >= 0; i--) {
        if (buckets[i] === 0) continue
        
        while (buckets[i]--) {
            result.push(i)
            sum += i
            totalSum -= i
            
            if (sum > totalSum) return result
        }
    }
    
    return result
};
```

## 893. Groups of Special-Equivalent Strings
```javascript
/**
 * @param {string[]} A
 * @return {number}
 */
var numSpecialEquivGroups = function(A) {
    const groups = new Set()
    
    for (const a of A) {
        const word = sort(a)
        groups.add(word)
    }
    
    return groups.size
};

const sort = str => {
    const odds = Array(26).fill(0)
    const evens = Array(26).fill(0)
    
    for (let i = 0; i < str.length; i++) {
        const index = str[i].charCodeAt(0) - 'a'.charCodeAt(0)
        if (i % 2 === 0) {
            evens[index]++
        } else {
            odds[index]++
        }
    }
    
    return [...odds, ...evens].join('')
}
```

## 575. Distribute Candies
```javascript
/**
 * @param {number[]} candies
 * @return {number}
 */
var distributeCandies = function(candies) {
    const kinds = new Set(candies)
    const count = candies.length / 2
    return Math.min(kinds.size, count)
};
```

## 1243. Array Transformation
```javascript
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var transformArray = function(arr) {
    let changed = true
    
    while (changed) {
        const temp = arr.slice()
        changed = false
        
        for (let i = 1; i < arr.length - 1; i++) {    
            if (arr[i] < arr[i-1] && arr[i] < arr[i+1]) {
                temp[i]++
                changed = true
            } else if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
                temp[i]--
                changed = true
            }
        }
        
        arr = temp
    }
    
    return arr
};
```

## 661. Image Smoother
```javascript
// O(m) space
/**
 * @param {number[][]} M
 * @return {number[][]}
 */
var imageSmoother = function(M) {
    const r = M.length
    const c = M[0].length
    
    const result = Array(r).fill(0).map(a => Array(c).fill([])) 
    
    for (let row = 0; row < r; row++) {
        for (let col = 0; col < c; col++) {
            result[row][col] = smooth(M, row, col, r, c)
        }
    }
    
    return result
};

const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1], [1, 1]]

const smooth = (grid, row, col, r, c) => {
    let sum = grid[row][col]
    let count = 1
    
    for (const [dRow, dCol] of dirs) {
        const newRow = row + dRow
        const newCol = col + dCol
        
        if (newRow < 0 || newRow >= r || newCol < 0 || newCol >= c)
            continue
        
        sum += grid[newRow][newCol]
        count++
    }
    
    return Math.floor(sum / count)
}


// O(1) space
/**
 * @param {number[][]} M
 * @return {number[][]}
 */
/**
 * @param {number[][]} M
 * @return {number[][]}
 */
var imageSmoother = function(M) {
    const r = M.length
    const c = M[0].length
    
    for (let row = 0; row < r; row++) {
        for (let col = 0; col < c; col++) {
            M[row][col] |= (smooth(M, row, col, r, c) << 8)
        }
    }
    
    for (let row = 0; row < r; row++) {
        for (let col = 0; col < c; col++) {
            M[row][col] >>= 8
        }
    }
    
    return M
};

const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1], [1, 1]]

const smooth = (grid, row, col, r, c) => {
    let sum = grid[row][col]
    let count = 1
    
    for (const [dRow, dCol] of dirs) {
        const newRow = row + dRow
        const newCol = col + dCol
        
        if (newRow < 0 || newRow >= r || newCol < 0 || newCol >= c)
            continue
        
        sum += (grid[newRow][newCol] & 255)
        count++
    }
    
    return Math.floor(sum / count)
}
```

## 492. Construct the Rectangle
```javascript
/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
    for (let i = Math.floor(Math.sqrt(area)); i >= 0; i--) {
        if (area % i === 0) return [area / i, i]
    }
};
```

## 1436. Destination City
```javascript
/**
 * @param {string[][]} paths
 * @return {string}
 */
var destCity = function(paths) {
    const graph = {}
    
    for (const [start, end] of paths) {
        if (!graph[start]) graph[start] = 0
        if (!graph[end]) graph[end] = 0
        graph[start]++
    }
    
    for (const [vertex, edges] of Object.entries(graph)) {
        if (!edges) return vertex
    }
};
```

## 146. LRU Cache
```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.capacity = capacity
    this.keyToNodeMap = {}
    this.list = new DoublyLinkedList()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    const node = this.keyToNodeMap[key]
    if (node === undefined) {
        return -1
    }
    
    // move to node front of list
    this.list.moveToFront(node)
    
    return node.val
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    const node = this.keyToNodeMap[key]
    if (node !== undefined) {
        node.val = value
        
        // move to node front of list
        this.list.moveToFront(node)
        return
    }
    
    // add node to head
    const newNode = new Node(key, value)
    this.keyToNodeMap[key] = newNode
    this.list.insertAtHead(newNode)
        
    // if length over capacity evict tail
    if (this.list.length > this.capacity) {
        const tailNode = this.list.removeTail()
        delete this.keyToNodeMap[tailNode.key]
    }
};

/** 
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */

class DoublyLinkedList {
    constructor() {
        this.length = 0
        
        this.head = new Node(NaN)
        this.tail = new Node(NaN)
        this.head.next = this.tail
        this.tail.prev = this.head
    }
    
    moveToFront(node) {
        this.remove(node)
        this.insertAtHead(node) 
    }
    
    insertAtHead(node) {
        node.next = this.head.next
        node.next.prev = node
        this.head.next = node
        node.prev = this.head
        this.length++
    }
    
    remove(node) {
        const prev = node.prev
        const next = node.next
        
        prev.next = next
        next.prev = prev
        node.prev = null
        node.next = null
        
        this.length--
        
        return node
    }
    
    removeTail() {
        if (this.length === 0) {
            return
        }
        
        return this.remove(this.tail.prev)
    }
}

class Node {
    constructor(key, value) {
        this.key = key
        this.val = value
        this.prev = null
        this.next = null
    }
}
```

## 422. Valid Word Square
```javascript
/**
 * @param {string[]} words
 * @return {boolean}
 */
var validWordSquare = function(words) {
    for (let i = 0; i < words.length; i++) {
        for (let j = 0; j < words[i].length; j++) {
            if (j >= words.length)
                return false
            if (words[j].length <= i)
                return false
            if (words[i][j] !== words[j][i])
                return false
        }
    }
    
    return true
};
```

## 859. Buddy Strings
```javascript
/**
 * @param {string} A
 * @param {string} B
 * @return {boolean}
 */
var buddyStrings = function(A, B) {
    if (A.length !== B.length)
        return false
    
    const unique = new Set(A)

    const diff = []
    for (let i = 0; i < A.length; i++) {
        if (A[i] !== B[i]) {
            diff.push(i)
        }
    }
    
    const [i, j] = diff
    
    return diff.length == 2 && A[i] == B[j] && B[i] == A[j] ||
        diff.length == 0 && unique.size < A.length
};
```

## 1431. Kids With the Greatest Number of Candies
```javascript
/**
 * @param {number[]} candies
 * @param {number} extraCandies
 * @return {boolean[]}
 */
var kidsWithCandies = function(candies, extraCandies) {
    const max = Math.max(...candies)
    return candies.map(candy => candy + extraCandies >= max)
};
```

## 1427. Perform String Shifts
```javascript
/**
 * @param {string} s
 * @param {number[][]} shift
 * @return {string}
 */
var stringShift = function(s, shift) {
    let shifts = 0
    for (const [dir, amount] of shift) {
        if (dir) {
            shifts += amount
        } else {
            shifts -= amount
        }
    }
    
    const dir = shifts < 0 ? 'left' : 'right'
    let amount = Math.abs(shifts) % s.length
    
    if (dir === 'left')
        amount = s.length - amount
    
    const str = Array(s.length).fill()
    for (let i = 0; i < s.length; i++) {
        str[(i + amount) % s.length] = s[i]
    }
    
    return str.join('')
};
```

## 883. Projection Area of 3D Shapes
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var projectionArea = function(grid) {
    let result = 0
    
    for (let row = 0; row < grid.length; row++) {
        let maxRow = 0
        let maxCol = 0
        
        for (let col = 0; col < grid.length; col++) {
            if (grid[row][col] > 0) result++
            
            maxRow = Math.max(maxRow, grid[row][col])
            maxCol = Math.max(maxCol, grid[col][row])
        }
        
        result += maxRow + maxCol
    }
    
    return result
};
```

## 1378. Replace Employee ID With The Unique Identifier
```sql
# Write your MySQL query statement below
SELECT unique_id, name 
FROM Employees
LEFT JOIN EmployeeUNI
USING(id)
```

## 1350. Students With Invalid Departments
```sql
# Write your MySQL query statement below
SELECT S.id, S.name
FROM Students as S
LEFT JOIN Departments as D
ON S.department_id = D.id
WHERE D.name IS NULL

# Write your MySQL query statement below
SELECT id, name
FROM Students
WHERE department_id NOT IN
(SELECT id FROM Departments)
```

## 1407. Top Travellers
```javascript
# Write your MySQL query statement below
SELECT name, SUM(IFNULL(distance, 0)) AS travelled_distance
FROM Users AS U
LEFT JOIN Rides AS R
ON U.id = R.user_id
GROUP BY U.id
ORDER BY travelled_distance DESC, name
```

## 1327. List the Products Ordered in a Period
```sql
# Write your MySQL query statement below
SELECT product_name, SUM(unit) AS unit
FROM Products
JOIN Orders
USING(product_id)
WHERE MONTH(order_date) = 2 AND YEAR(order_date) = 2020
GROUP BY (product_id)
HAVING SUM(unit) >= 100
```

## 1322. Ads Performance
```javascript
# Write your MySQL query statement below
SELECT ad_id AS ad_id,
       IFNULL(ROUND(AVG(100 * (ACTION = 'Clicked') / (ACTION <> 'Ignored')), 2), 0) AS ctr
FROM Ads
GROUP BY ad_id
ORDER BY ctr DESC, ad_ID
```

## 1266. Minimum Time Visiting All Points
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var minTimeToVisitAllPoints = function(points) {
    let dist = 0
    
    for (let i = 1; i < points.length; i++) {
        const [x1, y1] = points[i - 1]
        const [x2, y2] = points[i]
        
        const deltaX = Math.abs(x1 - x2)
        const deltaY = Math.abs(y1 - y2)
        
        dist += Math.max(deltaX, deltaY)
    }
    
    return dist
};
```

## 1275. Find Winner on a Tic Tac Toe Game
```javascript
/**
 * @param {number[][]} moves
 * @return {string}
 */
var tictactoe = function(moves) {
    const n = 3
    const rows = Array(n).fill(0)
    const cols = Array(n).fill(0)
    let diag1 = 0
    let diag2 = 0
    
    let player = 1
    for (const [row, col] of moves) {
        rows[row] += player
        cols[col] += player
        if (row === col) diag1 += player
        if (row === n - 1 - col) diag2 += player
        
        const score = n * player
        if (rows[row] === score || cols[col] === score || diag1 === score || diag2 === score)
            return score < 0 ? 'B' : 'A'
        
        player *= -1
    }
    
    return moves.length === n * n ? 'Draw' : 'Pending'
};
```

## 604. Design Compressed String Iterator
```javascript
/**
 * @param {string} compressedString
 */
var StringIterator = function(compressedString) {
    this.str = compressedString
    
    this.currChar = ' '
    this.currCount = 0
    this.currIndex = 0
};

/**
 * @return {character}
 */
StringIterator.prototype.next = function() {
    if (this.currCount <= 0) {
        this.getNextChar()
        this.getNextCount()
    }
    
    this.currCount--
    return this.currChar
};

/**
 * @return {boolean}
 */
StringIterator.prototype.hasNext = function() {
    return this.currIndex < this.str.length || this.currCount > 0
};

StringIterator.prototype.getNextChar = function() {
    if (this.currIndex >= this.str.length) {
        this.currChar = ' '
    } else {
        this.currChar = this.str[this.currIndex++]
    }
}

StringIterator.prototype.getNextCount = function() {
    this.currCount = 0
    
    while (this.currIndex < this.str.length && isNum(this.str[this.currIndex])) {
        this.currCount *= 10
        this.currCount += +this.str[this.currIndex]
        this.currIndex++
    }
}

const isNum = char => !isNaN(+char)

/** 
 * Your StringIterator object will be instantiated and called as such:
 * var obj = new StringIterator(compressedString)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */
```

## 1232. Check If It Is a Straight Line
```javascript
/**
 * @param {number[][]} coordinates
 * @return {boolean}
 */
var checkStraightLine = function(coordinates) {
    if (coordinates.length === 2) 
        return true
    
    const [x1, y1] = coordinates[0]
    const [x2, y2] = coordinates[1]
    
    for (let i = 2; i < coordinates.length; i++) {
        const [x3, y3] = coordinates[i]
        if (((y3 - y2) * (x3 - x1)) !== ((y3 - y1) * (x3 - x2)))
            return false
    }
    
    return true
};

/**
 * @param {number[][]} coordinates
 * @return {boolean}
 */
var checkStraightLine = function(coordinates) {
    let slope = null
    
    for (let i = 0; i < coordinates.length - 1; i++) {
        const [x1, y1] = coordinates[i]
        const [x2, y2] = coordinates[i + 1]
        
        if (slope === null) {
            slope = getSlope(x1, y1, x2, y2)
            continue
        }
        
        if (slope !== getSlope(x1, y1, x2, y2)) {
            return false
        }
    }
    
    return true
};

const getSlope = (x1, y1, x2, y2) => {
    if (x2 - x1 === 0) return undefined
    return (y2 - y1) / (x2 - x1)
}
```

## 1037. Valid Boomerang
```javascript
/**
 * @param {number[][]} points
 * @return {boolean}
 */
var isBoomerang = function(points) {
    const [x1, y1] = points[0]
    const [x2, y2] = points[1]
    const [x3, y3] = points[2]
    
    return ((y3 - y2) * (x3 - x1)) !== ((y3 - y1) * (x3 - x2))
};

/**
 * @param {number[][]} points
 * @return {boolean}
 */
var isBoomerang = function(points) {
    const [x1, y1] = points[0]
    const [x2, y2] = points[1]
    const [x3, y3] = points[2]
    
    return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) * 0.5) !== 0
};
```

## 888. Fair Candy Swap
```javascript
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number[]}
 */
var fairCandySwap = function(A, B) {
    const aSum = A.reduce((result, num) => result + num, 0)
    const bSum = B.reduce((result, num) => result + num, 0)
    const delta = (bSum - aSum) / 2
    
    const bSet = new Set(B)
    
    for (const x of A) {
        if (bSet.has(x + delta))
            return [x, x + delta]
    }
    return []
};
```

## 840. Magic Squares In Grid
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var numMagicSquaresInside = function(grid) {
    let magicSquares = 0
    
    for (let i = 0; i < grid.length - 2; i++) {
        for (let j = 0; j < grid[0].length - 2; j++) {
            magicSquares += isMagicSquare(grid, i, j)
        }
    }
    
    return magicSquares
};

const isMagicSquare = (grid, i, j) => {
    let seen = 0
    const colSums = Array(3).fill(0)
    const rowSums = Array(3).fill(0)

    for (let row = i; row < i + 3; row++) {
        for (let col = j; col < j + 3; col++) {
            const num = grid[row][col]
            if (seen & 1 << (num - 1)) 
                return 0
            
            seen |= 1 << (num - 1)
            
            rowSums[row - i] += num
            colSums[col - j] += num
        }
    }
    
    if (seen !== 511) return 0
    
    const diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] 
    const diag2 = grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]
    
    for (const col of colSums) {
        if (col !== 15) return 0
    }
    
    for (const row of rowSums) {
        if (row !== 15) return 0
    }
    
    if (diag1 !== 15 || diag2 !== 15)
        return 0
    
    return 1
}
```

## 1260. Shift 2D Grid
```javascript
/**
 * @param {number[][]} grid
 * @param {number} k
 * @return {number[][]}
 */
var shiftGrid = function(grid, k) {
    const m = grid.length
    const n = grid[0].length
    
    const result = Array(m).fill(0).map(arr => Array(n).fill(0))
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            const inc = Math.floor((col + k) / n)
            const nRow = (row + inc) % m
            const nCol = (col + k) % n

            result[nRow][nCol] = grid[row][col]
        }
    }
    
    return result
};

// In Place
/**
 * @param {number[][]} grid
 * @param {number} k
 * @return {number[][]}
 */
var shiftGrid = function(grid, k) {
    const m = grid.length
    const n = grid[0].length
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            const shiftRow = (row + (Math.floor((col + k) / n))) % m
            const shiftCol = (col + k) % n
            
            const bin = grid[row][col] <<= 16
            grid[shiftRow][shiftCol] |= bin
        }
    }
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            grid[row][col] >>= 16
        }
    }
    
    return grid
};
```

## 696. Count Binary Substrings
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var countBinarySubstrings = function(s) {
    let prevBlock = 0
    let currBlock = 1
    let count = 0
    
    for (let i = 1; i < s.length; i++) {
        if (s[i] === s[i-1]) {
            currBlock++
        } else {
            count += Math.min(prevBlock, currBlock)
            
            prevBlock = currBlock
            currBlock = 1
        }
    }
    
    return count + Math.min(prevBlock, currBlock)
};
```

## 459. Repeated Substring Pattern
```javascript
// O(n^2) Brute Force
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
    const len = s.length
    
    for (let i = 1; i <= Math.floor(len / 2); i++) {
        if (len % i !== 0) continue
        
        const repeats = Math.floor(len / i)
        const substr = s.slice(0, i)
        const str = substr.repeat(repeats)
        
        if (s === str)
            return true
    }
    
    return false
};
```

## 1018. Binary Prefix Divisible By 5
```javascript
/**
 * @param {number[]} A
 * @return {boolean[]}
 */
var prefixesDivBy5 = function(A) {
    const result = []
    let num = 0
    
    for (const bit of A) {
        num = (2 * (num % 5) + bit) % 5
        result.push(num % 5 === 0)
    }
    
    return result
};

/**
 * @param {number[]} A
 * @return {boolean[]}
 */
var prefixesDivBy5 = function(A) {
    const result = []
    let num = 0
    
    for (const bit of A) {
        num |= bit
        num %= 5
        
        result.push(num % 5 === 0)
        
        num <<= 1
    }
    
    return result
};
```

## 800. Similar RGB Color
```javascript
/**
 * @param {string} color
 * @return {string}
 */
var similarRGB = function(color) {
    const colors = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99', 
                    'aa', 'bb', 'cc', 'dd', 'ee', 'ff']
    
    const result = ['#']
    
    for (let i = 1; i < color.length; i += 2) {
        let max = -Number.MAX_VALUE
        let rgb = ''
        
        const hex = color.slice(i, i + 2)
        const hexVal = parseInt(hex, 16)
        
        for (const c of colors) {
            const cand = parseInt(c, 16)
            const candVal = -((cand - hexVal) ** 2)
            
            if (candVal > max) {
                max = candVal
                rgb = c
            }
        }
        
        result.push(rgb)
    }
    
    return result.join('')
};
```

## 949. Largest Time for Given Digits
```javascript
// Iterative
/**
 * @param {number[]} A
 * @return {string}
 */
var largestTimeFromDigits = function(A) {
    let time = ''
    
    for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A.length; j++) {
            if (i === j) continue
            for (let k = 0; k < A.length; k++) {
                if (i === k || j === k) continue
                for (let l = 0; l < A.length; l++) {
                    if (i === l || j === l || k === l) continue
                    const hours = `${A[i]}${A[j]}`
                    const mins = `${A[k]}${A[l]}`

                    if (hours >= 24 || mins >= 60) continue

                    const currTime = hours + ':' + mins
                    if (time === '' || time < currTime) time = currTime
                }
            }
        }
    }
    
    return time
};

// Backtracking
/**
 * @param {number[]} A
 * @return {string}
 */
var largestTimeFromDigits = function(A) {
    const _largestTimeFromDigits = (curr) => {
        if (seen === 15) {
            const hours = `${curr[0]}${curr[1]}`
            const mins = `${curr[2]}${curr[3]}`
            
            if (hours >= 24 || mins >= 60) return
            const currTime = hours + ':' + mins
            
            if (time === '' || time < currTime) 
                time = currTime
            
            return
        }
        
        for (let index = 0; index < A.length; index++) {
            const mask = 1 << index
            if (seen & mask) continue
            
            curr.push(A[index])
            seen |= mask
            
            _largestTimeFromDigits(curr)
            
            curr.pop()
            seen &= ~mask
        }
    }
    
    let time = ''
    let seen = 0
    _largestTimeFromDigits([])
    return time
};
```

## 408. Valid Word Abbreviation
```javascript
/**
 * @param {string} word
 * @param {string} abbr
 * @return {boolean}
 */
var validWordAbbreviation = function(word, abbr) {
    let i = 0
    let j = 0
    
    while (i < word.length && j < abbr.length) {
        if (word[i] === abbr[j]) {
            i++
            j++
            continue
        }
        
        if (abbr[j] <= '0' || abbr[j] > '9')
            return false
        
        const start = j
        while (j < abbr.length && !isNaN(abbr[j])) {
            j++
        }
        
        const num = +abbr.slice(start, j)
        i += num
    }

    return i === word.length && j === abbr.length
};
```

## 812. Largest Triangle Area
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var largestTriangleArea = function(points) {
    let max = 0
    
    for (let i = 0; i < points.length - 2; i++) {
        for (let j = i + 1; j < points.length - 1; j++) {
            for (let k = j + 1; k < points.length; k++) {
                max = Math.max(max, area(points[i], points[j], points[k]))
            }
        }
    }
    
    return max
};

const area = (p1, p2, p3) => {
    const [x1, y1] = p1
    const [x2, y2] = p2
    const [x3, y3] = p3
    
    return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) * 0.5)
}
```

## 447. Number of Boomerangs
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var numberOfBoomerangs = function(points) {
    let result = 0
    
    for (let i = 0; i < points.length; i++) {
        const map = {}
        
        for (let j = 0; j < points.length; j++) {
            if (i === j) continue
            
            const dist = distance(points[i], points[j])
            
            if (!map[dist]) 
                map[dist] = 0
            
            map[dist]++
        }
        
        for (const val of Object.values(map)) {
            result += val * (val - 1)
        }
    }
    
    return result
};

const distance = (p1, p2) => {
    const [x1, y1] = p1
    const [x2, y2] = p2
    
    return (x2 - x1) ** 2 + (y2 - y1) ** 2
}
```

## 475. Heaters
```javascript
/**
 * @param {number[]} houses
 * @param {number[]} heaters
 * @return {number}
 */
var findRadius = function(houses, heaters) {
    houses.sort((a, b) => a - b)
    heaters.sort((a, b) => a - b)
    
    let max = 0
    let i = 0
    
    for (const house of houses) {
        while (i < heaters.length - 1 && Math.abs(heaters[i] - house) >= Math.abs(heaters[i+1] - house)) {
            i++
        }
        
        max = Math.max(max, Math.abs(heaters[i] - house))
    }
    
    return max
};
```

## 1118. Number of Days in a Month
```javascript
/**
 * @param {number} Y
 * @param {number} M
 * @return {number}
 */
var numberOfDays = function(Y, M) {
    const daysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    let result = daysPerMonth[M - 1]
    if (isLeapYear(Y) && M === 2)
        result++
    
    return result
};

const isLeapYear = y => y % 4 == 0 && y % 100 != 0 || y % 400 == 0
```

## 1154. Day of the Year
```javascript
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    const [dateYear, dateMonth, dateDay] = date.split('-')
    const months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    let day = 0
    
    for (let month = 1; month < +dateMonth; month++) {
        if (month === 2 && isLeapYear(+dateYear)) {
            day += 29
        } else {
            day += months[month - 1]
        }
    }
    
    return day + +dateDay
};

const isLeapYear = y => (y % 4 === 0 && y % 100 !== 0) || y % 400 === 0
```

## 1360. Number of Days Between Two Dates
```javascript
/**
 * @param {string} date1
 * @param {string} date2
 * @return {number}
 */

const daysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

var daysBetweenDates = function(date1, date2) {
    const [y1, m1, d1] = date1.split('-')
    const [y2, m2, d2] = date2.split('-')
    
    const days1 = daysFrom1970(+y1, +m1, +d1)
    const days2 = daysFrom1970(+y2, +m2, +d2)

    return Math.abs(days1 - days2)
}

const isLeapYear = y => y % 4 === 0 && y % 100 !== 0 || y % 400 === 0

const daysFrom1970 = (y, m, d) => {
    let days = 0
    
    for (let currY = 1970; currY < y; currY++) {
        days += isLeapYear(currY) ? 366 : 365    
    }
    
    for (let currM = 1; currM < m; currM++) {
        days += daysOfMonth[currM - 1]
        
        if (isLeapYear(y) && currM === 2)
            days++
    }
    
    return days + d
}

// API
/**
 * @param {string} date1
 * @param {string} date2
 * @return {number}
 */

var daysBetweenDates = function(date1, date2) {
    const d1 = new Date(date1)
    const d2 = new Date(date2)
    
    const millisecondsBetween = Math.abs(d1 - d2)
    return millisecondsBetween / (1000 * 60 * 60 * 24)
}
```

## 1441. Build an Array With Stack Operations
```javascript
/**
 * @param {number[]} target
 * @param {number} n
 * @return {string[]}
 */
var buildArray = function(target, n) {
    let i = 0
    const result = []
    
    for (let j = 1; j <= n && i < target.length; j++) {
        result.push('Push')
        
        if (target[i] === j) {
            i++
        } else {
            result.push('Pop')   
        }
    }
    
    return result
};
```

## 453. Minimum Moves to Equal Array Elements
```javascript
// Sorting
/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
    nums.sort((a, b) => a - b)
    
    let count = 0
    
    for (let i = nums.length - 1; i > 0; i--) {
        count += nums[i] - nums[0]
    }
    
    return count
};

// O(n)
/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
    let min = Number.MAX_VALUE
    let sum = 0
    
    for (const num of nums) {
        min = Math.min(num, min)
        sum += num
    }
    
    return sum - min * nums.length
};

// O(n) avoiding integer overflow
/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
    let min = Number.MAX_VALUE
    let moves = 0
    
    for (const num of nums) {
        min = Math.min(num, min)
    }
    
    for (const num of nums) {
        moves += num - min
    }
    
    return moves
};
```

## 1217. Play with Chips
```javascript
/**
 * @param {number[]} chips
 * @return {number}
 */
var minCostToMoveChips = function(chips) {
    let evens = 0
    let odds = 0
    
    for (let i = 0; i < chips.length; i++) {
        chips[i] & 1 ? odds++ : evens++
    }
    
    return Math.min(evens, odds)
};
```

## 1033. Moving Stones Until Consecutive
```javascript
/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number[]}
 */
var numMovesStones = function(a, b, c) {
    const s = [a, b, c]
    s.sort((a, b) => a - b)
    
    if (s[2] - s[0] === 2)
        return [0, 0]
    
    const minDist = Math.min(s[1] - s[0], s[2] - s[1])
    const min = minDist <= 2 ? 1 : 2
    const max = s[2] - s[0] - 2
    
    return [min, max]
};

/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number[]}
 */
var numMovesStones = function(a, b, c) {
    const [x, y, z] = [a, b, c].sort((a, b) => a - b)
    
    const diff1 = y - x - 1
    const diff2 = z - y - 1
    
    if (diff1 === 0 && diff2 === 0) {
        return [0, 0]
    }
    
    if (diff1 === 0 || diff2 === 0) {
        return [1, Math.max(diff1, diff2)]
    }
    
    if (diff1 === 1 || diff2 === 1) {
        return [1, diff1 + diff2]
    }
    
    return [2, diff1 + diff2]
};
```

## 1443. Minimum Time to Collect All Apples in a Tree
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {boolean[]} hasApple
 * @return {number}
 */
var minTime = function(n, edges, hasApple) {
    const _dfs = (node) => {
        let apple = hasApple[node]
        
        if (graph[node]) {
            for (const vertex of graph[node]) {
                if (_dfs(vertex)) 
                    apple = true
            }
        }
        
        if (apple && node !== 0) 
            min += 2
        
        return apple
    }
    
    const graph = buildGraph(n, edges)
    let min = 0
    _dfs(0)
    return min
};

const buildGraph = (n, edges) => {
    const graph = Array(n).fill()

    for (const [start, end] of edges) {
        if (!graph[start])
            graph[start] = []
        
        graph[start].push(end)
    }
    
    return graph
}
```

## 1103. Distribute Candies to People
```javascript
/**
 * @param {number} candies
 * @param {number} num_people
 * @return {number[]}
 */
var distributeCandies = function(candies, num_people) {
    const result = Array(num_people).fill(0)
    
    for (let i = 0; candies > 0; i++) {
        result[i % num_people] += Math.min(candies, i + 1)
        candies -= i + 1
    }
    
    return result
};
```

## 892. Surface Area of 3D Shapes
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var surfaceArea = function(grid) {
    const n = grid.length
    let area = 0
    
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < n; col++) {
            const cube = grid[row][col]
            if (cube === 0) continue
            
            area += cube * 4 + 2
            
            if (col - 1 >= 0) {
                const leftCube = grid[row][col - 1]
                area -= Math.min(cube, leftCube) * 2
            }
            
            if (row - 1 >= 0) {
                const topCube = grid[row - 1][col]
                area -= Math.min(cube, topCube) * 2
            }
        }
    }
    
    return area
};
```

## 1071. Greatest Common Divisor of Strings
```javascript
// Recursive O(n^2)
/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function(str1, str2) {
    if (str1.length < str2.length)
        return gcdOfStrings(str2, str1)
    
    if (!str1.includes(str2))
        return ''
    
    if (!str2.length)
        return str1
    
    return gcdOfStrings(str1.slice(str2.length), str2)
};

// Iterative O(n)
/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function(str1, str2) {
    const length = gcd(str1.length, str2.length)
    const gcdStr = str1.slice(0, length)
    const s1 = gcdStr.repeat(str1.length / length)
    const s2 = gcdStr.repeat(str2.length / length)
    
    if (s1 === str1 && s2 === str2)
        return gcdStr
    
    return ''
};

const gcd = (a, b) => {
    if (a < b) return gcd(b, a)
    return a % b === 0 ? b : gcd(b, a % b)
}
```

## 758. Bold Words in String
```javascript
/**
 * @param {string[]} words
 * @param {string} S
 * @return {string}
 */
var boldWords = function(words, S) {
    const marked = Array(S.length).fill(false)
    
    for (const word of words) {
        mark(word, marked, S)
    }
    
    const result = []
    
    for (let i = 0; i < S.length; i++) {
        if (marked[i] && (i == 0 || !marked[i - 1]))
            result.push("<b>")
        
        result.push(S[i])
        
        if (marked[i] && (i == S.length - 1 || !marked[i + 1]))
            result.push("</b>")
    }
    
    return result.join('')
};

const mark = (word, marked, S) => {
    for (let end = word.length; end <= S.length; end++) {
        const start = end - word.length
        const str = S.slice(start, end)
        
        if (word !== str) continue
        
        for (let j = start; j < end; j++) {
            marked[j] = true
        }
    }
}
```

## 1175. Prime Arrangements
```javascript
/**
 * @param {number} n
 * @return {number}
 */

var numPrimeArrangements = function(n) {
    const MOD = BigInt(10 ** 9 + 7)
    const primes = countPrimes(n)
    return factorial(primes) * factorial(n - primes) % MOD
};

const countPrimes = n => {
    const isPrime = Array(n + 1).fill(true)
    isPrime[0] = false
    isPrime[1] = false
    
    for (let i = 2; i <= Math.sqrt(n); i++) {
        if (!isPrime[i]) continue
        
        for (let multiple = 2; i * multiple <= n; multiple++) {
            isPrime[i * multiple] = false
        }
    }
    
    let count = 0
    
    for (const prime of isPrime) {
        if (prime) count++
    }
    
    return count
}

const factorial = num => {
    const MOD = BigInt(10 ** 9 + 7)
    let result = 1n
    
    for (let i = 2n; i <= num; i++) {
        result *= i
        result %= MOD
    }
    
    return result
}
```

## 1435. Create a Session Bar Chart
```javascript
# Write your MySQL query statement below
SELECT '[0-5>' AS bin, SUM(duration/60 BETWEEN 0 AND 5) AS total FROM Sessions
UNION ALL
SELECT '[5-10>' AS bin, SUM(duration/60 BETWEEN 5 AND 10) AS total FROM Sessions
UNION ALL
SELECT '[10-15>' AS bin, SUM(duration/60 BETWEEN 10 AND 15) AS total FROM Sessions
UNION ALL
SELECT '15 or more' AS bin, SUM(duration/60 >= 15) AS total FROM Sessions
```

## 665. Non-decreasing Array
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var checkPossibility = function(nums) {
    let count = 0
    for (const [i, num] of nums.entries()) {
        if (num > nums[i + 1]) {
            count++
            
            if (count > 1 || nums[i - 1] > nums[i + 1] && nums[i + 2] < nums[i]) {
                return false
            }
        }
    }
    
    return true
};
```

## 628. Maximum Product of Three Numbers
```javascript
// Sorting
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumProduct = function(nums) {
    nums.sort((a, b) => a - b)
    
    const m1 = nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]
    const m2 = nums[0] * nums[1] * nums[nums.length - 1]
    return Math.max(m1, m2)
};

// O(n)
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumProduct = function(nums) {
    let max1 = -Infinity
    let max2 = -Infinity
    let max3 = -Infinity
    let min1 = Infinity
    let min2 = Infinity
    
    for (const num of nums) {
        if (num > max1) {
            max3 = max2
            max2 = max1
            max1 = num
        } else if (num > max2) {
            max3 = max2
            max2 = num
        } else if (num > max3) {
            max3 = num
        }
        
        if (num < min1) {
            min2 = min1
            min1 = num
        } else if (num < min2) {
            min2 = num
        }
    }

    return Math.max(max1 * min1 * min2, max1 * max2 * max3)
};
```

## 751. IP to CIDR
```javascript
/**
 * @param {string} ip
 * @param {number} n
 * @return {string[]}
 */
var ipToCIDR = function(ip, n) {
    const result = []
    let ipNum = ipStrToNum(ip)

    while (n > 0) {
        let zeros = numOfTrailingZeros(ipNum)
        
        while (2 ** zeros > n)
            zeros--
        
        const numOfAddresses = 2 ** zeros        
        const prefixLength = 32 - zeros
        
        result.push(`${ipNumToStr(ipNum)}/${prefixLength}`)
        
        n -= numOfAddresses
        ipNum += numOfAddresses
    }
    
    return result
};

const numOfTrailingZeros = bin => {
    let zeros = 0
    
    while (bin && !(bin & 1)) {
        zeros++
        bin >>>= 1
    }
    
    return zeros
}

const ipStrToNum = str => {
    const ipAddress = str.split('.')
    return +ipAddress[0] << 24 | +ipAddress[1] << 16 | +ipAddress[2] << 8 | +ipAddress[3]
}

const ipNumToStr = num => {
    return `${num >>> 24}.${num >>> 16 & 0xFF}.${num >>> 8 & 0xFF}.${num & 0xFF}`  
} 
```

## 172. Factorial Trailing Zeroes
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
    let zeros = 0
    
    while (n > 0) {
        zeros += Math.floor(n / 5)
        n = Math.floor(n / 5)
    }
    
    return zeros
};
```

## 1389. Create Target Array in the Given Order
```javascript
// O(n^2) splice
/**
 * @param {number[]} nums
 * @param {number[]} index
 * @return {number[]}
 */
var createTargetArray = function(nums, index) {
    const result = []
    
    for (let i = 0; i < nums.length; i++) {
        const idx = index[i]
        const num = nums[i]
        
        result.splice(idx, 0, num)
    }
    
    return result
};

// O(n^2)
/**
 * @param {number[]} nums
 * @param {number[]} index
 * @return {number[]}
 */
var createTargetArray = function(nums, index) {
    let result = []
    
    for (let i = 0; i < nums.length; i++) {
        result = [...result.slice(0, index[i]), nums[i], ...result.slice(index[i])]
    }
    
    return result
};

// O(n^2) shift only when need to
/**
 * @param {number[]} nums
 * @param {number[]} index
 * @return {number[]}
 */
var createTargetArray = function(nums, index) {
    const result = Array(nums.length).fill(-1)
    
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i]
        const idx = index[i]
        
        if (result[idx] !== -1) {
            shiftElements(result, idx)
        }
        
        result[idx] = num
    }
    
    return result
};

const shiftElements = (arr, i) => {
    for (let j = arr.length - 1; j > i; j--) {
        arr[j] = arr[j - 1]
    } 
}
```

## 314. Binary Tree Vertical Order Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var verticalOrder = function(root) {
    if (!root) return []
    
    const cols = {}
    let minCol = 0
    let maxCol = 0
    
    const queue = [[root, 0]]
    while (queue.length) {
        const [node, col] = queue.shift()
        
        if (cols[col] === undefined) {
            cols[col] = []
        }
        
        cols[col].push(node.val)
        
        minCol = Math.min(minCol, col)
        maxCol = Math.max(maxCol, col)
        
        if (node.left) queue.push([node.left, col - 1])
        if (node.right) queue.push([node.right, col + 1])
    }
    
    const result = []
    for (let i = minCol; i <= maxCol; i++) {
        result.push(cols[i])
    }
    
    return result
};
```

## 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} original
 * @param {TreeNode} cloned
 * @param {TreeNode} target
 * @return {TreeNode}
 */

var getTargetCopy = function(original, cloned, target) {
    const dfs = (n1, n2) => {
        if (!n1 || !n2) return 
        if (n1 === target) return n2
        return dfs(n1.left, n2.left) || dfs(n1.right, n2.right)
    }
    
    return dfs(original, cloned)
};
```

## 1314. Matrix Block Sum
```javascript
/**
 * @param {number[][]} mat
 * @param {number} K
 * @return {number[][]}
 */
var matrixBlockSum = function(mat, K) {
    const m = mat.length
    const n = mat[0].length
    
    const prefix = Array(m+1).fill(0).map(a => Array(n+1).fill(0))
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            prefix[row+1][col+1] = mat[row][col] + prefix[row+1][col] + prefix[row][col+1] - prefix[row][col]
        }
    }

    const result = Array(m).fill(0).map(a => Array(n).fill(0))
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            const r1 = Math.max(0, row - K)
            const r2 = Math.min(m - 1, row + K)            
            const c1 = Math.max(0, col - K)
            const c2 = Math.min(n - 1, col + K)

            result[row][col] = prefix[r2+1][c2+1] - prefix[r2 + 1][c1] - prefix[r1][c2 + 1] + prefix[r1][c1]
        }
    }
    
    return result
};
```

## 706. Design HashMap
```javascript
// Separate Chaining (Linked List) + Rehash & Load Factor
/**
 * Initialize your data structure here.
 */
var MyHashMap = function() {
    this.elements = Array(10_000).fill().map(a => new LinkedList())
    this.loadFactor = 0.75
    this.count = 0
};

/**
 * value will always be non-negative. 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
MyHashMap.prototype.put = function(key, value) {
    const index = this.hash(key)
    this.elements[index].insert(key, value)
    this.count++
    
    if (this.shouldRehash()) {
        this.rehash()
    }
};

/**
 * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key 
 * @param {number} key
 * @return {number}
 */
MyHashMap.prototype.get = function(key) {
    const index = this.hash(key)
    return this.elements[index].get(key)
};

/**
 * Removes the mapping of the specified value key if this map contains a mapping for the key 
 * @param {number} key
 * @return {void}
 */
MyHashMap.prototype.remove = function(key) {
    const index = this.hash(key)
    if (this.elements[index].remove(key)) {
        this.count--
    }
};

/** 
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */

MyHashMap.prototype.hash = function(key) {
    return key % this.elements.length
}

MyHashMap.prototype.shouldRehash = function() {
    return this.count / this.elements.length >= this.loadFactor
}

MyHashMap.prototype.rehash = function() {
    const prevElements = this.elements
    this.elements = Array(prevElements.length * 2).fill().map(a => new LinkedList())
    this.count = 0
    
    for (const list of prevElements) {
        let head = list.head
        while (head) {
            this.put(head.key, head.val)
            head = head.next
        }
    }
}

class LinkedList {
    constructor() {
        this.head = null
    }
    
    get(key) {
        let curr = this.head
        while (curr) {
            if (curr.key === key) {
                return curr.val
            }
            curr = curr.next
        }
        
        return -1
    }
    
    insert(key, val) {
        if (this.get(key) === -1) {
            const node = new Node(key, val)
            node.next = this.head
            this.head = node
            return
        }
        
        let curr = this.head
        while (curr) {
            if (curr.key === key) {
                curr.val = val
                return
            }
            curr = curr.next
        }
    }
    
    remove(key) {
        if (!this.head) return false
        
        if (this.head.key === key) {
            this.head = this.head.next
            return
        }

        let curr = this.head
        while (curr.next) {
            if (curr.next.key === key) {
                curr.next = curr.next.next
                return true
            }
            
            curr = curr.next
        }
        
        return false
    }
}

class Node {
    constructor(key, val) {
        this.key = key
        this.val = val
    }
}

// Open Addressing (Linear Probing) + Rehash & Load Factor + Lazy Deletion
/**
 * Initialize your data structure here.
 */
var MyHashMap = function() {
    this.elements = Array(10_000).fill(null)
    this.loadFactor = 0.75
    this.count = 0
};

/**
 * value will always be non-negative. 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
MyHashMap.prototype.put = function(key, value) {
    let index = this.hash(key)
    
    while (this.elements[index] !== null) {
        if (this.elements[index][0] === key) break
        index++
        index %= this.elements.length
    }
    
    if (this.elements[index] === null) {
        this.count++
    }
    
    this.elements[index] = [key, value]
    
    if (this.shouldRehash()) {
        this.rehash()
    }
};

/**
 * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key 
 * @param {number} key
 * @return {number}
 */
MyHashMap.prototype.get = function(key) {
    let index = this.hash(key)
    let firstLazyIndex = null
    
    while (this.elements[index] !== null) {
        if (this.elements[index][0] === key) {
            break
        }
        
        if (this.elements[index][0] === -1 && firstLazyIndex === null) {
            firstLazyIndex = index
        }
        
        index++
        index %= this.elements.length
    }
    
    if (this.elements[index] === null)
        return -1
    
    const value = this.elements[index][1]
    
    if (firstLazyIndex !== null) {
        this.elements[firstLazyIndex] = [this.elements[index][0], 
                                         this.elements[index][1]]
        this.elements[index] = [-1, -1]
    }
    
    return value
};

/**
 * Removes the mapping of the specified value key if this map contains a mapping for the key 
 * @param {number} key
 * @return {void}
 */
MyHashMap.prototype.remove = function(key) {
    let index = this.hash(key)
    
    while (this.elements[index] !== null) {
        if (this.elements[index][0] === key) {
            this.elements[index] = [-1, -1]
            this.count--
            return
        }
        
        index++
        index %= this.elements.length
    }  
};

MyHashMap.prototype.hash = function(key) {
    return key % this.elements.length
}

MyHashMap.prototype.rehash = function() {
    const prevElements = this.elements
    this.elements = Array(this.elements.length * 2).fill(null)
    
    for (let i = 0; i < prevElements.length; i++) {
        if (prevElements[i] === null || prevElements[i][0] === -1) continue
        this.put(prevElements[i][0], prevElements[i][1])
    }
}

MyHashMap.prototype.shouldRehash = function() {
    return this.count / this.elements.length >= this.loadFactor
}

/** 
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */



// Open Addressing (Quadratic Probing) + Rehash & Load Factor + Lazy Deletion
/**
 * Initialize your data structure here.
 */
var MyHashMap = function() {
    this.elements = Array(10_000).fill(null)
    this.loadFactor = 0.49
    this.count = 0
};

/**
 * value will always be non-negative. 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
MyHashMap.prototype.put = function(key, value) {
    let index = this.hash(key)
    let base = 0
    
    while (this.elements[index] !== null) {
        if (this.elements[index][0] === key) break
        index += base ** 2
        index %= this.elements.length
        base++
    }
    
    if (this.elements[index] === null) {
        this.count++
    }
    
    this.elements[index] = [key, value]
    
    if (this.shouldRehash()) {
        this.rehash()
    }
};

/**
 * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key 
 * @param {number} key
 * @return {number}
 */
MyHashMap.prototype.get = function(key) {
    let index = this.hash(key)
    let base = 0
    let firstLazyIndex = null
    
    while (this.elements[index] !== null) {
        if (this.elements[index][0] === key) {
            break
        }
        
        if (this.elements[index][0] === -1 && firstLazyIndex === null) {
            firstLazyIndex = index
        }
        
        index += base ** 2
        index %= this.elements.length
        base++
    }
    
    if (this.elements[index] === null)
        return -1
    
    const value = this.elements[index][1]
    
    if (firstLazyIndex !== null) {
        this.elements[firstLazyIndex] = [this.elements[index][0], 
                                         this.elements[index][1]]
        this.elements[index] = [-1, -1]
    }
    
    return value
};

/**
 * Removes the mapping of the specified value key if this map contains a mapping for the key 
 * @param {number} key
 * @return {void}
 */
MyHashMap.prototype.remove = function(key) {
    let index = this.hash(key)
    let base = 0
    
    while (this.elements[index] !== null) {
        if (this.elements[index][0] === key) {
            this.elements[index] = [-1, -1]
            this.count--
            return
        }
        
        index += base ** 2
        index %= this.elements.length
        base++
    }  
};

MyHashMap.prototype.hash = function(key) {
    return key % this.elements.length
}

MyHashMap.prototype.rehash = function() {
    const prevElements = this.elements
    this.elements = Array(this.elements.length * 2).fill(null)
    
    for (let i = 0; i < prevElements.length; i++) {
        if (prevElements[i] === null || prevElements[i][0] === -1) continue
        this.put(prevElements[i][0], prevElements[i][1])
    }
}

MyHashMap.prototype.shouldRehash = function() {
    return this.count / this.elements.length >= this.loadFactor
}

/** 
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */
```

## 1445. Apples & Oranges
```sql
# Write your MySQL query statement below
SELECT sale_date, 
       apples.sold_num - oranges.sold_num AS diff 
FROM
(SELECT * FROM Sales WHERE fruit = 'apples') AS apples
INNER JOIN
(SELECT * FROM Sales WHERE fruit = 'oranges') AS oranges
USING(sale_date)
```

## 1393. Capital Gain/Loss
```sql
# Write your MySQL query statement below
SELECT stock_name, 
       SUM(IF(operation = 'Buy', -price, price)) AS capital_gain_loss
FROM Stocks
GROUP BY stock_name
```

## 1398. Customers Who Bought Products A and B but Not C
```sql
# Write your MySQL query statement below
SELECT customer_id, customer_name
FROM Customers
JOIN Orders
USING(customer_id)
GROUP BY customer_id
HAVING SUM(product_name = "A") > 0 AND 
       SUM(product_name = "B") > 0 AND 
       SUM(product_name = "C") = 0
```

## 1347. Minimum Number of Steps to Make Two Strings Anagram
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var minSteps = function(s, t) {
    const counter = Array(26).fill(0)
    let steps = 0
    
    for (const char of s) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        counter[index]++
    }
    
    for (const char of t) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        counter[index]--
    }
    
    for (const count of counter) {
        if (count > 0) steps += count
    }
    
    return steps
};
```

## 1421. NPV Queries
```sql
# Write your MySQL query statement below
SELECT id, year, IFNULL(npv, 0) AS npv
FROM Queries
LEFT JOIN NPV
USING(id, year)
```

## 797. All Paths From Source to Target
```javascript
/**
 * @param {number[][]} graph
 * @return {number[][]}
 */
var allPathsSourceTarget = function(graph) {
    const _allPathsSourceTarget = node => {
        if (node === n - 1) {
            result.push(path.slice())
            return
        }
        
        for (const neighbor of graph[node]) {
            path.push(neighbor)
            _allPathsSourceTarget(neighbor)
            path.pop()
        }
    }
    
    const n = graph.length
    const result = []
    const path = [0]
    _allPathsSourceTarget(0)
    return result
};
```

## 890. Find and Replace Pattern
```javascript
/**
 * @param {string[]} words
 * @param {string} pattern
 * @return {string[]}
 */
var findAndReplacePattern = function(words, pattern) {
    const result = []
    
    for (const word of words) {
        if (isMatch(word, pattern)) {
            result.push(word)
        }
    }
    
    return result
};

const isMatch = (word, pattern) => {
    if (word.length !== pattern.length)
        return false
    
    const pMap = {}
    const wMap = {}
    
    for (let i = 0; i < word.length; i++) {
        const wChar = word[i]
        const pChar = pattern[i]
        
        if (!pMap[pChar] && !wMap[wChar]) {
            pMap[pChar] = wChar
            wMap[wChar] = pChar
        } else if (pMap[pChar] === wChar && wMap[wChar] === pChar) {
            continue
        } else {
            return false
        }
    }
    return true
}
```

## 1440. Evaluate Boolean Expression
```sql
# Write your MySQL query statement below
SELECT left_operand, operator, right_operand,
    CASE WHEN operator = '>' AND v1.value > v2.value THEN 'true'
         WHEN operator = '<' AND v1.value < v2.value THEN 'true'
         WHEN operator = '=' AND v1.value = v2.value THEN 'true'
         ELSE 'false'
         END AS value
FROM Expressions AS e
JOIN Variables AS v1 ON v1.name = left_operand
JOIN Variables AS v2 ON v2.name = right_operand
```

## 419. Battleships in a Board
```javascript
/**
 * @param {character[][]} board
 * @return {number}
 */
var countBattleships = function(board) {
    let count = 0
    
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[0].length; col++) {
            if (board[row][col] === '.') continue
            if (row > 0 && board[row - 1][col] === 'X') continue
            if (col > 0 && board[row][col - 1] === 'X') continue
            count++
        }
    }
    
    return count
};
```

## 1450. Number of Students Doing Homework at a Given Time
```javascript
/**
 * @param {number[]} startTime
 * @param {number[]} endTime
 * @param {number} queryTime
 * @return {number}
 */
var busyStudent = function(startTime, endTime, queryTime) {
    let students = 0
    
    for (let i = 0; i < startTime.length; i++) {
        if (startTime[i] <= queryTime && queryTime <= endTime[i]) {
            students++
        }
    }
    
    return students
};
```

## 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} threshold
 * @return {number}
 */
var numOfSubarrays = function(arr, k, threshold) {
    let sum = 0
    let count = 0
    
    for (let i = 0; i < arr.length; i++) {
        sum += arr[i]
        
        if (i < k - 1) continue
        
        if (sum / k >= threshold)
            count++
        
        sum -= arr[i - k + 1]
    }
    
    return count
};
```

## 791. Custom Sort String
```javascript
/**
 * @param {string} S
 * @param {string} T
 * @return {string}
 */
var customSortString = function(S, T) {
    const count = Array(26).fill(0)
    
    for (const char of T) {
        const index = indexForChar(char)
        count[index]++
    }
    
    const result = []
    
    for (const char of S) {
        const index = indexForChar(char)
        while (count[index]-- > 0) {
            result.push(char)
        }
    }
    
    for (const char of T) {
        const index = indexForChar(char)
        if (count[index]-- > 0) {
            result.push(char)
        }
    }
    
    return result.join('')
};

const indexForChar = char => {
    return char.charCodeAt(0) - 'a'.charCodeAt(0)
}
```

## 1437. Check If All 1's Are at Least Length K Places Away
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var kLengthApart = function(nums, k) {
    let j = null 
    for (let i = 0; i < nums.length; i++) {
        if (!nums[i]) continue

        if (j !== null && i - j - 1 < k)
            return false
        
        j = i
    }
    
    return true
};
```

## 1355. Activity Participants
```sql
# Write your MySQL query statement below
SELECT activity
FROM Friends
GROUP BY activity
HAVING COUNT(*) NOT IN
(
    SELECT MAX(cnt)
    FROM (SELECT activity, COUNT(*) AS cnt
          FROM Friends
          GROUP BY activity) as d1
    UNION
    SELECT MIN(cnt)
    FROM (SELECT activity, COUNT(*) AS cnt
          FROM Friends
          GROUP BY activity) as d2
)
```

## 950. Reveal Cards In Increasing Order
```javascript
/**
 * @param {number[]} deck
 * @return {number[]}
 */
var deckRevealedIncreasing = function(deck) {
    deck.sort((a, b) => a - b)
    
    const result = [deck.pop()]
    
    while (deck.length) {
        result.unshift(result.pop())
        result.unshift(deck.pop())
    }
    
    return result
};
```

## 1433. Check If a String Can Break Another String
```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkIfCanBreak = function(s1, s2) {
    s1 = bucketSort(s1)
    s2 = bucketSort(s2)
    
    let notBroken1 = true
    let notBroken2 = true
    for (let i = 0; i < s1.length; i++) {
        if (s1[i] > s2[i]) notBroken1 = false
        if (s1[i] < s2[i]) notBroken2 = false
    }
    
    return notBroken1 || notBroken2
};

const bucketSort = str => {
    const buckets = Array(26).fill(0)
    
    for (const char of str) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        buckets[index]++
    }
    
    const result = []
    for (let i = 0; i < buckets.length; i++) {
        while (buckets[i]--) {
            result.push(String.fromCharCode(i + 'a'.charCodeAt(0)))
        }
    }
    
    return result.join('')
}
```

## 1222. Queens That Can Attack the King
```javascript
/**
 * @param {number[][]} queens
 * @param {number[]} king
 * @return {number[][]}
 */
var queensAttacktheKing = function(queens, king) {
    const seen = Array(8).fill(0).map(arr => Array(8).fill(false))
    for (const [row, col] of queens) {
        seen[row][col] = true
    }
    
    const result = []
    const dirs = [-1, 0, 1]
    
    for (const dx of dirs) {
        for (const dy of dirs) {
            if (!dx && !dy) continue
            
            let [row, col] = king
            
            while (row >= 0 && row < 8 && col >= 0 && col < 8) {
                if (seen[row][col]) {
                    result.push([row, col])
                    break
                }
                
                row += dx
                col += dy
            }
        }   
    }
    
    return result
};
```

## 1357. Apply Discount Every n Orders
```javascript
/**
 * @param {number} n
 * @param {number} discount
 * @param {number[]} products
 * @param {number[]} prices
 */
var Cashier = function(n, discount, products, prices) {
    this.n = n
    this.discount = discount
    this.priceMap = {}
    this.customerNumber = 0
    
    for (let i = 0; i < products.length; i++) {
        this.priceMap[products[i]] = prices[i]
    }
};

/** 
 * @param {number[]} product 
 * @param {number[]} amount
 * @return {number}
 */
Cashier.prototype.getBill = function(product, amount) {
    let total = 0
    
    for (let i = 0; i < product.length; i++) {
        total += this.priceMap[product[i]] * amount[i]
    } 
    
    if (this.customerNumber === this.n - 1) {
        this.customerNumber = 0
        return total - (this.discount * total) / 100
    }
    
    this.customerNumber++
    return total
};

/** 
 * Your Cashier object will be instantiated and called as such:
 * var obj = new Cashier(n, discount, products, prices)
 * var param_1 = obj.getBill(product,amount)
 */
```

## 912. Sort an Array
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    const buckets = Array(50_001 * 2).fill(0)
    for (const num of nums) {
        buckets[num + 50_001]++
    }
    
    const result = []
    for (let [i, bucket] of buckets.entries()) {
        while (bucket--) {
            result.push(i - 50_001)
        }
    }
    
    return result
};
```

## 362. Design Hit Counter
```javascript
// https://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/
/**
 * Initialize your data structure here.
 */
var HitCounter = function() {
    this.interval = 300
    this.times = Array(this.interval).fill(0)
    this.hits = Array(this.interval).fill(0)
};

/**
 * Record a hit.
        @param timestamp - The current timestamp (in seconds granularity). 
 * @param {number} timestamp
 * @return {void}
 */
HitCounter.prototype.hit = function(timestamp) {
    const index = timestamp % this.interval
    if (this.times[index] !== timestamp) {
        this.times[index] = timestamp
        this.hits[index] = 1
    } else {
        this.hits[index]++
    }
};

/**
 * Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity). 
 * @param {number} timestamp
 * @return {number}
 */
HitCounter.prototype.getHits = function(timestamp) {
    let hits = 0
    for (let i = 0; i < this.interval; i++) {
        if (this.interval > timestamp - this.times[i]) {
            hits += this.hits[i]
        }
    }
    
    return hits
};

/** 
 * Your HitCounter object will be instantiated and called as such:
 * var obj = new HitCounter()
 * obj.hit(timestamp)
 * var param_2 = obj.getHits(timestamp)
 */
```

## 1448. Count Good Nodes in Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var goodNodes = function(root) {
    const _goodNodes = (node, max) => {
        if (!node) return 0
        
        let count = node.val >= max
        count += _goodNodes(node.left, Math.max(max, node.val))
        count += _goodNodes(node.right, Math.max(max, node.val))
        return count
    }
    
    return _goodNodes(root, -Infinity)
};
```

## 319. Bulb Switcher
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var bulbSwitch = function(n) {
    return Math.floor(Math.sqrt(n))
};
```

## 1273. Delete Tree Nodes
```javascript
/**
 * @param {number} nodes
 * @param {number[]} parent
 * @param {number[]} value
 * @return {number}
 */
var deleteTreeNodes = function(nodes, parent, value) {
    const dfs = node => {
        let sum = value[node]
        let count = 1
        
        if (tree[node]) {
            for (const neighbor of tree[node]) {
                const [subSum, subCount] = dfs(neighbor)
                sum += subSum
                count += subCount
            }
        }
        
        if (sum === 0) count = 0
        return [sum, count]
    }
    
    const tree = buildTree(nodes, parent)
    return dfs(0)[1]
};

const buildTree = (nodes, parent) => {
    const tree = {}
    
    for (let i = 0; i < parent.length; i++) {
        const p = parent[i]
        if (p === -1) continue
        
        if (!tree[p]) tree[p] = []
        tree[p].push(i)
    }
    
    return tree
}
```

## 413. Arithmetic Slices
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var numberOfArithmeticSlices = function(A) {
    let result = 0
    let count = 0
    
    for (let i = 2; i < A.length; i++) {
        if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {
            count++
            result += count
        } else {
            count = 0
        }
    }
    
    return result
};
```

## 300. Longest Increasing Subsequence
```javascript
// O(n^2) time O(n) space
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    if (!nums.length) return 0
    
    const dp = Array(nums.length).fill(1)
    
    let max = 1
    
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[j] + 1, dp[i])
                max = Math.max(max, dp[i])
            }
        }
    }
    
    return max
};

// O(n log n) time O(n) space
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
   const dp = []
   
   for (const num of nums) {
       if (!dp.length || num > dp[dp.length - 1]) {
           dp.push(num)           
           continue
       }
       
       const index = binarySearch(dp, num)
       dp[index] = num
   }
    
   return dp.length
};

const binarySearch = (arr, target) => {
    let low = 0
    let high = arr.length - 1
    
    while (low < high) {
        const mid = Math.floor((high - low) / 2) + low
        
        if (arr[mid] >= target) {
            high = mid
        } else {
            low = mid + 1
        }
    }
    
    return low
}
```

## 334. Increasing Triplet Subsequence
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    let min1 = Infinity
    let min2 = Infinity
    
    for (const num of nums) {
        if (num <= min1) {
            min1 = num
        } else if (num <= min2) {
            min2 = num
        } else {
            return true
        }
    }
    
    return false
};
```

## 251. Flatten 2D Vector
```javascript
/**
 * @param {number[][]} v
 */
var Vector2D = function(v) {
    this.v = v
    this.i = 0
    this.a = 0
};

/**
 * @return {number}
 */
Vector2D.prototype.next = function() {
    this.nextAvailableIndex()
    return this.v[this.a][this.i++]
};

/**
 * @return {boolean}
 */
Vector2D.prototype.hasNext = function() {
    this.nextAvailableIndex()
    return this.a < this.v.length
};

/** 
 * Your Vector2D object will be instantiated and called as such:
 * var obj = new Vector2D(v)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */

Vector2D.prototype.nextAvailableIndex = function() {
    while (this.a < this.v.length && this.i >= this.v[this.a].length) {
        this.a++
        this.i = 0
    }
};
```

## 769. Max Chunks To Make Sorted
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var maxChunksToSorted = function(arr) {
    let chunks = 0
    let max = 0
    
    for (let i = 0; i < arr.length; i++) {
        max = Math.max(max, arr[i])
        if (max === i) chunks++
    }
    
    return chunks
};
```

## 244. Shortest Word Distance II
```javascript
/**
 * @param {string[]} words
 */
var WordDistance = function(words) {
    this.memo = {}
    this.indices = {}
    this.words = words
    
    for (let i = 0; i < words.length; i++) {
        const word = words[i]
        if (!this.indices[word])
            this.indices[word] = []
        
        this.indices[word].push(i)
    }
};

/** 
 * @param {string} word1 
 * @param {string} word2
 * @return {number}
 */
WordDistance.prototype.shortest = function(word1, word2) {
    const key1 = `${word1}-${word2}`
    const key2 = `${word2}-${word1}`
    
    if (this.memo[key1])
        return this.memo[key1]
    
    const dist = this.shortestWordDistance(word1, word2)
    this.memo[key1] = dist
    this.memo[key2] = dist
    return dist
};

/** 
 * Your WordDistance object will be instantiated and called as such:
 * var obj = new WordDistance(words)
 * var param_1 = obj.shortest(word1,word2)
 */

WordDistance.prototype.shortestWordDistance = function(word1, word2) {
    let dist = this.words.length
    
    const arr1 = this.indices[word1]
    const arr2 = this.indices[word2]
    let p = 0
    let q = 0

    while (p < arr1.length && q < arr2.length) {
        dist = Math.min(dist, Math.abs(arr1[p] - arr2[q]))
        arr1[p] > arr2[q] ? q++ : p++
    }
    
    return dist
}
```

## 245. Shortest Word Distance III
```javascript
/**
 * @param {string[]} words
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var shortestWordDistance = function(words, word1, word2) {
    let i1 = -1
    let i2 = -1
    const same = word1 === word2
    let dist = words.length
    
    for (const [index, word] of words.entries()) {
        if (word === word1) {
            if (same) {
                i1 = i2
                i2 = index
            } else {
                i1 = index
            }
        } else if (word === word2) {
            i2 = index
        }
        
        if (i1 !== -1 && i2 !== -1)
            dist = Math.min(dist, Math.abs(i1 - i2))
    }
    
    return dist    
};
```

## 281. Zigzag Iterator
```javascript
/**
 * @constructor
 * @param {Integer[]} v1
 * @param {Integer[]} v1
 */
var ZigzagIterator = function ZigzagIterator(v1, v2) {
    this.k = 2
    this.lists = []
    this.indices = []
    
    if (v1.length) {
        this.lists.push(v1)
        this.indices.push(0)
    }
    
    if (v2.length) {
        this.lists.push(v2)
        this.indices.push(0)
    }
};

/**
 * @this ZigzagIterator
 * @returns {boolean}
 */
ZigzagIterator.prototype.hasNext = function hasNext() {
    return this.lists.length
};

/**
 * @this ZigzagIterator
 * @returns {integer}
 */
ZigzagIterator.prototype.next = function next() {
    const currList = this.lists.shift()
    let currIndex = this.indices.shift()
    const result = currList[currIndex++]
    
    if (currIndex < currList.length) {
        this.lists.push(currList)
        this.indices.push(currIndex)
    }
    
    return result
};

/**
 * Your ZigzagIterator will be called like this:
 * var i = new ZigzagIterator(v1, v2), a = [];
 * while (i.hasNext()) a.push(i.next());
*/
```

## 284. Peeking Iterator
```javascript
/**
 * // This is the Iterator's API interface.
 * // You should not implement it, or speculate about its implementation.
 * function Iterator() {
 *    @ return {number}
 *    this.next = function() { // return the next number of the iterator
 *       ...
 *    }; 
 *
 *    @return {boolean}
 *    this.hasNext = function() { // return true if it still has numbers
 *       ...
 *    };
 * };
 */

/**
 * @param {Iterator} iterator
 */
var PeekingIterator = function(iterator) {
    this.iterator = iterator
    this.hasPeeked = false
    this.peekElement = null
};

/**
 * @return {number}
 */
PeekingIterator.prototype.peek = function() {
    if (!this.hasPeeked) {
        this.hasPeeked = true
        this.peekElement = this.iterator.next()
    }
    
    return this.peekElement
};

/**
 * @return {number}
 */
PeekingIterator.prototype.next = function() {
    if (!this.hasPeeked) {
        return this.iterator.next()
    }
    
    const result = this.peekElement
    this.hasPeeked = false
    this.peekElement = null
    return result
};

/**
 * @return {boolean}
 */
PeekingIterator.prototype.hasNext = function() {
    return this.hasPeeked || this.iterator.hasNext()
};

/** 
 * Your PeekingIterator object will be instantiated and called as such:
 * var obj = new PeekingIterator(arr)
 * var param_1 = obj.peek()
 * var param_2 = obj.next()
 * var param_3 = obj.hasNext()
 */
```

## 540. Single Element in a Sorted Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
    let left = 0
    let right = nums.length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        const isEven = (right - mid) % 2 === 0
        
        if (nums[mid] === nums[mid - 1]) {
            if (isEven) {
                right = mid - 2
            } else {
                left = mid + 1
            }
        } else if (nums[mid] === nums[mid + 1]) {
            if (isEven) {
                left = mid + 2
            } else {
                right = mid - 1
            }
        } else {
            return nums[mid]
        }
    }
    
    return nums[left]
};
```

## 1143. Longest Common Subsequence
```javascript
// Top-Down Recursive
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    const lCS = (i, j) => {
        if (i < 0 || j < 0) 
            return 0
        
        if (memo[i][j] !== -1) 
            return memo[i][j]
        
        if (text1[i] === text2[j]) {
            memo[i][j] = 1 + lCS(i - 1, j - 1)
        } else {
            memo[i][j] = Math.max(lCS(i - 1, j), lCS(i, j - 1))
        }
        
        return memo[i][j]
    }
    
    const memo = new Array(text1.length).fill(0).map(a => new Array(text2.length).fill(-1))
    return lCS(text1.length - 1, text2.length - 1)
};

// Bottom Up Iterative O(mn) space
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length
    const n = text2.length
    
    const dp = Array(m + 1).fill(0).map(arr => Array(n + 1).fill(0))
    
    for (let i = 1; i < m + 1; i++) {
        for (let j = 1; j < n + 1; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1]
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
            }
        }
    }
    
    return dp[m][n]
};

// Bottom Up Iterative O(min(m, n)) space
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length
    const n = text2.length
    
    const dp = Array(2).fill(0).map(arr => Array(n + 1).fill(0))
    
    for (let i = 1; i < m + 1; i++) {
        for (let j = 1; j < n + 1; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i % 2][j] = 1 + dp[(i - 1) % 2][j - 1]
            } else {
                dp[i % 2][j] = Math.max(dp[(i - 1) % 2][j], dp[i % 2][j - 1])
            }
        }
    }
    
    return dp[m % 2][n]
};
```

## 228. Summary Ranges
```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    const result = []
    
    let start = 0
    for (let end = 1; end <= nums.length; end++) {
        if (nums[end] - nums[end - 1] === 1) {
            continue
        }
        
        const intervalStart = nums[start]
        const intervalEnd = nums[end - 1]
        const interval = formatInterval(intervalStart, intervalEnd)
        result.push(interval)
        start = end
    }
    
    return result
};

const formatInterval = (start, end) => {
    if (start === end) {
        return `${start}`
    }
    
    return `${start}->${end}`
}
```

## 163. Missing Ranges
```javascript
/**
 * @param {number[]} nums
 * @param {number} lower
 * @param {number} upper
 * @return {string[]}
 */
var findMissingRanges = function(nums, lower, upper) {
    if (!nums.length) {
        return [strForRange(lower, upper)]
    }
    
    const result = []
    
    if (nums[0] > lower) {
        result.push(strForRange(lower, nums[0] - 1))
    }
    
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] - 1 !== nums[i - 1] && nums[i] !== nums[i - 1]) {
            result.push(strForRange(nums[i - 1] + 1, nums[i] - 1))
        }
    }
    
    if (nums[nums.length - 1] < upper) {
        result.push(strForRange(nums[nums.length - 1] + 1, upper))
    }
    
    return result
};
    
const strForRange = (start, end) => {
    if (start === end) {
        return `${start}`
    } else {
        return `${start}->${end}`
    }
}
```

## 1390. Four Divisors
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */

var sumFourDivisors = function(nums) {
    let sum = 0
    
    for (const num of nums) {
        sum += sumOfKDivisors(num, 4)
    }
    
    return sum
};

const sumOfKDivisors = (num, k) => {
    let sum = num + 1
    let count = 2
    
    for (let i = 2; i <= Math.sqrt(num); i++) {
        if (num % i !== 0) continue
        
        if (num / i === i) {
            sum += i
            count += 1              
        } else {
            sum += num / i
            sum += i
            count += 2    
        }
        
        if (count > k) break
    }
    
    return count === k ? sum : 0
}
```

## 1328. Break a Palindrome
```javascript
/**
 * @param {string} palindrome
 * @return {string}
 */
var breakPalindrome = function(palindrome) {
    if (palindrome.length <= 1) return ''
    
    const p = palindrome.split('')
    
    let i = 0
    let j = p.length - 1
    
    while (i < j) {
        const char1 = p[i]
        const char2 = p[j]
        
        if (char1 !== 'a') {
            p[i] = 'a'
            return p.join('')
        }
        
        i++
        j--
    }
    
    p[p.length - 1] = 'b'
    return p.join('')
};
```

## 165. Compare Version Numbers
```javascript
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
    let p = 0
    let q = 0
    let pNum = 0
    let qNum = 0
    
    while (p < version1.length || q < version2.length) {    
        while (p < version1.length && version1[p] !== '.') {
            pNum *= 10
            pNum += +version1[p++]
        }
        
        while (q < version2.length && version2[q] !== '.') {
            qNum *= 10
            qNum += +version2[q++]
        }
        
        if (pNum > qNum) {
            return 1
        } else if (pNum < qNum) {
            return -1
        }
        
        p++
        q++
        pNum = 0
        qNum = 0
    }
    
    return 0
};
```

## 573. Squirrel Simulation
```javascript
/**
 * @param {number} height
 * @param {number} width
 * @param {number[]} tree
 * @param {number[]} squirrel
 * @param {number[][]} nuts
 * @return {number}
 */
var minDistance = function(height, width, tree, squirrel, nuts) {
    let dist = 0
    let savings = -Number.MAX_VALUE
    
    for (const nut of nuts) {
        const currDist = distance(nut, tree)
        dist += currDist * 2
        savings = Math.max(savings, currDist - distance(nut, squirrel))
    }
    
    return dist - savings
};

const distance = (a, b) => {
    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1])
}
```

## 1456. Maximum Number of Vowels in a Substring of Given Length
```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var maxVowels = function(s, k) {
    const vowels = new Set('aeiou')
    let max = 0
    let count = 0
    
    for (let i = 0; i < s.length; i++) {
        if (vowels.has(s[i])) {
            count++
        }
        
        if (i >= k && vowels.has(s[i - k])) {
            count--
        }
        
        max = Math.max(max, count)
    }
    
    return max
};
```

## 694. Number of Distinct Islands
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var numDistinctIslands = function(grid) {
    const rowLen = grid.length
    const colLen = grid[0].length
    
    const unique = new Set()
    
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (grid[row][col] === 1) {
                const island = getIsland(grid, row, col)
                unique.add(island)
            }
        }
    }
    
    return unique.size
};

const getIsland = (grid, startRow, startCol) => {
    const rowLen = grid.length
    const colLen = grid[0].length
    
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    
    const result = []
    grid[startRow][startCol] = 0
    
    const queue = [[startRow, startCol]]
    while (queue.length) {
        const [row, col] = queue.shift()
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen) {
                continue
            }
            
            if (grid[nextRow][nextCol] === 0) {
                continue
            }
            
            grid[nextRow][nextCol] = 0
            result.push([nextRow - startRow, nextCol - startCol])
            queue.push([nextRow, nextCol])
        }
    }
    
    return result.join('')
}

/**
 * @param {number[][]} grid
 * @return {number}
 */
var numDistinctIslands = function(grid) {
    const islands = new Set()
    
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (!grid[row][col]) continue
            const shape = floodFill(grid, row, col, [])
            islands.add(shape)
        }
    }
    
    return islands.size
};

const floodFill = (grid, originRow, originCol, path) => {
    const _floodFill = (row, col, dir) => {
        if (row < 0 || col < 0 || 
            row >= grid.length || col >= grid[0].length || 
            grid[row][col] === 0) return
        
        grid[row][col] = 0
        
        path.push(dir)

        _floodFill(row + 1, col, 'D')
        _floodFill(row - 1, col, 'U')
        _floodFill(row, col + 1, 'R')
        _floodFill(row, col - 1, 'L')
        
        path.push('E')
    }
    
    _floodFill(originRow, originCol, 'S')
    return path.join('')
}
```

## 670. Maximum Swap
```javascript
/**
 * @param {number} num
 * @return {number}
 */
var maximumSwap = function(num) {
    let nums = []
    let maxes = []
    let maxNum = -1
    let maxIdx = -1
    let idx = 0
    
    while (num) {
        const digit = num % 10
        nums.push(digit)
        maxes.push([maxNum, maxIdx])
        
        if (maxNum < digit) {
            maxNum = digit
            maxIdx = idx
        }
        
        idx++
        num = Math.floor(num / 10)
    }
    
    for (let i = nums.length - 1; i >= 0; i--) {
        const [mNum, mIdx] = maxes[i]
        
        if (nums[i] < mNum) {
            const temp = nums[i]
            nums[i] = nums[mIdx]
            nums[mIdx] = temp
            break
        }
    }
    
    let result = 0
    for (let i = nums.length - 1; i >= 0; i--) {
        result *= 10
        result += nums[i]
    }
    
    return result
};
```

## 380. Insert Delete GetRandom O(1)
```javascript
/**
 * Initialize your data structure here.
 */
var RandomizedSet = function() {
    this.elements = []
    this.indexMap = {}
};

/**
 * Inserts a value to the set. Returns true if the set did not already contain the specified element. 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
    if (this.indexMap[val] !== undefined) {
        return false
    }
    
    this.elements.push(val)
    this.indexMap[val] = this.elements.length - 1
    return true
};

/**
 * Removes a value from the set. Returns true if the set contained the specified element. 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
    if (this.indexMap[val] === undefined) {
        return false
    }
    
    const lastVal = this.elements[this.elements.length - 1]
    const valIndex = this.indexMap[val]
    
    this.elements[valIndex] = lastVal
    this.indexMap[lastVal] = valIndex
    
    this.elements.pop()
    delete this.indexMap[val]
    
    return true
};

/**
 * Get a random element from the set.
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
    const randomIndex = Math.trunc(Math.random() * this.elements.length)
    return this.elements[randomIndex]
};

/** 
 * Your RandomizedSet object will be instantiated and called as such:
 * var obj = new RandomizedSet()
 * var param_1 = obj.insert(val)
 * var param_2 = obj.remove(val)
 * var param_3 = obj.getRandom()
 */
```

## 1457. Pseudo-Palindromic Paths in a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var pseudoPalindromicPaths  = function(root) {
    const dfs = (node, bin) => {
        if (!node) return
        
        bin ^= 1 << (node.val - 1)
        
        if (!node.left && !node.right) {    
            if ((bin & (bin - 1)) === 0)
                count++
            
            return
        }
        
        dfs(node.left, bin)
        dfs(node.right, bin)
    }
    
    let count = 0
    dfs(root, 0)
    return count
};
```

## 161. One Edit Distance
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isOneEditDistance = function(s1, s2) {
    if (!s1.length && !s2.length) return 0
    
    const long = s1.length < s2.length ? s2 : s1
    const short = s1.length < s2.length ? s1 : s2
    const diff = long.length - short.length
    if (diff > 1) return false
    
    let mismatch = 0
    let l = 0
    let s = 0
    
    while (l < long.length || s < short.length) {
        if (long[l] !== short[s]) {
            mismatch++
            
            if (mismatch > 1) return false
            
            if (diff > 0) {
                l++
                continue
            }
        }
        
        l++
        s++
    }

    return mismatch === 1
};
```

## 1295. Find Numbers with Even Number of Digits
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumbers = function(nums) {
    let count = 0
    
    for (const num of nums) {
        count += isEven(Math.floor(Math.log10(num)) + 1)
    }
    
    return count
};

const isEven = num => num % 2 === 0
```

## 1146. Snapshot Array
```javascript
/**
 * @param {number} length
 */
var SnapshotArray = function(length) {
    this.arr = Array(length).fill(0).map(a => [])
    this.currSnap = 0
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
SnapshotArray.prototype.set = function(i, val) {
    const last = this.arr[i].length - 1
    if (!this.arr[i].length || this.arr[i][last][0] !== this.currSnap) {
        this.arr[i].push([this.currSnap, val])
    } else {
        this.arr[i][last][1] = val
    }
};

/**
 * @return {number}
 */
SnapshotArray.prototype.snap = function() {
   return this.currSnap++
};

/** 
 * @param {number} index 
 * @param {number} snap_id
 * @return {number}
 */
SnapshotArray.prototype.get = function(i, snap_id) {
    const elements = this.arr[i]
    if (!elements.length) return 0
    
    const index = this.binarySearch(elements, snap_id)
    if (index === -1) return 0
    
    return elements[index][1]
};

/** 
 * Your SnapshotArray object will be instantiated and called as such:
 * var obj = new SnapshotArray(length)
 * obj.set(index,val)
 * var param_2 = obj.snap()
 * var param_3 = obj.get(index,snap_id)
 */

SnapshotArray.prototype.binarySearch = function(arr, target) {
    let left = 0
    let right = arr.length - 1
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid][0] === target) {
            return mid
        } else if (arr[mid][0] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return right
};
```

## 771. Jewels and Stones
```javascript
/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    const jewels = new Set(J)
    
    let count = 0
    
    for (const s of S) {
        count += jewels.has(s)
    }
    
    return count
};
```

## 359. Logger Rate Limiter
```javascript
/**
 * Initialize your data structure here.
 */
var Logger = function() {
    this.log = {}
};

/**
 * Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity. 
 * @param {number} timestamp 
 * @param {string} message
 * @return {boolean}
 */
Logger.prototype.shouldPrintMessage = function(timestamp, message) {
    if (this.log[message] === undefined || this.log[message] + 10 <= timestamp) {
        this.log[message] = timestamp
        return true
    }
    return false
};

/** 
 * Your Logger object will be instantiated and called as such:
 * var obj = new Logger()
 * var param_1 = obj.shouldPrintMessage(timestamp,message)
 */
```

## 811. Subdomain Visit Count
```javascript
/**
 * @param {string[]} cpdomains
 * @return {string[]}
 */
var subdomainVisits = function(cpdomains) {
    const map = {}
    
    for (const cpdomain of cpdomains) {
        const [visits, domain] = cpdomain.split(' ')
        
        let validSubdomain = true
        for (let i = 0; i < domain.length; i++) {
            if (validSubdomain) {
                const subdomain = domain.slice(i)
                
                if (!map[subdomain]) 
                    map[subdomain] = 0
                
                map[subdomain] += +visits
                validSubdomain = false
            }
            
            validSubdomain = domain[i] === '.'
        }
    }
    
    return Object.entries(map).map(pair => `${pair[1]} ${pair[0]}`)
};
```

## 1464. Maximum Product of Two Elements in an Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let max1 = 0
    let max2 = 0
    
    for (const num of nums) {
        if (num > max1) {
            max2 = max1
            max1 = num
        } else if (num > max2) {
            max2 = num
        }
    }
    
    
    return (max1 - 1) * (max2 - 1)
};
```

## 1460. Make Two Arrays Equal by Reversing Sub-arrays
```javascript
/**
 * @param {number[]} target
 * @param {number[]} arr
 * @return {boolean}
 */
var canBeEqual = function(target, arr) {
    const buckets = Array(1001).fill(0)
    
    for (let i = 0; i < target.length; i++) {
        buckets[target[i]]++
        buckets[arr[i]]--
    }
    
    for (const bucket of buckets) {
        if (bucket !== 0) return false
    }
    
    return true
};
```

## 406. Queue Reconstruction by Height
```javascript
// O(n^2)
/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function(people) {
    people.sort((a, b) => b[0] - a[0] || a[1] - b[1])
    
    const result = []
    
    for (const [height, order] of people) {
        result.splice(order, 0, [height, order])
    }
    
    return result
};
```

## 1237. Find Positive Integer Solution for a Given Equation
```javascript
// Linear
/**
 * // This is the CustomFunction's API interface.
 * // You should not implement it, or speculate about its implementation
 * function CustomFunction() {
 *     @param {integer, integer} x, y
 *     @return {integer}
 *     this.f = function(x, y) {
 *         ...
 *     };
 * };
 */

/**
 * @param {CustomFunction} customfunction
 * @param {integer} z
 * @return {integer[][]}
 */
var findSolution = function(customfunction, z) {
    const pairs = []
    
    let x = 1
    let y = 1000
    
    while (x <= 1000 && y >= 1) {
        const result = customfunction.f(x, y)
        if (result > z) {
            y--
        } else if (result < z) {
            x++
        } else {
            pairs.push([x, y])
            x++
            y--
        }
    }
    
    return pairs
};

// Binary Search
/**
 * // This is the CustomFunction's API interface.
 * // You should not implement it, or speculate about its implementation
 * function CustomFunction() {
 *     @param {integer, integer} x, y
 *     @return {integer}
 *     this.f = function(x, y) {
 *         ...
 *     };
 * };
 */

/**
 * @param {CustomFunction} customfunction
 * @param {integer} z
 * @return {integer[][]}
 */
var findSolution = function(customfunction, z) {
    const pairs = []
    
    for (let x = 1; x <= 1000; x++) {
        const y = binarySearch(customfunction, x, z)
        if (y === -1) continue
        pairs.push([x, y])
    }
    
    return pairs
};

const binarySearch = (customfunction, x, target) => {
    let left = 1
    let right = 1000
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        const result = customfunction.f(x, mid)
        if (result === target) {
            return mid
        } else if (result < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1
}
```

## 96. Unique Binary Search Trees
```javascript
// Top Down DP
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    const _numTrees = (n) => {
        if (n <= 1) return 1
        
        if (memo[n] !== undefined) {
            return memo[n]
        }
        
        let count = 0
        for (let mid = 1; mid <= n; mid++) {
            count += _numTrees(mid - 1) * _numTrees(n - mid)
        }
        
        memo[n] = count
        return count
    }
    
    const memo = {}
    return _numTrees(n)
};

// Bottom Up DP
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    const dp = new Array(n + 1).fill(0)
    dp[0] = 1
    dp[1] = 1
    
    for (let nodeCount = 2; nodeCount <= n; nodeCount++) {
        for (let mid = 1; mid <= nodeCount; mid++) {
            dp[nodeCount] += dp[mid - 1] * dp[nodeCount - mid]
        }
    }
    
    return dp[n]
};
```

## 1337. The K Weakest Rows in a Matrix
```javascript
/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number[]}
 */
var kWeakestRows = function(mat, k) {
    const counts = getCounts(mat)
    
    const buckets = Array(101).fill(null)
    for (const [row, count] of counts) {
        if (!buckets[count]) buckets[count] = []
        buckets[count].push(row)
    }
    
    const result = []
    for (let i = 0; i < buckets.length; i++) {
        if (buckets[i] === null) continue
        
        for (let j = 0; j < buckets[i].length; j++) {
            result.push(buckets[i][j])
            if (result.length === k) return result
        }
    }
    
    return result
};

const getCounts = matrix => {
    const counts = []
    
    for (let row = 0; row < matrix.length; row++) {
        const count = binarySearch(matrix[row])
        counts.push([row, count])
    }
    
    return counts
}

const binarySearch = arr => {
    let left = 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid] === 1) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left
}

// Linear Scan
/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number[]}
 */
var kWeakestRows = function(mat, k) {
    const rowLength = mat.length
    const colLength = mat[0].length
    
    const result = []
    
    for (let col = 0; col < colLength; col++) {
        for (let row = 0; row < rowLength; row++) {
            if (mat[row][col] === 0 && (col === 0 || mat[row][col - 1] === 1)) {
                result.push(row)
                if (result.length === k) return result
            }
        }
    }
    
    if (result.length < k) {
        for (let row = 0; row < rowLength; row++) {
            if (mat[row][colLength - 1] === 1) {
                result.push(row)
                
                if (result.length === k) return result
            }
        }
    }
    
    return result
};
```

## 48. Rotate Image
```javascript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    const n = matrix.length
    
    for (let layer = 0; layer < Math.floor(n / 2); layer++) {
        for (let i = layer; i < n - layer - 1; i++) {
            const top = matrix[layer][i]
            matrix[layer][i] = matrix[n - i - 1][layer]
            matrix[n - i - 1][layer] = matrix[n - 1 - layer][n - i - 1]
            matrix[n - 1 - layer][n - i - 1] = matrix[i][n - layer - 1]
            matrix[i][n - layer - 1] = top
        }
    }
};
```

## 322. Coin Change
```javascript
// Top Down
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    const _coinChange = (sum) => {
        if (sum === amount) {
            return 0
        }
        
        if (sum > amount) {
            return Infinity
        }
        
        if (memo[sum] !== undefined) {
            return memo[sum]
        }
        
        let min = Infinity
        for (const coin of coins) {
           min = Math.min(min, 1 + _coinChange(sum + coin))
        }
        
        memo[sum] = min
        return memo[sum]
    }
    
    const memo = {}
    const result = _coinChange(0, 0)
    return result === Infinity ? -1 : result
};

// Bottom Up
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity)
    dp[0] = 0
    
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], 1 + dp[i - coin])
            }
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount]
};

// BFS
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    const queue = [0]
    let level = 0
    const visited = new Set()
    while (queue.length) {
        const length = queue.length
        for (let i = 0; i < length; i++) {
            const curr = queue.shift()
            
            if (curr === amount) {
                return level
            }
            
            for (const coin of coins) {
                if (visited.has(curr + coin)) continue
                if (curr + coin > amount) continue
                queue.push(curr + coin)
                visited.add(curr + coin)
            }
        }
        
        level++
    }
    
    return -1
};
```

## 983. Minimum Cost For Tickets
```javascript
// Top Down
/**
 * @param {number[]} days
 * @param {number[]} costs
 * @return {number}
 */
var mincostTickets = function(days, costs) {
    const _mincostTickets = day => {
        if (day <= 0) return 0
        if (memo[day]) return memo[day]
        
        if (travelDays.has(day)) {
            memo[day] = Math.min(_mincostTickets(day - 1) + costs[0],
                                 _mincostTickets(day - 7) + costs[1],
                                 _mincostTickets(day - 30) + costs[2])
        } else {
            memo[day] = Math.min(_mincostTickets(day - 1))
        }
        
        return memo[day]
    }
    
    const travelDays = new Set(days)
    const memo = {}
    return _mincostTickets(365)
};

// Bottom Up
/**
 * @param {number[]} days
 * @param {number[]} costs
 * @return {number}
 */
var mincostTickets = function(days, costs) {
    const travelDays = new Set(days)
    const dp = Array(366).fill(Number.MAX_VALUE)
    dp[0] = 0
    
    for (let day = 1; day <= 365; day++) {
        if (!travelDays.has(day)) {
            dp[day] = dp[day - 1]
        } else {
            dp[day] = Math.min(dp[day], dp[day - 1] + costs[0])
            
            if (day - 7 >= 0) {
                dp[day] = Math.min(dp[day], dp[day - 7] + costs[1])
            } else {
                dp[day] = Math.min(dp[day], costs[1])
            }
            
            if (day - 30 >= 0) {
                dp[day] = Math.min(dp[day], dp[day - 30] + costs[2])
            } else {
                dp[day] = Math.min(dp[day], costs[2])
            }
        }
    }
    
    return dp[365]
};
```

## 999. Available Captures for Rook
```javascript
/**
 * @param {character[][]} board
 * @return {number}
 */
var numRookCaptures = function(board) {
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (board[row][col] === 'R') {
                return capture(board, row, col)
            }
        }
    }
    
    return 0
};

const capture = (board, row, col) => {
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    let captured = 0
    
    for (const [dRow, dCol] of dirs) {
        let currRow = row + dRow
        let currCol = col + dCol
        
        while (currRow >= 0 && currRow < 8 && currCol >= 0 && currCol < 8) {
            if (board[currRow][currCol] === 'p') {
                captured++
                break
            }
            
            if (board[currRow][currCol] === 'B') break
            
            currRow += dRow
            currCol += dCol    
        }
    }
    
    return captured
}
```

## 821. Shortest Distance to a Character
```javascript
/**
 * @param {string} S
 * @param {character} C
 * @return {number[]}
 */
var shortestToChar = function(S, C) {
    const result = Array(S.length).fill(0)
    
    let prev = Number.MAX_VALUE
    for (let i = 0; i < S.length; i++) {
        if (S[i] === C) 
            prev = i
        
        result[i] = Math.abs(i - prev)
    }
    
    prev = Number.MAX_VALUE
    for (let i = S.length - 1; i >= 0; i--) {
        if (S[i] === C) 
            prev = i
        
        result[i] = Math.min(result[i], Math.abs(i - prev))
    }
    
    return result
};
```

## 1394. Find Lucky Integer in an Array
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var findLucky = function(arr) {
    const buckets = Array(501).fill(0)
    
    for (const a of arr) {
        buckets[a]++
    }
    
    for (let i = buckets.length - 1; i > 0; i--) {
        if (buckets[i] === i)
            return i
    }
    
    return -1
};
```

## 1469. Find All the Lonely Nodes
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var getLonelyNodes = function(root) {
    const dfs = (node, isLonely) => {
        if (!node) return
        
        if (isLonely) {
            lonely.push(node.val)
        }
        
        dfs(node.left, !node.right)
        dfs(node.right, !node.left)
    }
    
    const lonely = []
    dfs(root)
    return lonely
};
```

## 1048. Longest String Chain
```javascript
/**
 * @param {string[]} words
 * @return {number}
 */
var longestStrChain = function(words) {
    const set = new Set(words)
    const graph = buildGraph(words, set)
    const dp = {}
    
    let result = 1
    for (const [vertex, edges] of Object.entries(graph)) {
        if (dp[vertex]) continue
        longest(vertex, graph, dp)
    }
    
    return Math.max(result, ...Object.values(dp))
};

const longest = (vertex, graph, dp) => {
    if (dp[vertex]) return dp[vertex]
    
    dp[vertex] = 1
    if (graph[vertex]) {
        for (const neighbor of graph[vertex]) {
           dp[vertex] = Math.max(dp[vertex], 1 + longest(neighbor, graph, dp)) 
        }
    }
    
    return dp[vertex]
}

const buildGraph = (words, set) => {
    const graph = {}
    
    for (const word of words) {
        for (let i = 0; i < word.length; i++) {
            const neighbor = word.slice(0, i) + word.slice(i + 1)
            if (!set.has(neighbor)) continue
            if (!graph[word]) graph[word] = []
            graph[word].push(neighbor)
        }
    }
    
    return graph
}
```

## 104. Maximum Depth of Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (!root) return 0
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
};
```

## 152. Maximum Product Subarray
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let maxP = 1
    let minP = 1
    let max = nums[0]
    
    for (const num of nums) {
        const temp = maxP * num
        maxP = Math.max(maxP * num, minP * num, num)
        minP = Math.min(temp, minP * num, num)
        max = Math.max(maxP, max)
    }
    
    return max
};
```

## 516. Longest Palindromic Subsequence
```javascript
// Top Down DP
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function(s) {
    const _longestPalindromeSubseq = (start, end) => {
        if (memo[start][end]) 
            return memo[start][end]
        
        if (start === end) return 1
        if (start > end) return 0
        
        if (s[start] === s[end]) {
            memo[start][end] = 2 + _longestPalindromeSubseq(start + 1, end - 1)
        } else {
            memo[start][end] = Math.max(_longestPalindromeSubseq(start + 1, end), 
                                        _longestPalindromeSubseq(start, end - 1))
        }
        
        return memo[start][end]
    }
    
    const memo = Array(s.length).fill(0).map(a => Array(s.length).fill(0))
    return _longestPalindromeSubseq(0, s.length - 1)
};

// Bottom Up DP
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function(s) {
    const n = s.length
    const dp = new Array(n).fill().map(a => new Array(n).fill(0))
    for (let len = 1; len <= n; len++) {
        for (let start = 0; start <= n - len; start++) {
            const end = start + len - 1
            
            if (start === end) {
                dp[start][end] = 1
                continue
            }
            
            if (s[start] === s[end]) {
                dp[start][end] = 2 + dp[start + 1][end - 1]
                continue
            }
            
            dp[start][end] = Math.max(dp[start + 1][end], dp[start][end - 1])
        }
    }
    
    return dp[0][n - 1]
};
```

## 1470. Shuffle the Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number[]}
 */
var shuffle = function(nums, n) {
    for (let i = 0; i < n; i++) {
        nums[i] <<= 10
        nums[i] |= nums[i + n]
    }
    
    let j = nums.length - 1
    for (let i = n - 1; i >= 0; i--) {
        const num1 = nums[i] & 1023
        const num2 = nums[i] >> 10
        
        nums[j] = num1
        nums[j - 1] = num2
        j -= 2 
    }
    
    return nums
};

/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number[]}
 */
var shuffle = function(nums, n) {
    const arr = []
    for (let x = 0; x < n; x++) {
        arr.push(nums[x])
        arr.push(nums[x + n])
    }
    
    return arr
};
```

## 1472. Design Browser History
```javascript
/**
 * @param {string} homepage
 */
var BrowserHistory = function(homepage) {
    this.history = [homepage]
    this.currIndex = 0
    this.rightIndex = 0
};

/** 
 * @param {string} url
 * @return {void}
 */
BrowserHistory.prototype.visit = function(url) {
    this.currIndex++
    this.rightIndex = this.currIndex
    this.history[this.currIndex] = url
};

/** 
 * @param {number} steps
 * @return {string}
 */
BrowserHistory.prototype.back = function(steps) {
    this.currIndex = Math.max(0, this.currIndex - steps)
    return this.history[this.currIndex]
};

/** 
 * @param {number} steps
 * @return {string}
 */
BrowserHistory.prototype.forward = function(steps) {
    this.currIndex = Math.min(this.rightIndex, this.currIndex + steps)
    return this.history[this.currIndex]
};

/** 
 * Your BrowserHistory object will be instantiated and called as such:
 * var obj = new BrowserHistory(homepage)
 * obj.visit(url)
 * var param_2 = obj.back(steps)
 * var param_3 = obj.forward(steps)
 */
```

## 1451. Rearrange Words in a Sentence
```javascript
// O(n log n) custom sort
/**
 * @param {string} text
 * @return {string}
 */
var arrangeWords = function(text) {
    const words = text.split(' ')
    words[0] = words[0].toLowerCase()
    
    const sortedWords = []
    for (const [index, word] of words.entries()) {
        sortedWords.push([word, index, word.length])
    }
    
    sortedWords.sort((a, b) => a[2] - b[2] || a[1] - a[1])
    
    const result = sortedWords.map(word => word[0])
    result[0] = capitalize(result[0])
    return result.join(' ')
};

const capitalize = word => {
    const chars = word.split('')
    chars[0] = chars[0].toUpperCase() 
    return chars.join('')
}

// O(n) map
/**
 * @param {string} text
 * @return {string}
 */
var arrangeWords = function(text) {
    const words = text.split(' ')
    words[0] = words[0].toLowerCase()
    
    const map = {}
    for (const word of words) {
        if (!map[word.length]) map[word.length] = []
        map[word.length].push(word)
    }
    
    const result = []
    for (const [key, val] of Object.entries(map)) {
        for (const word of val) {
            result.push(word)
        }
    }
    result[0] = capitalize(result[0])
    return result.join(' ')
};

const capitalize = word => {
    const chars = word.split('')
    chars[0] = chars[0].toUpperCase() 
    return chars.join('')
}
```

## 1432. Max Difference You Can Get From Changing an Integer
```javascript
/**
 * @param {number} num
 * @return {number}
 */
var maxDiff = function(num) {
    const a = `${num}`.split('')
    const b = `${num}`.split('')
    
    for (let i = 0; i < a.length; i++) {
        if (a[i] <= 1) continue
        
        if (i === 0) {
            replace(a, a[i], 1)
        } else {
            replace(a, a[i], 0)
        }
        
        break
    }
    
    for (let i = 0; i < b.length; i++) {
        if (b[i] == 9) continue
        replace(b, b[i], 9)
        break
    }
    
    return +b.join('') - +a.join('')
};

const replace = (arr, prev, next) => {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === prev) {
            arr[i] = next
        }
    }
}
```

## 799. Champagne Tower
```javascript
/**
 * @param {number} poured
 * @param {number} query_row
 * @param {number} query_glass
 * @return {number}
 */
var champagneTower = function(poured, query_row, query_glass) {
    let prevRow = [poured]
    for (let i = 0; i < query_row; i++) {
        const nextRow = Array(prevRow.length + 1).fill(0)
        
        for (let j = 0; j < prevRow.length; j++) {
            const amount = (prevRow[j] - 1) / 2
            if (amount <= 0) continue
            nextRow[j] += amount
            nextRow[j + 1] += amount
        }
        
        prevRow = nextRow
    }
    
    return Math.min(prevRow[query_glass], 1)  
};
```

## 279. Perfect Squares
```javascript
// Top Down DP
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
    const _numSquares = (n) => {
        if (n <= 0) return 0
        if (memo[n]) return memo[n]
        
        memo[n] = Infinity
        
        for (let square = 1; square ** 2 <= n; square++) {
            memo[n] = Math.min(memo[n], 1 + _numSquares(n - square ** 2))
        }
        
        return memo[n]
    }
    
    const memo = {}
    return _numSquares(n)
};

// Bottom Up DP
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
    const dp = Array(n + 1).fill(Infinity)
    dp[0] = 0
    
    for (let num = 1; num <= n; num++) {
        for (let square = 1; square ** 2 <= num; square++) {
            dp[num] = Math.min(dp[num], 1 + dp[num - square ** 2])
        }
    }
    
    return dp[n]
};

// Bottom Up DP with global cache
/**
 * @param {number} n
 * @return {number}
 */

const dp = [0, 1]

var numSquares = function(n) {
    while (dp.length <= n) {
        const m = dp.length
        let result = Infinity
        
        for (let i = 1; i ** 2 <= m; i++) {
            result = Math.min(result, 1 + dp[m - i ** 2])
        }
        
        dp.push(result)
    }
    
    return dp[n]
};

// BFS
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
    const squares = []
    for (let i = 1; i ** 2 <= n; i++) {
        squares.push(i ** 2)
    }
    
    const queue = [0]
    const visited = new Set()
    let level = 0
    
    while (queue.length) {
        const size = queue.length
        
        for (let i = 0; i < size; i++) {
            const num = queue.shift()
            
            if (num === n)
                return level
            
            if (num > n) continue
            
            for (const square of squares) {
                if (visited.has(num + square)) continue
                visited.add(num + square)
                queue.push(num + square)
            }
        }
        
        level++
    }
    
    return level
};
```

## 1474. Delete N Nodes After M Nodes of a Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
var deleteNodes = function(head, m, n) {
    let curr = head
    
    while (curr) {
        let i = m - 1
        while (i-- && curr) {
            curr = curr.next
        }
        
        let prev = curr
        let j = n + 1
        while (j-- && curr) {
            curr = curr.next
        }
        
        if (prev) prev.next = curr
    }
    
    return head
};
```

## 412. Fizz Buzz
```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    const result = []
    for (let num = 1; num <= n; num++) {
        if (num % 15 === 0) {
            result.push('FizzBuzz')
        } else if (num % 3 === 0) {
            result.push('Fizz')
        } else if (num % 5 === 0) {
            result.push('Buzz')
        } else {
            result.push(`${num}`)
        }
    }
    
    return result
};
```

## 265. Paint House II
```javascript
// Top Down DP O(k^2 * n) Time O(N*K) Space
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCostII = function(costs) {
    const _minCostII = (house, color) => {
        if (memo[house][color] !== Infinity) 
            return memo[house][color]
        
        if (house === costs.length - 1) 
            return costs[house][color]
        
        let min = Infinity
        for (let i = 0; i < costs[house].length; i++) {
            if (color === i) continue
            min = Math.min(min, _minCostII(house + 1, i))
        }
        
        memo[house][color] = costs[house][color] + min
        return memo[house][color]
    }
    
    if (!costs.length) return 0
    
    const memo = Array(costs.length).fill(0).map(a => Array(costs[0].length).fill(Infinity))
    
    let min = Infinity
    for (let color = 0; color < costs[0].length; color++) {
        min = Math.min(min, _minCostII(0, color))
    }
    
    return min
};

// Bottom Up DP O(k^2 * n) Time O(N*K) Space
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCostII = function(costs) {
    if (!costs.length) return 0
    
    const houses = costs.length
    const colors = costs[0].length
    
    const dp = Array(houses).fill(0).map(a => Array(colors).fill(0))
    dp[0] = costs[0]
    
    for (let house = 1; house < houses; house++) {
        for (let color = 0; color < colors; color++) {
            let min = Infinity
            
            for (let prevColor = 0; prevColor < colors; prevColor++) {
                if (color === prevColor) continue
                min = Math.min(min, dp[house - 1][prevColor])
            }
            
            dp[house][color] = costs[house][color] + min
        }
    }
    
    return Math.min(...dp[dp.length - 1])
};

// Bottom Up DP O(k^2 * n) Time O(K) Space
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCostII = function(costs) {
    if (!costs.length) return 0
    
    const houses = costs.length
    const colors = costs[0].length
    
    let prevRow = costs[0]
    
    for (let house = 1; house < houses; house++) {
        const currRow = Array(colors).fill(0)
        
        for (let color = 0; color < colors; color++) {
            let min = Infinity
            
            for (let prevColor = 0; prevColor < colors; prevColor++) {
                if (color === prevColor) continue
                min = Math.min(min, prevRow[prevColor])
            }
            
            currRow[color] = costs[house][color] + min
        }
        
        prevRow = currRow
    }
    
    return Math.min(...prevRow)
};
// Bottom Up DP O(n*k) time O(k) space
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCostII = function(costs) {
    if (!costs.length) return 0
    
    const houses = costs.length
    const colors = costs[0].length
    
    let prevRow = costs[0]
    
    for (let house = 1; house < houses; house++) {
        let min1 = -1
        let min2 = -1
        for (let color = 0; color < colors; color++) {
            const cost = prevRow[color]
            
            if (min1 === -1 || cost < prevRow[min1]) {
                min2 = min1
                min1 = color
            } else if (min2 === -1 || cost < prevRow[min2]) {
                min2 = color
            }
        }

        const currRow = Array(colors).fill(0)
        for (let color = 0; color < colors; color++) {
            if (color === min1) {
                currRow[color] = costs[house][color] + prevRow[min2]
            } else {
                currRow[color] = costs[house][color] + prevRow[min1]
            }
        }

        prevRow = currRow
    }
    
    return Math.min(...prevRow)
};

// Bottom Up DP O(n*k) time O(1) space
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCostII = function(costs) {
    if (!costs.length) return 0
    
    const houses = costs.length
    const colors = costs[0].length
    
    let prevMin1 = -1
    let prevMin2 = -1
    let prevMin1Color = -1
    
    for (let color = 0; color < colors; color++) {
        const cost = costs[0][color]
        
        if (prevMin1 === -1 || cost < prevMin1) {
            prevMin2 = prevMin1
            prevMin1 = cost
            prevMin1Color = color
        } else if (prevMin2 === -1 || cost < prevMin2) {
            prevMin2 = cost
        }
        
    }
    
    for (let house = 1; house < houses; house++) {
        let min1 = -1
        let min2 = -1
        let min1Color = -1
        
        for (let color = 0; color < colors; color++) {
            let cost = costs[house][color]
            
            if (color === prevMin1Color) {
                cost += prevMin2
            } else {
                cost += prevMin1
            }
            
            if (min1 === -1 || cost < min1) {
                min2 = min1
                min1Color = color
                min1 = cost
            } else if (min2 === -1 || cost < min2) {
                min2 = cost
            }
        }

        prevMin1 = min1
        prevMin2 = min2
        prevMin1Color = min1Color
    }
    
    return prevMin1
};
```

## 1480. Running Sum of 1d Array
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var runningSum = function(nums) {
    for (let i = 1; i < nums.length; i++) {
        nums[i] += nums[i - 1]
    }
    
    return nums
};
```

## 120. Triangle
```javascript
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
    for (let i = 1; i < triangle.length; i++) {
        const prevRow = triangle[i - 1]
        const row = triangle[i]
        
        for (let j = 0; j < row.length; j++) {
            const prevLeft = prevRow[j - 1] === undefined ? Infinity : prevRow[j - 1]
            const prevRight = prevRow[j] === undefined ? Infinity : prevRow[j]
            row[j] += Math.min(prevLeft, prevRight)
        }
    }
    
    return Math.min(...triangle[triangle.length - 1])
};
```

## 95. Unique Binary Search Trees II
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
    const _generateTrees = (start, end) => {
        const nodes = []
        
        if (start > end) {
            nodes.push(null)
            return nodes
        }
        
        for (let rootVal = start; rootVal <= end; rootVal++) {
            const leftNodes = _generateTrees(start, rootVal - 1)
            const rightNodes = _generateTrees(rootVal + 1, end)
            
            for (const left of leftNodes) {
                for (const right of rightNodes) {
                    const root = new TreeNode(rootVal, left, right)
                    nodes.push(root)
                }
            }
        }
        
        return nodes
    }
    
    if (n === 0) return []
    return _generateTrees(1, n)
};
```

## 213. House Robber II
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if (nums.length === 1) return nums[0]
    return Math.max(robHouses(0, nums.length - 2, nums), robHouses(1, nums.length - 1, nums))
};

const robHouses = (start, end, nums) => {
    let prev = 0
    let curr = 0
    
    for (let i = start; i <= end; i++) {
        const temp = curr
        curr = Math.max(nums[i] + prev, curr)
        prev = temp
    }
    
    return curr
}
```

## 1426. Counting Elements
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var countElements = function(arr) {
    const buckets = Array(1001).fill(0)
    for (const a of arr) {
        buckets[a]++
    }
    
    let count = 0
    for (let i = 0; i < buckets.length - 1; i++) {
        if (buckets[i + 1] !== 0) {
            count += buckets[i]
        }
    }
    
    return count
};
```

## 788. Rotated Digits
```javascript
// Brute Force
/**
 * @param {number} N
 * @return {number}
 */
var rotatedDigits = function(N) {
    let count = 0
    
    for (let num = 1; num <= N; num++) {
        count += isGoodNumber(num)
    }
    
    return count
};

const map = { 0: 0, 1: 1, 8: 8, 2: 5, 5: 2, 6: 9, 9: 6 }
const memo = {}

const isGoodNumber = num => {
    if (memo[num]) return memo[num]
    
    let flipNum = 0
    let place = 1
    let n = num
    
    while (n > 0) {
        let digit = map[n % 10]
        if (digit === undefined) return false
        
        digit *= place
        place *= 10
        
        flipNum += digit
        n = Math.floor(n / 10)
    }
    
    
    memo[num] = flipNum !== num
    return memo[num]
}
```

## 108. Convert Sorted Array to Binary Search Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    const _sortedArrayToBST = (left, right) => {
        if (left > right) return null
        
        const mid = Math.trunc((right - left) / 2) + left
        const node = new TreeNode(nums[mid])
        node.left = _sortedArrayToBST(left, mid - 1)
        node.right = _sortedArrayToBST(mid + 1, right)
        return node
    }
    
    return _sortedArrayToBST(0, nums.length - 1)
};
```

## 377. Combination Sum IV
```javascript
// Top Down DP
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var combinationSum4 = function(nums, target) {
    const _combinationSum4 = (sum) => {
        if (memo[sum] !== undefined)
            return memo[sum]

        if (sum > target)
            return 0
        
        if (sum === target)
            return 1
        
        memo[sum] = 0
        for (const num of nums) {
            memo[sum] += _combinationSum4(sum + num)
        }
        
        return memo[sum]
    }
    
    if (!nums.length) return 0
    const memo = Array(target + 1).fill()
    return _combinationSum4(0)
};

// Bottom Up DP
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var combinationSum4 = function(nums, target) {
    const dp = Array(target + 1).fill(0)
    dp[0] = 1
    
    for (let i = 1; i <= target; i++) {
        for (const num of nums) {
            if (i < num) continue
            dp[i] = dp[i] + dp[i - num]
        }
    }
    
    return dp[target]
};
```

## 518. Coin Change 2
```javascript
// Top Down DP
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
    const _change = (i, sum) => {
        if (sum === amount) return 1
        if (sum > amount || i >= coins.length) return 0
        
        if (memo[i][sum] !== undefined) {
            return memo[i][sum]
        }
        
        let count = 0
        count += _change(i, sum + coins[i])
        count += _change(i + 1, sum)
        memo[i][sum] = count
        return count
    }
    
    const memo = new Array(coins.length).fill().map(a => new Array(amount))
    return _change(0, 0)
};

// Bottom Up DP
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
    const dp = Array(amount + 1).fill(0)
    dp[0] = 1
    
    for (const coin of coins) {
        for (let i = 1; i <= amount; i++) {
            if (i < coin) continue
            dp[i] += dp[i - coin]
        }
    }
    
    return dp[amount]
};
```

## 494. Target Sum
```javascript
// Top Down DP
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    const _findTargetSumWays = (i, sum) => {
        if (i >= nums.length) {
            return sum === S
        }
        
        const key = `${i}-${sum}`
        if (memo[key] !== undefined) {
            return memo[key]
        }
        
        let count = 0
        count += _findTargetSumWays(i + 1, sum + nums[i])
        count += _findTargetSumWays(i + 1, sum - nums[i])
        
        memo[key] = count
        return count
    }
    
    const memo = {}
    return _findTargetSumWays(0, 0)
};

// Bottom Up DP O(n^2) Space
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    if (S > 1000) return 0
    
    const dp = Array(nums.length).fill().map(a => Array(2001).fill(0))
    dp[0][nums[0] + 1000] += 1
    dp[0][-nums[0] + 1000] += 1
    
    for (let i = 1; i < nums.length; i++) {
        for (let sum = -1000; sum <= 1000; sum++) {
            if (dp[i - 1][sum + 1000] > 0) {
                dp[i][sum + nums[i] + 1000] += dp[i - 1][sum + 1000]
                dp[i][sum - nums[i] + 1000] += dp[i - 1][sum + 1000]
            }
        }
    }
    
    return dp[nums.length - 1][S + 1000]
};

// Bottom Up DP O(n) Space
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    if (S > 1000) return 0
    
    let prevRow = Array(2001).fill(0)
    prevRow[nums[0] + 1000] += 1
    prevRow[-nums[0] + 1000] += 1
    
    for (let i = 1; i < nums.length; i++) {
        const currRow = Array(2001).fill(0)
        
        for (let sum = -1000; sum <= 1000; sum++) {
            if (prevRow[sum + 1000] > 0) {
                currRow[sum + nums[i] + 1000] += prevRow[sum + 1000]
                currRow[sum - nums[i] + 1000] += prevRow[sum + 1000]
            }
        }
        
        prevRow = currRow
    }
    
    return prevRow[S + 1000]
};
```

## 1495. Friendly Movies Streamed Last Month
```sql
# Write your MySQL query statement below
SELECT DISTINCT title
FROM Content
JOIN TVProgram
USING(content_id)
WHERE content_type = 'Movies'
    AND MONTH(program_date) = 6
    AND YEAR(program_date) = 2020
    AND Kids_content = 'Y'
```

## 1493. Longest Subarray of 1's After Deleting One Element
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSubarray = function(nums) {
    let i = 0
    let deletes = 0
    let count = 0
    let max = 0
    
    nums[i] ? count++ : deletes++
    
    for (let j = 1; j < nums.length; j++) {
        nums[j] ? count++ : deletes++
        max = Math.max(max, count)
        
        while (deletes > 1 && i < nums.length) {
            nums[i] ? count-- : deletes--
            i++
        }
    }
    
    return max - (count === nums.length)
};
```

## 1491. Average Salary Excluding the Minimum and Maximum Salary
```javascript
/**
 * @param {number[]} salary
 * @return {number}
 */
var average = function(salary) {
    let sum = 0
    let max = salary[0]
    let min = salary[0]
    
    for (const num of salary) {
        sum += num
        max = Math.max(max, num)
        min = Math.min(min, num)
    }
    
    return (sum - max - min) / (salary.length - 2)
};
```

## 1496. Path Crossing
```javascript
/**
 * @param {string} path
 * @return {boolean}
 */
var isPathCrossing = function(path) {
    const set = new Set()
    let curr = [0, 0]
    set.add(curr.toString())
    
    for (const p of path) {
        switch (p) {
            case 'N':
                curr[0]++
                break
            case 'S':
                curr[0]--
                break
            case 'E':
                curr[1]++
                break
            case 'W':
                curr[1]--
                break
        }
        
        if (set.has(curr.toString()))
            return true
            
        set.add(curr.toString())
    }
    
    return false
};
```

## 13. Roman to Integer
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }
    
    let int = 0
    let i = 0
    while (i < s.length) {
        const curr = s[i]
        const next = s[i + 1]
        
        if (next && map[curr] < map[next]) {
            int += map[next] - map[curr]
            i += 2
        } else {
            int += map[curr]
            i++
        }
    }
    
    return int
};
```

## 1184. Distance Between Bus Stops
```javascript
/**
 * @param {number[]} distance
 * @param {number} start
 * @param {number} destination
 * @return {number}
 */
var distanceBetweenBusStops = function(distance, start, destination) {
    let totalSum = 0
    for (const d of distance) {
        totalSum += d
    }
    
    let s = Math.min(start, destination)
    let e = Math.max(start, destination)
    
    let leftSum = 0
    for (let i = s; i < e; i++) {
        leftSum += distance[i]
    }
    
    return Math.min(leftSum, totalSum - leftSum)
    
};

/**
 * @param {number[]} distance
 * @param {number} start
 * @param {number} destination
 * @return {number}
 */
var distanceBetweenBusStops = function(distance, start, destination) {
    const graph = {}
    for (let i = 0; i < distance.length; i++) {
        const i2 = (i + 1) % distance.length
        
        if (!graph[i]) graph[i] = []
        if (!graph[i2]) graph[i2] = []
        
        graph[i].push([i2, distance[i]])
        graph[i2].push([i, distance[i]])
    }
    
    return dfs(graph, start, destination)
};

const dfs = (graph, start, destination) => {
    const _dfs = (vertex, prev, dist) => {
        if (vertex === destination) {
            return dist
        }
        
        let min = Infinity
        
        for (const [neighbor, weight] of graph[vertex]) {
            if (neighbor === prev) continue
            min = Math.min(min, _dfs(neighbor, vertex, dist + weight))
        }
        
        return min
    }
    
    return _dfs(start, start, 0)
}
```

## 416. Partition Equal Subset Sum
```javascript
// Top Down DP
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    const _canPartition = (sum, i) => {
        if (sum === target)
            return true
        
        if (sum > target || i >= nums.length)
            return false
        
        if (memo[sum][i] !== undefined) 
            return memo[sum][i]
        
        memo[sum][i] = _canPartition(sum, i + 1) || _canPartition(sum + nums[i], i + 1)
        return memo[sum][i]
    }
    
    let sum = 0
    for (const num of nums) {
        sum += num
    }
    
    if (sum % 2 !== 0)
        return false
    
    const target = sum / 2
    const memo = new Array(target + 1).fill().map(a => Array(nums.length).fill())
    return _canPartition(0, 0)
};

// Bottom Up DP - O(mn) space
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    let sum = 0
    
    for (const num of nums) {
        sum += num
    }
    
    if (sum % 2 !== 0)
        return false
    
    const target = sum / 2
    
    const dp = Array(nums.length + 1).fill().map(a => Array(target + 1).fill(false))
    for (let i = 0; i < dp.length; i++) {
        dp[i][0] = true
    }
    
    for (let i = 1; i < dp.length; i++) {
        for (let j = 1; j <= target; j++) {
            dp[i][j] = dp[i - 1][j]
            
            if (j < nums[i - 1]) continue
            dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]]
        }
    }
    
    return dp[nums.length][target]
};

// Bottom Up DP - O(n) space
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    let sum = 0
    for (const num of nums) {
        sum += num
    }
    
    if (sum % 2 !== 0)
        return false
    
    const target = sum / 2
    let prev = Array(target + 1).fill(false)
    prev[0] = true
    
    for (let i = 1; i <= nums.length; i++) {
        const curr = Array(target + 1).fill(false)
        curr[0] = true
        
        for (let j = 1; j <= target; j++) {
            curr[j] = prev[j]
            
            if (j < nums[i - 1]) continue
            curr[j] = prev[j] || prev[j - nums[i - 1]]
        }
        
        prev = curr
    }
    
    return prev[target]
};
```

## 1422. Maximum Score After Splitting a String
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maxScore = function(s) {
    let max = 0
    let rightScore = 0
    for (const char of s) {
        rightScore += +char
    }
    
    let leftScore = 0
    for (let i = 0; i < s.length - 1; i++) {
        +s[i] ? rightScore-- : leftScore++
        max = Math.max(max, leftScore + rightScore)
    }
    
    return max
};
```

## 304. Range Sum Query 2D - Immutable
```javascript
/**
 * @param {number[][]} matrix
 */
var NumMatrix = function(matrix) {
    if (!matrix.length) return
    
    const m = matrix.length + 1
    const n = matrix[0].length + 1
    
    this.dp = Array(m).fill().map(a => Array(n).fill(0))
    
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            this.dp[row][col] = this.dp[row - 1][col] + 
                                this.dp[row][col - 1] -
                                this.dp[row - 1][col - 1] + 
                                matrix[row - 1][col - 1]
        }
    }    
};

/** 
 * @param {number} row1 
 * @param {number} col1 
 * @param {number} row2 
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
    return this.dp[row2 + 1][col2 + 1] - 
           this.dp[row1][col2 + 1] - 
           this.dp[row2 + 1][col1] + 
           this.dp[row1][col1]
};

/** 
 * Your NumMatrix object will be instantiated and called as such:
 * var obj = new NumMatrix(matrix)
 * var param_1 = obj.sumRegion(row1,col1,row2,col2)
 */
```

## 718. Maximum Length of Repeated Subarray
```javascript
// Top Down DP
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
    const _findLength = (i, j, length) => {
        if (i < 0 || j < 0) {
            return length
        }
        
        if (memo[i][j][length] !== undefined)
            return memo[i][j][length]
        
        let lcs1 = length
        if (A[i] === B[j])
            lcs1 = _findLength(i - 1, j - 1, length + 1)
        
        memo[i][j][length] = Math.max(lcs1, _findLength(i, j - 1, 0), _findLength(i - 1, j, 0))
        return memo[i][j][length]
    }
    
    const aLen = A.length + 1
    const bLen = B.length + 1
    const memo = Array(aLen).fill()
                    .map(a => Array(bLen).fill()
                    .map(a => Array(Math.max(aLen, bLen)).fill()))
    
    return _findLength(A.length - 1, B.length - 1, 0)
};

// Bottom Up DP

```

## 1218. Longest Arithmetic Subsequence of Given Difference
```javascript
/**
 * @param {number[]} arr
 * @param {number} difference
 * @return {number}
 */
var longestSubsequence = function(arr, difference) {
    const map = {}
    let max = 1
    
    for (let i = 0; i < arr.length; i++) {
        map[arr[i]] = 1 + (map[arr[i] - difference] || 0)
        max = Math.max(max, map[arr[i]])
    }
    
    return max
};
```

## 1027. Longest Arithmetic Sequence
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var longestArithSeqLength = function(A) {
    const map = {}
    let max = 2
    for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
            const diff = A[i] - A[j]
            const count = (map[`${i}-${diff}`] || 1) + 1
            map[`${j}-${diff}`] = count
            max = Math.max(max, count)
        }
    }
    
    return max
};
```

## 1271. Hexspeak
```javascript
/**
 * @param {string} num
 * @return {string}
 */
var toHexspeak = function(num) {
    const set = new Set("ABCDEFIO")
    const hex = (+num).toString(16).toUpperCase().split('')
    
    for (let i = 0; i < hex.length; i++) {
        if (hex[i] == 0) {
            hex[i] = 'O'
        } else if (hex[i] == 1) {
            hex[i] = 'I'
        }
    }
    
    for (const char of hex) {
        if (!set.has(char)) return "ERROR"
    }
    
    return hex.join('')
};

/**
 * @param {string} num
 * @return {string}
 */
var toHexspeak = function(num) {
    const hex = []
    const hexMap = 'OI23456789ABCDEF'
    
    while (num) {
        const digit = num % 16
        
        if (digit >= 2 && digit <= 9)
            return 'ERROR'
        
        hex.push(hexMap[digit])
        num = Math.floor(num / 16)
    }
    
    hex.reverse()
    return hex.join('')
};
```

## 997. Find the Town Judge
```javascript
/**
 * @param {number} N
 * @param {number[][]} trust
 * @return {number}
 */
var findJudge = function(N, trust) {
    const degrees = Array(N + 1).fill(0)
    for (const [u, v] of trust) {
        degrees[u]--
        degrees[v]++
    }
    
    for (let vertex = 1; vertex <= N; vertex++) {
        if (degrees[vertex] === N - 1)
            return vertex
    }
    
    return -1
};
```

## 1139. Largest 1-Bordered Square
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var largest1BorderedSquare = function(grid) {
    const m = grid.length
    const n = grid[0].length
    
    const dp = Array(m + 1).fill(0)
                .map(a => Array(n + 1).fill(0)
                .map(a => Array(2).fill(0)))
    
    let max = 0
    for (let row = 1; row <= m; row++) {
        for (let col = 1; col <= n; col++) {
            if (grid[row - 1][col - 1] === 0) continue
            dp[row][col][0] = dp[row - 1][col][0] + 1
            dp[row][col][1] = dp[row][col - 1][1] + 1
            
            const len = Math.min(dp[row][col][0], dp[row][col][1])
            if (len <= max) continue
            
            for (let k = len; k > max; k--) {
                if (dp[row - k + 1][col][1] >= k && dp[row][col - k + 1][0] >= k) {
                    max = Math.max(max, k)
                    break
                }
            }
        }
    }
    
    return max * max
};
```

## 764. Largest Plus Sign
```javascript
/**
 * @param {number} N
 * @param {number[][]} mines
 * @return {number}
 */
var orderOfLargestPlusSign = function(N, mines) {
    const dp = Array(N).fill().map(a => Array(N).fill(1))
    let max = 0
    
    const banned = new Set()
    for (const [row, col] of mines) {
        banned.add(row * N + col)
    }
    
    for (let row = 0; row < N; row++) {  
        let count = 0
        for (let col = 0; col < N; col++) {
            count = banned.has(row * N + col) ? 0 : count + 1
            dp[row][col] = count
        }
        
        count = 0
        for (let col = N - 1; col >= 0; col--) {
            count = banned.has(row * N + col) ? 0 : count + 1
            dp[row][col] = Math.min(dp[row][col], count)
        }
    }
    
    for (let col = 0; col < N; col++) {  
        let count = 0
        for (let row = 0; row < N; row++) {
            count = banned.has(row * N + col) ? 0 : count + 1
            dp[row][col] = Math.min(dp[row][col], count)
        }
        
        count = 0
        for (let row = N - 1; row >= 0; row--) {
            count = banned.has(row * N + col) ? 0 : count + 1
            dp[row][col] = Math.min(dp[row][col], count)
            max = Math.max(dp[row][col], max)
        }
    }
    
    return max
};
```

## 506. Relative Ranks
```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var findRelativeRanks = function(nums) {
    const sorted = nums.slice().sort((a, b) => b - a)
    const map = {}
    for (let i = 0; i < sorted.length; i++) {
        switch (i) {
            case 0:
                map[sorted[i]] = 'Gold Medal'
                break
            case 1:
                map[sorted[i]] = 'Silver Medal'
                break
            case 2:
                map[sorted[i]] = 'Bronze Medal'
                break
            default:
                map[sorted[i]] = `${i + 1}`
        }
    }
    
    return nums.map(num => map[num])
};
```

## 750. Number Of Corner Rectangles
```javascript
// Brute Force - n^2 * m^2
/**
 * @param {number[][]} grid
 * @return {number}
 */
var countCornerRectangles = function(grid) {
    const m = grid.length
    const n = grid[0].length
    let count = 0
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] !== 1) continue
            
            for (let i = row - 1; i >= 0; i--) {
                if (grid[i][col] !== 1) continue
                
                for (let j = col - 1; j >= 0; j--) {
                    if (grid[row][j] !== 1) continue
                    
                    if (grid[i][j] === 1) {
                        count++
                    }
                }
            }
        }
    }
    
    return count
};

// Combinations - m^2 * 2
/**
 * @param {number[][]} grid
 * @return {number}
 */
var countCornerRectangles = function(grid) {
    const m = grid.length
    const n = grid[0].length
    let result = 0
    
    for (let row1 = 0; row1 < m; row1++) {
        for (let row2 = row1 + 1; row2 < m; row2++) {
            let count = 0
            
            for (let col = 0; col < n; col++) {
                count += grid[row1][col] & grid[row2][col]
            }
            
            result += (count * (count - 1)) / 2
        }
    }
    
    return result
};

// Bottom Up DP O(m * n^2)
/**
 * @param {number[][]} grid
 * @return {number}
 */
var countCornerRectangles = function(grid) {
    const m = grid.length
    const n = grid[0].length
    let result = 0
    const dp = Array(n).fill().map(a => Array(n).fill(0))

    for (let row = 0; row < m; row++) {
        for (let col1 = 0; col1 < n; col1++) {
            if (grid[row][col1] === 0) continue
            
            for (let col2 = col1 + 1; col2 < n; col2++) {
                if (grid[row][col2] === 0) continue
                result += dp[col1][col2]++
            }   
        }
    }
    
    return result
};
```

## 650. 2 Keys Keyboard
```javascript
// Top Down DP
/**
 * @param {number} n
 * @return {number}
 */
var minSteps = function(n) {
    const _minSteps = (count, clipboard) => {
        if (count > n) {
            return Infinity
        }
        
        if (count === n) {
            return 0
        }
        
        if (memo[count][clipboard] !== undefined) {
            return memo[count][clipboard]
        }
        
        let min = Infinity
        
        // paste
        if (clipboard > 0) {
            min = 1 + _minSteps(count + clipboard, clipboard)
        }
        
        // copy + paste
        min = Math.min(min, 2 + _minSteps(count + count, count))
        
        memo[count][clipboard] = min
        return min
    }
    
    const memo = new Array(n).fill().map(a => new Array(n))
    return _minSteps(1, 0)
};

// Bottom Up DP
/**
 * @param {number} n
 * @return {number}
 */
var minSteps = function(n) {
    const dp = Array(n + 1).fill(0)
    
    for (let i = 2; i <= n; i++) {
        dp[i] = i
        for (let j = Math.floor(i / 2); j >= 1; j--) {
            if (i % j !== 0) continue
            dp[i] = Math.min(dp[i], dp[j] + i / j)
        }
    }
    
    return dp[n]
};
```

## 935. Knight Dialer
```javascript
// Top Down DP
/**
 * @param {number} N
 * @return {number}
 */
var knightDialer = function(N) {
    const _knightDialer = (num, N) => {
        if (N === 0) return 1
        if (memo[num][N] !== undefined) return memo[num][N]
        
        memo[num][N] = 0
        for (const neighbor of graph[num]) {
            memo[num][N] += _knightDialer(neighbor, N - 1)
            memo[num][N] %= MOD
        }
        
        return memo[num][N]
    }
    
    if (N === 1) return 10
    
    const graph = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [0,1,7], [2,6], [1,3], [4,2]]
    const memo = Array(10).fill().map(a => Array(N).fill())
    const MOD = 10 ** 9 + 7
    
    let result = 0
    for (let num = 0; num <= 9; num++) {
        result += _knightDialer(num, N - 1)
        result %= MOD
    }
    
    return result
};

// Bottom Up DP
/**
 * @param {number} N
 * @return {number}
 */
var knightDialer = function(N) {
    const graph = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [0,1,7], [2,6], [1,3], [4,2]]
    const MOD = 10 ** 9 + 7
    let prevRow = Array(10).fill(1)
    
    for (let i = 1; i < N; i++) {
        const currRow = Array(10).fill(0)
        
        for (let key = 0; key <= 9; key++) {
            for (const neighbor of graph[key]) {
                currRow[neighbor] += prevRow[key]
                currRow[neighbor] %= MOD
            }
        }
        
        prevRow = currRow
    }
    
    let result = 0
    for (const num of prevRow) {
        result += num
        result %= MOD
    }
    return result
};
```

## 139. Word Break
```javascript
// Top Down DP - Time: O(n^3) Space: O(n)
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
    const _wordBreak = start => {
        if (start >= s.length) return true
        
        if (memo[start] !== undefined) {
            return memo[start]
        }
        
        for (let i = start; i < Math.min(start + maxLen, s.length); i++) {
            const subtr = s.slice(start, i + 1)
            if (!seen.has(subtr) || !_wordBreak(i + 1)) continue
            memo[start] = true
            return true
        }
        
        memo[start] = false
        return memo[start]
    }
    
    let maxLen = 0
    for (const word of wordDict) {
        maxLen = Math.max(maxLen, word.length)
    }
    
    const seen = new Set(wordDict)
    const memo = new Array(s.length)
    return _wordBreak(0)
};

// Bottom Up DP
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
    const dict = new Set(wordDict)
    const dp = Array(s.length + 1).fill(false)
    dp[0] = true
    
    for (let i = 1; i <= s.length; i++) {
        for (let j = 0; j < i; j++) {
            if (dp[j] && dict.has(s.slice(j, i))) {
                dp[i] = true
                break
            }
        }
    }
    
    return dp[s.length]
};
```

## 474. Ones and Zeroes
```javascript
// Top Down DP
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function(strs, m, n) {
    const _findMaxForm = (index, m, n) => {
        if (index >= strs.length) return 0
        
        if (memo[index][m][n] !== undefined)
            return memo[index][m][n]
        
        const [mCount, nCount] = count(strs[index], index, cache)
        
        let max = 0
        if (mCount <= m && nCount <= n) {
            max = 1 + _findMaxForm(index + 1, m - mCount, n - nCount)
        }
        
        max = Math.max(max, _findMaxForm(index + 1, m, n))
        memo[index][m][n] = max
        return max
        
    }
    
    const cache = Array(strs.length).fill()
    const memo = Array(strs.length).fill()
                    .map(a => Array(m + 1).fill()
                    .map(a => Array(n + 1).fill()))
    
    return _findMaxForm(0, m, n)
};

const count = (str, index, cache) => {
    if (cache[index] !== undefined)
        return cache[index]
    
    let m = 0
    let n = 0
    
    for (const char of str) {
        char === '1' ? n++ : m++
    }
    
    cache[index] = [m, n]
    return cache[index]
}

// Bottom Up DP O(l * m * n) Space
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function(strs, m, n) {
    const dp = Array(strs.length + 1).fill(0)
                                     .map(a => Array(m + 1).fill(0)
                                     .map(a => Array(n + 1).fill(0)))
    
    for (let i = 1; i <= strs.length; i++) {
        const [mCount, nCount] = count(strs[i - 1], i)
        
        for (let j = 0; j <= m; j++) {
            for (let k = 0; k <= n; k++) {
                if (j >= mCount && k >= nCount) {
                    dp[i][j][k] = Math.max(dp[i - 1][j][k], 1 + dp[i - 1][j - mCount][k - nCount])
                } else {
                    dp[i][j][k] = dp[i - 1][j][k]
                }
            }
        }
    }
    
    return dp[strs.length][m][n]
};
    
const count = (str, index) => {
    let m = 0
    let n = 0
    
    for (const char of str) {
        char === '1' ? n++ : m++
    }
    
    return [m, n]
}

// Bottom Up DP O(m * n) Space
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function(strs, m, n) {
    const dp = Array(m + 1).fill(0).map(a => Array(n + 1).fill(0))
                                     
    
    for (let i = 1; i <= strs.length; i++) {
        const [mCount, nCount] = count(strs[i - 1], i)
        
        for (let j = m; j >= mCount; j--) {
            for (let k = n; k >= nCount; k--) {
                dp[j][k] = Math.max(dp[j][k], 1 + dp[j - mCount][k - nCount])           
            }
        }
    }
    
    return dp[m][n]
};
    
const count = (str, index) => {
    let m = 0
    let n = 0
    
    for (const char of str) {
        char === '1' ? n++ : m++
    }
    
    return [m, n]
}
```

## 1507. Reformat Date
```javascript
/**
 * @param {string} date
 * @return {string}
 */
var reformatDate = function(date) {
    const months = {"Jan" : "01", "Feb": "02", "Mar" : "03", 
                    "Apr": "04", "May" : "05", "Jun" : "06", 
                    "Jul" : "07", "Aug" : "08", "Sep" : "09", 
                    "Oct" : "10", "Nov" : "11", "Dec": "12"}
    
    const [day, month, year] = date.split(' ')
    
    const dayNum = day.split('')
    dayNum.pop()
    dayNum.pop()
    
    if (dayNum.length === 1) 
        dayNum.unshift('0')
    
    return `${year}-${months[month]}-${dayNum.join('')}`
};
```

## 1512. Number of Good Pairs
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var numIdenticalPairs = function(nums) {
    const buckets = Array(101).fill(0)
    for (const num of nums) {
        buckets[num]++
    }
    
    let count = 0
    for (let i = 0; i < buckets.length; i++) {
        if (!buckets[i]) continue
        count += (buckets[i] * (buckets[i] - 1)) / 2
    }
    
    return count
};
```

## 576. Out of Boundary Paths
```javascript
// Top Down DP
/**
 * @param {number} m
 * @param {number} n
 * @param {number} N
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
var findPaths = function(m, n, N, i, j) {
    const _findPaths = (row, col, steps) => {
        if (steps < 0)
            return 0
        
        if (row < 0 || row >= m || col < 0 || col >= n)
            return 1
        
        if (memo[row][col][steps] !== undefined)
            return memo[row][col][steps]
        
        memo[row][col][steps] = 0
        for (const [dRow, dCol] of dirs) {
            memo[row][col][steps] += _findPaths(row + dRow, col + dCol, steps - 1)
            memo[row][col][steps] %= MOD
        }
        
        return memo[row][col][steps]
    }
    
    const MOD = 10 ** 9 + 7
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    const memo = Array(m + 1).fill().map(a => Array(n + 1).fill().map(a => Array(N + 1).fill()))
    return _findPaths(i, j, N)
};

// Bottom Up DP
```

## 1042. Flower Planting With No Adjacent
```javascript
/**
 * @param {number} N
 * @param {number[][]} paths
 * @return {number[]}
 */
var gardenNoAdj = function(N, paths) {
    const result = Array(N + 1).fill()
    const graph = buildGraph(N, paths)
    
    for (let vertex = 1; vertex <= N; vertex++) {
        color(graph, vertex, result)
    }
    
    return result.slice(1)
};

const color = (graph, vertex, result) => {
    const colors = new Set([1, 2, 3, 4])
    for (const neighbor of graph[vertex]) {
        if (!result[neighbor]) continue
        colors.delete(result[neighbor])
    }
    
    for (const c of colors) {
        result[vertex] = c
        break
    }
}

const buildGraph = (N, paths) => {
    const graph = Array(N + 1).fill(0).map(a => [])
    for (const [u, v] of paths) {
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}
```

## 931. Minimum Falling Path Sum
```javascript
// Top Down DP
/**
 * @param {number[][]} A
 * @return {number}
 */
var minFallingPathSum = function(A) {
    const _minFallingPathSum = (row, col) => {
        if (col < 0 || col >= n)
            return Infinity
        
        if (row === A.length)
            return 0
        
        if (memo[row][col] !== undefined)
            return memo[row][col]
        
        memo[row][col] = A[row][col]
        memo[row][col] += Math.min(_minFallingPathSum(row + 1, col - 1),
                                  _minFallingPathSum(row + 1, col),
                                  _minFallingPathSum(row + 1, col + 1))
        
        return memo[row][col]
    }
    
    const m = A.length
    const n = A[0].length
    const memo = Array(m).fill().map(a => Array(n).fill())
    
    let min = Infinity
    for (let col = 0; col < m; col++) {
        min = Math.min(min, _minFallingPathSum(0, col))
    }
    
    return min
};

// Bottom Up DP
/**
 * @param {number[][]} A
 * @return {number}
 */
var minFallingPathSum = function(A) {
    const m = A.length
    const n = A[0].length
    let prevRow = A[0]
    
    for (let row = 1; row < m; row++) {
        const currRow = Array(m).fill()
        for (let col = 0; col < n; col++) {
            currRow[col] = A[row][col]
            currRow[col] += Math.min(prevRow[col - 1] || Infinity, 
                                     prevRow[col] || Infinity, 
                                     prevRow[col + 1] || Infinity)
        }
        
        prevRow = currRow
    }
    
    return Math.min(...prevRow)
};
```

## 401. Binary Watch
```javascript
var readBinaryWatch = function(num) {
    const _readBinaryWatch = (n, hourIndex, minIndex, hours, mins) => {
        if (hours > 11 || mins > 59) return
        
        if (n === 0) {    
            if (mins < 10) mins = `${0}${mins}`    
            
            const time = `${hours}:${mins}`
            times.push(time)
            
            return
        }
        
        for (let i = hourIndex; i < 4; i++) {
            _readBinaryWatch(n - 1, i + 1, minIndex, hours | 1 << i, mins)
        }
        
        for (let i = minIndex; i < 6; i++) {
            _readBinaryWatch(n - 1, 4, i + 1, hours, mins | 1 << i)
        }
    }
    
    const times = []
    _readBinaryWatch(num, 0, 0, 0, 0)
    return times
};
```

## Leetcode 415. Add Strings
```javascript
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
    let result = []
    
    let i = num1.length - 1
    let j = num2.length - 1
    let carry = 0
    
    while (i >= 0 || j >= 0) {
        const digit1 = +num1[i] || 0
        const digit2 = +num2[j] || 0
        
        const sum = digit1 + digit2 + carry
        carry = Math.floor(sum / 10)
        result.push(sum % 10)
        
        i--
        j--
    }
    
    if (carry > 0) {
        result.push(carry)
    }
    
    return result.reverse().join('')
};
```

## 838. Push Dominoes
```javascript
/**
 * @param {string} dominoes
 * @return {string}
 */
var pushDominoes = function(dominoes) {
    const n = dominoes.length
    const result = []
    const forces = Array(n).fill(0)
    
    let currForce = 0
    for (let i = 0; i < n; i++) {
        if (dominoes[i] === 'L') {
            currForce = 0
        } else if (dominoes[i] === 'R') {
            currForce = n
        } else {
            currForce = Math.max(currForce - 1, 0)
        }
        
        forces[i] += currForce
    }
    
    currForce = 0
    for (let i = n - 1; i >= 0; i--) {
        if (dominoes[i] === 'L') {
            currForce = n
        } else if (dominoes[i] === 'R') {
            currForce = 0
        } else {
            currForce = Math.max(currForce - 1, 0)
        }
        
        forces[i] -= currForce
    }
    
    for (const force of forces) {
        if (force < 0) {
            result.push('L')
        } else if (force > 0) {
            result.push('R')
        } else {
            result.push('.')
        }
    }
    
    return result.join('')
};
```

## 361. Bomb Enemy
```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var maxKilledEnemies = function(grid) {
    if (!grid.length) return 0
    
    const m = grid.length
    const n = grid[0].length
    
    const dp = Array(m).fill().map(a => Array(n).fill(0))
    let max = 0
    
    for (let col = 0; col < n; col++) {
        let enemies = 0
        for (let row = 0; row < m; row++) {
            if (grid[row][col] === 'E') {
                enemies++
            } else if (grid[row][col] === 'W') {
                enemies = 0
            }
            
            dp[row][col] += enemies
        }
        
        enemies = 0
        for (let row = m - 1; row >= 0; row--) {
            if (grid[row][col] === 'E') {
                enemies++
            } else if (grid[row][col] === 'W') {
                enemies = 0
            }
            
            dp[row][col] += enemies
        }
    }
    
    for (let row = 0; row < m; row++) {
        let enemies = 0
        for (let col = n - 1; col >= 0; col--) {
            if (grid[row][col] === 'E') {
                enemies++
            } else if (grid[row][col] === 'W') {
                enemies = 0
            }
            
            dp[row][col] += enemies
        }
        
        enemies = 0
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === 'E') {
                enemies++
            } else if (grid[row][col] === 'W') {
                enemies = 0
            }
            
            dp[row][col] += enemies
            
            if (grid[row][col] !== '0') continue
            max = Math.max(max, dp[row][col])
        }
    }
    
    return max
};
```

## 231. Power of Two
```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    return n > 0 && (n & (n - 1)) === 0
};
```

## 1501. Countries You Can Safely Invest In
```javascript
# Write your MySQL query statement below
SELECT name AS country
FROM Country
JOIN (SELECT duration, LEFT(phone_number, 3) AS ccode
      FROM Calls
      JOIN Person
      ON id IN (caller_id, callee_id)) as t1
ON country_code = ccode
GROUP BY name
HAVING AVG(duration) > (SELECT AVG(duration) FROM calls)
```

## 1490. Clone N-ary Tree
```javascript
// BFS
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val === undefined ? 0 : val;
 *    this.children = children === undefined ? [] : children;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneTree = function(root) {
    if (!root) return null
    
    const map = new Map()
    map.set(root, new Node(root.val))
    
    const queue = [root]
    while (queue.length) {
        const node = queue.shift()
        
        for (const child of node.children) {
            if (!map.get(child)) {
                map.set(child, new Node(child.val))
                queue.push(child)
            }
            
            map.get(node).children.push(map.get(child))
        }
    }
    
    return map.get(root)
};
```

## 1511. Customer Order Frequency
```javascript
# Write your MySQL query statement below
SELECT customer_id, name
FROM (SELECT customer_id, name
      FROM Orders
      JOIN Product USING(product_id)
      JOIN Customers USING(customer_id)
      WHERE MONTH(order_date) IN (6, 7)
      GROUP BY customer_id, MONTH(order_date)
      HAVING SUM(quantity * price) >= 100) AS t
GROUP BY customer_id
HAVING COUNT(*) = 2
```

## 1517. Find Users With Valid E-Mails
```javascript
# Write your MySQL query statement below
SELECT *
FROM Users
WHERE mail REGEXP '^[A-Za-z][A-Za-z0-9\_\.\-]*@leetcode\.com'
```

## 1528. Shuffle String
```javascript
/**
 * @param {string} s
 * @param {number[]} indices
 * @return {string}
 */
var restoreString = function(s, indices) {
    const result = Array(s.length).fill()
    
    for (let i = 0; i < s.length; i++) {
        result[indices[i]] = s[i]
    }
    
    return result.join('')
};
```

## 1527. Patients With a Condition
```javascript
# Write your MySQL query statement below
SELECT *
FROM Patients
WHERE conditions LIKE 'DIAB1%' OR conditions LIKE '% DIAB1%'
```

## 1522. Diameter of N-Ary Tree
```javascript
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val === undefined ? 0 : val;
 *    this.children = children === undefined ? [] : children;
 * };
 */

/**
 * @param {Node} root
 * @return {number}
 */
var diameter = function(root) {
    const dfs = node => {
        if (!node) return 0
        
        let max1 = 0
        let max2 = 0
        
        for (const child of node.children) {
            const height = dfs(child)
            if (max1 < height) {
                max2 = max1
                max1 = height
            } else if (max2 < height) {
                max2 = height
            }
        }
        
        max = Math.max(max, max1 + max2)
        return max1 + 1
    }
    
    let max = 0
    dfs(root)
    return max
};
```

## 1513. Number of Substrings With Only 1s
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numSub = function(s) {
    const MOD = 10 ** 9 + 7
    let count = 0
    
    let start = 0
    for (let end = 0; end <= s.length; end++) {
        if (s[end] === '0' || end === s.length) {
            const n = end - start
            count += (n * (n + 1) / 2) % MOD
            start = end + 1
        }
    }
    
    return count
};
```

## 374. Guess Number Higher or Lower
```javascript
/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return 	            -1 if num is lower than the guess number
 *			             1 if num is higher than the guess number
 *                       otherwise return 0
 * var guess = function(num) {}
 */

/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    let left = 1
    let right = n
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        const result = guess(mid)
        
        if (result === 0) {
            return mid
        } else if (result === 1) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
};
```

## 716. Max Stack
```javascript
/**
 * initialize your data structure here.
 */
var MaxStack = function() {
    this.stack = []
    this.max = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MaxStack.prototype.push = function(x) {
    let max = x
    
    if (this.max.length && this.max[this.max.length - 1] > x) {
        max = this.max[this.max.length - 1]
    }
    
    this.max.push(max)
    this.stack.push(x)
};

/**
 * @return {number}
 */
MaxStack.prototype.pop = function() {
    this.max.pop()
    return this.stack.pop()
};

/**
 * @return {number}
 */
MaxStack.prototype.top = function() {
    return this.stack[this.stack.length - 1]
};

/**
 * @return {number}
 */
MaxStack.prototype.peekMax = function() {
    return this.max[this.max.length - 1]
};

/**
 * @return {number}
 */
MaxStack.prototype.popMax = function() {
    const max = this.max[this.max.length - 1]
    const temp = []
    
    while (this.top() !== max)
        temp.push(this.pop())
    
    this.pop()
    
    while (temp.length)
        this.push(temp.pop())
    
    return max
};

/** 
 * Your MaxStack object will be instantiated and called as such:
 * var obj = new MaxStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.peekMax()
 * var param_5 = obj.popMax()
 */
```

## 299. Bulls and Cows
```javascript
/**
 * @param {string} secret
 * @param {string} guess
 * @return {string}
 */
var getHint = function(secret, guess) {
    const counts = Array(10).fill(0)
    let bulls = 0
    let cows = 0

    for (let i = 0; i < guess.length; i++) {
        if (secret[i] === guess[i]) {
            bulls++
        } else {
            if (counts[secret[i]] < 0) cows++
            if (counts[guess[i]] > 0) cows++
            counts[secret[i]]++
            counts[guess[i]]--
        }
    }
    
    return `${bulls}A${cows}B`
};
```

## 137. Single Number II
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let result = 0
    
    for (let i = 0; i < 32; i++) {
        const mask = 1 << i
        let count = 0
        for (const num of nums) {
            if (num & mask) count++
        }
        
        if (count % 3) result |= mask
    }
    
    return result
};
```

## 186. Reverse Words in a String II
```javascript
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseWords = function(s) {
    s.reverse()
    
    let left = 0
    for (let right = 1; right <= s.length; right++) {
        if (right === s.length || s[right] === ' ') {
            reverse(s, left, right - 1)
            left = right + 1
        }
    }
};

const reverse = (arr, left, right) => {
    while (left < right) {
        const temp = arr[left]
        arr[left] = arr[right]
        arr[right] = temp
        
        left++
        right--
    }
}
```

## 1257. Smallest Common Region
```javascript
/**
 * @param {string[][]} regions
 * @param {string} region1
 * @param {string} region2
 * @return {string}
 */
var findSmallestRegion = function(regions, region1, region2) {
    const parents = {}
    for (const region of regions) { 
        for (let i = 1; i < region.length; i++) {
            parents[region[i]] = region[0]
        }
    }
    
    const seen = new Set()
    while (region1) {
        seen.add(region1)
        region1 = parents[region1]
    }
    
    while (!seen.has(region2)) {
        region2 = parents[region2]
    }
    
    return region2
};
```

## 1459. Rectangles Area
```sql
# Write your MySQL query statement below
SELECT p1.id AS P1, 
       p2.id AS P2, 
       ABS(p1.y_value - p2.y_value) * ABS(p1.x_value - p2.x_value) AS AREA
FROM Points AS p1
JOIN Points AS p2
ON p1.id < p2.id
HAVING AREA <> 0
ORDER BY AREA DESC, P1, P2

# Write your MySQL query statement below
SELECT p1.id AS P1, 
       p2.id AS P2, 
       ABS(p1.y_value - p2.y_value) * ABS(p1.x_value - p2.x_value) AS AREA
FROM Points AS p1
JOIN Points AS p2
ON p1.id < p2.id AND p1.x_value <> p2.x_value AND p1.y_value <> p2.y_value
ORDER BY AREA DESC, P1, P2
```

## 1341. Movie Rating
```sql
# Write your MySQL query statement below
(SELECT name AS results
 FROM Movie_Rating
 JOIN Users
 USING(user_id)
 GROUP BY name
 ORDER BY COUNT(*) DESC, name
 LIMIT 1)
UNION
(SELECT title AS results
 FROM Movie_Rating
 JOIN Movies
 USING(movie_id)
 WHERE MONTH(created_at) = 2 AND YEAR(created_at) = 2020
 GROUP BY title
 ORDER BY AVG(rating) DESC, title
 LIMIT 1)
```

## 738. Monotone Increasing Digits
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var monotoneIncreasingDigits = function(N) {
    const str = `${N}`.split('')
    
    let i = 1
    while (i < str.length && str[i - 1] <= str[i]) {
        i++
    }
    
    if (i >= str.length) return N
    
    while (i >= 0 && str[i - 1] > str[i]) {
        i--
        str[i]--
    }
    
    for (let j = i + 1; j < str.length; j++) {
        str[j] = 9
    }
    
    return +str.join('')
};
```

## 970. Powerful Integers
```javascript
/**
 * @param {number} x
 * @param {number} y
 * @param {number} bound
 * @return {number[]}
 */
var powerfulIntegers = function(x, y, bound) {
    const result = new Set()
    
    let maxI = x
    let maxJ = y
    if (x !== 1) maxI = Math.log(bound) / Math.log(x)
    if (y !== 1) maxJ = Math.log(bound) / Math.log(y)
    
    for (let i = 0; i <= maxI; i++) {
        for (let j = 0; j <= maxJ; j++) {
            const num = x**i + y**j
            if (num <= bound) {
                result.add(num)
                continue
            }
            
            break    
        }
    }
    
    return Array.from(result)
};
```

## 624. Maximum Distance in Arrays
```javascript
/**
 * @param {number[][]} arrays
 * @return {number}
 */
var maxDistance = function(arrays) {
    let result = 0
    let max = arrays[0][arrays[0].length - 1]
    let min = arrays[0][0]
    
    for (let i = 1; i < arrays.length; i++) {
        const arr = arrays[i]
        const arrMin = arr[0]
        const arrMax = arr[arr.length - 1]
        
        result = Math.max(result, Math.abs(max - arrMin), Math.abs(min - arrMax))
        max = Math.max(max, arrMax)
        min = Math.min(min, arrMin)
    }
    
    return result
};
```

## 873. Length of Longest Fibonacci Subsequence
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var lenLongestFibSubseq = function(A) {
    const map = {}
    for (let i = 0; i < A.length; i++) {
        map[A[i]] = i
    }
    
    const dp = Array.from(Array(A.length), () => Array(A.length).fill(2))
    let max = 0
    
    for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
            const nextIndex = map[A[i] + A[j]]
            if (nextIndex === undefined) continue
            
            dp[j][nextIndex] = Math.max(dp[j][nextIndex], dp[i][j] + 1)
            max = Math.max(max, dp[j][nextIndex])
        }
    }
    
    return max
};
```

## 6. ZigZag Conversion
```javascript
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows === 1) return s
    
    const matrix = new Array(numRows + 1).fill().map(a => [])
    
    let row = 0
    let dir = -1
    for (const char of s) {
        matrix[row].push(char)
        
        if (row === 0 || row === numRows - 1) {
            dir *= -1
        }
        
        row += dir
    }
    
    return matrix.flat().join('')
};
```

## 616. Add Bold Tag in String
```javascript
/**
 * @param {string} s
 * @param {string[]} dict
 * @return {string}
 */
var addBoldTag = function(s, dict) {
    const marked = Array(s.length).fill(false)
    
    for (let i = 0; i < s.length; i++) {
        for (const word of dict) {
            const candidate = s.slice(i, i + word.length)
            if (candidate === word) {
                mark(marked, i, i + word.length)
            }
        } 
    }
    
    const result = []
    for (let i = 0; i < s.length; i++) {
        if (marked[i] && (i == 0 || !marked[i - 1]))
            result.push("<b>")
        
        result.push(s[i])
        
        if (marked[i] && (i == s.length - 1 || !marked[i + 1]))
            result.push("</b>")
    }
    
    return result.join('')
};

const mark = (marked, start, end) => {
    while (start < end) {
        marked[start] = true
        start++
    }
}
```

## 388. Longest Absolute File Path
```javascript
/**
 * @param {string} input
 * @return {number}
 */
var lengthLongestPath = function(input) {
    const map = { '-1': 0 }
    let max = 0
    
    for (const line of input.split('\n')) {
        let path = line.split('\t')
        path = path[path.length - 1]
        
        const depth = line.length - path.length
        
        if (path.includes('.')) {
            max = Math.max(max, map[depth - 1] + path.length)
        } else {
            map[depth] = map[depth - 1] + path.length + 1
        }
    }
    
    return max
};
```

## 507. Perfect Number
```javascript
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function(num) {
    if (num <= 1) return false
    
    let sum = 1
    
    for (let i = 2; i <= Math.sqrt(num); i++) {
        if (num % i !== 0) continue
        
        sum += i
        sum += num / i
    }
    
    return sum === num
};
```

## 384. Shuffle an Array
```javascript
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.nums = nums  
};

/**
 * Resets the array to its original configuration and return it.
 * @return {number[]}
 */
Solution.prototype.reset = function() {
    return this.nums
};

/**
 * Returns a random shuffling of the array.
 * @return {number[]}
 */
Solution.prototype.shuffle = function() {
    const result = this.nums.slice()
    
    for (let i = result.length - 1; i > 0; i--) {
        const randomIndex = Math.floor(Math.random() * (i + 1))
        
        const temp = result[randomIndex]
        result[randomIndex] = result[i]
        result[i] = temp
    }
    
    return result
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */
```

## 398. Random Pick Index
```javascript
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.nums = nums
};

/** 
 * @param {number} target
 * @return {number}
 */
Solution.prototype.pick = function(target) {
    let result = -1
    let count = 0
    
    for (let i = 0; i < this.nums.length; i++) {
        if (this.nums[i] !== target) continue
        
        const random = Math.floor(Math.random() * (count + 1))
        count++
        
        if (random === 0) result = i
    }
    
    return result
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.pick(target)
 */
```

## 382. Linked List Random Node
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
 * @param {ListNode} head
 */
var Solution = function(head) {
    this.head = head
};

/**
 * Returns a random node's value.
 * @return {number}
 */
Solution.prototype.getRandom = function() {
    let node = this.head
    let result = node.val
    let count = 0
    
    while (node) {
        const random = Math.floor(Math.random() * (count + 1))
        count++
        
        if (random === 0) {
            result = node.val
        }
        
        node = node.next
    }
    
    return result
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(head)
 * var param_1 = obj.getRandom()
 */
```

## 348. Design Tic-Tac-Toe
```javascript
/**
 * Initialize your data structure here.
 * @param {number} n
 */
var TicTacToe = function(n) {
    this.n = n
    this.rows = Array(n).fill(0)
    this.cols = Array(n).fill(0)
    this.diags = Array(2).fill(0)
};

/**
 * Player {player} makes a move at ({row}, {col}).
        @param row The row of the board.
        @param col The column of the board.
        @param player The player, can be either 1 or 2.
        @return The current winning condition, can be either:
                0: No one wins.
                1: Player 1 wins.
                2: Player 2 wins. 
 * @param {number} row 
 * @param {number} col 
 * @param {number} player
 * @return {number}
 */
TicTacToe.prototype.move = function(row, col, player) {
    const currMove = player === 1 ? -1 : 1
    
    this.rows[row] += currMove
    this.cols[col] += currMove
    
    if (row === col) 
        this.diags[0] += currMove
    if (row === this.n - col - 1) 
        this.diags[1] += currMove
    
    if (Math.abs(this.rows[row]) === this.n || 
        Math.abs(this.cols[col]) === this.n || 
        Math.abs(this.diags[0]) === this.n || 
        Math.abs(this.diags[1]) === this.n)
        return player
    
    return 0
};

/** 
 * Your TicTacToe object will be instantiated and called as such:
 * var obj = new TicTacToe(n)
 * var param_1 = obj.move(row,col,player)
 */
```

## 794. Valid Tic-Tac-Toe State
```javascript
/**
 * @param {string[]} board
 * @return {boolean}
 */
var validTicTacToe = function(board) {
    const n = board.length
    let xWins = false
    let oWins = false
    let xCount = 0
    let oCount = 0
    
    const rows = new Array(n).fill(0)
    const cols = new Array(n).fill(0)
    let diag1 = 0
    let diag2 = 0
    
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[row].length; col++) {
            if (board[row][col] === 'O') {
                oCount++
                rows[row]++
                cols[col]++
                if (row - col === 0) diag1++
                if (row + col === 2) diag2++
            } else if (board[row][col] === 'X') {
                xCount++
                rows[row]--
                cols[col]--
                if (row - col === 0) diag1--
                if (row + col === 2) diag2--
            }
        }
    }
    
    for (const row of rows) {
        if (row === n) oWins = true
        if (row === -n) xWins = true
    }
    
    for (const col of cols) {
        if (col === n) oWins = true
        if (col === -n) xWins = true
    }
    
    if (diag1 === n) oWins = true
    if (diag1 === -n) xWins = true
    
    if (diag2 === n) oWins = true
    if (diag2 === -n) xWins = true
    
    if (xWins) return !oWins && xCount - oCount === 1
    if (oWins) return !xWins && xCount === oCount
    return xCount === oCount || xCount - oCount === 1
};
```

## 36. Valid Sudoku
```javascript
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
    const seen = new Set()
    
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board.length; col++) {
            if (board[row][col] === '.') continue
            
            const rowVal = `row-${row}-${board[row][col]}`
            const colVal = `col-${col}-${board[row][col]}`
            const boxVal = `box-${Math.floor(row / 3) * 3 + Math.floor(col / 3)}-${board[row][col]}`
            
            if (seen.has(rowVal) || seen.has(colVal) || seen.has(boxVal))
                return false
            
            seen.add(rowVal)
            seen.add(colVal)
            seen.add(boxVal)
        } 
    }
    
    return true
};
```

## 923. 3Sum With Multiplicity
```javascript
/**
 * @param {number[]} A
 * @param {number} target
 * @return {number}
 */
var threeSumMulti = function(A, target) {
    const MOD = 10 ** 9 + 7
    A.sort((a, b) => a - b)
    
    let count = 0
    
    for (let i = 0; i < A.length; i++) {
        const t = target - A[i]
        let left = i + 1
        let right = A.length - 1
        
        while (left < right) {
            const sum = A[left] + A[right]
            if (sum < t) {
                left++
            } else if (sum > t) {
                right--
            } else if (A[left] !== A[right]) {
                let leftCount = 1
                let rightCount = 1
                
                while (left + 1 < right && A[left] === A[left + 1]) {
                    left++
                    leftCount++
                }
                
                while (right - 1 > left && A[right] === A[right - 1]) {
                    right--
                    rightCount++
                }
                
                count += leftCount * rightCount
                count %= MOD
                left++
                right--
            } else {
                count += (right - left + 1) * (right - left) / 2
                count %= MOD
                break
            }
        }
    }
    
    return count
};
```

## 581. Shortest Unsorted Continuous Subarray
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findUnsortedSubarray = function(nums) {
    let min = Infinity
    let max = -Infinity
    
    let flag = false
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] < nums[i - 1])
            flag = true
        if (flag)
            min = Math.min(min, nums[i])
    }
    
    flag = false
    for (let i = nums.length - 2; i >= 0; i--) {
        if (nums[i + 1] < nums[i])
            flag = true
        if (flag)
            max = Math.max(max, nums[i])
    }
    
    let left = 0
    for (left; left < nums.length; left++) {
        if (min < nums[left]) break
    }
    
    let right = nums.length - 1
    for (right; right >= 0; right--) {
        if (max > nums[right]) break
    }
    
    return right - left < 0 ? 0 : right - left + 1
};
```

## 1506. Find Root of N-Ary Tree
```javascript
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val === undefined ? 0 : val;
 *    this.children = children === undefined ? [] : children;
 * };
 */

/**
 * @param {Node[]} tree
 * @return {Node}
 */
var findRoot = function(tree) {
    let rootVal = 0
    
    for (const node of tree) {
        rootVal ^= node.val
        
        for (const child of node.children) {
            rootVal ^= child.val
        }
    }
    
    for (const node of tree) {
        if (rootVal === node.val) return node
    }
};
```

## 535. Encode and Decode TinyURL
```javascript
/**
 * Encodes a URL to a shortened URL.
 *
 * @param {string} longUrl
 * @return {string}
 */

const map = new Map()
const alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

var encode = function(longUrl) {
    let encodedKey = getRandom()
    while (map.get(encodedKey)) {
        encodedKey = getRandom()
    }
    
    map.set(encodedKey, longUrl)
    return 'tinyurl.com/' + encodedKey
};

/**
 * Decodes a shortened URL to its original URL.
 *
 * @param {string} shortUrl
 * @return {string}
 */
var decode = function(shortUrl) {
    return map.get(shortUrl.replace('tinyurl.com/', ''))
};

var getRandom = function() {
    let result = []
    
    for (let i = 0; i <= 6; i++) {
        const randomIndex = Math.floor(Math.random() * alphabet.length)
        result.push(alphabet[randomIndex])
    }
    
    return result.join('')
}

/**
 * Your functions will be called as such:
 * decode(encode(url));
 */
```

## 1525. Number of Good Ways to Split a String
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numSplits = function(s) {
    let count = 0
    
    const suffixSum = Array(s.length).fill(0)
    const suffixSeen = new Set()
    for (let i = s.length - 1; i >= 0; i--) {
        suffixSeen.add(s[i])
        suffixSum[i] = suffixSeen.size
    }
    
    
    const prefixSeen = new Set()
    for (let i = 0; i < s.length; i++) {
        prefixSeen.add(s[i])
        count += suffixSum[i + 1] === prefixSeen.size
    }
    
    return count
};
```

## 825. Friends Of Appropriate Ages
```javascript
/**
 * @param {number[]} ages
 * @return {number}
 */
var numFriendRequests = function(ages) {
    let count = 0
    
    const ageGroups = Array(121).fill(0)
    for (const age of ages) {
        ageGroups[age]++
    }
    
    for (let i = 1; i < ageGroups.length; i++) {
        ageGroups[i] += ageGroups[i - 1]
    }
    
    for (let i = 15; i < ageGroups.length; i++) {
        const currCount = ageGroups[i] - ageGroups[i - 1]
        const validCount = ageGroups[i] - ageGroups[Math.floor(i * 0.5 + 7)]
        count += currCount * validCount - currCount
    }
    
    return count
};
```

## 1428. Leftmost Column with at Least a One
```javascript
/**
 * // This is the BinaryMatrix's API interface.
 * // You should not implement it, or speculate about its implementation
 * function BinaryMatrix() {
 *     @param {integer} row, col
 *     @return {integer}
 *     this.get = function(row, col) {
 *         ...
 *     };
 *
 *     @return {[integer, integer]}
 *     this.dimensions = function() {
 *         ...
 *     };
 * };
 */

/**
 * @param {BinaryMatrix} binaryMatrix
 * @return {number}
 */
var leftMostColumnWithOne = function(binaryMatrix) {
    const [row, col] = binaryMatrix.dimensions()
    
    let currRow = 0
    let currCol = col - 1
    let minCol = -1
    
    while (currRow < row && currCol >= 0) {
        binaryMatrix.get(currRow, currCol) === 0 ? currRow++ : currCol--
    }
    
    return currCol === col - 1 ? -1 : currCol + 1
};
```

## 289. Game of Life
```javascript
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function(board) {
    const m = board.length
    const n = board[0].length
    const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0], [-1, -1], [-1, 1], [1, -1], [1, 1]]
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            let liveCellCount = 0
            for (const [dRow, dCol] of dirs) {
                const nextRow = row + dRow
                const nextCol = col + dCol
                
                if (nextRow < 0 || nextRow >= m || 
                    nextCol < 0 || nextCol >= n) continue
                
                liveCellCount += board[nextRow][nextCol] & 1
            }
            
            if (board[row][col] === 0 && liveCellCount === 3) {
                board[row][col] |= 2
            }
            
            if (board[row][col] === 1 && liveCellCount >= 2 && liveCellCount <= 3) {
                board[row][col] |= 2
            }
        }
    }
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            board[i][j] >>= 1
        }
    }
};
```

## 1446. Consecutive Characters
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maxPower = function(s) {
    let power = 1
    
    let start = 0
    for (let end = 1; end < s.length; end++) {
        if (s[start] !== s[end]) {
            start = end
        }
            
        power = Math.max(power, end - start + 1)
    }
    
    return power
};
```

## 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence
```javascript
/**
 * @param {string} sentence
 * @param {string} searchWord
 * @return {number}
 */
var isPrefixOfWord = function(sentence, searchWord) {
    let i = 0
    let j = 0
    let wordIndex = 1
    
    while (j < sentence.length) {
        if (sentence[j] === ' ') {
            wordIndex++
            i = 0
            j++
            continue
        }
        
        if (sentence[j] === searchWord[i]) {
            i++
            j++
            
            if (i >= searchWord.length) {
                return wordIndex
            }
            
            continue
        }
        
        while (j < sentence.length && sentence[j] !== ' ') {
            j++
        }
    }
    
    return -1
};
```

## 1518. Water Bottles
```javascript
/**
 * @param {number} numBottles
 * @param {number} numExchange
 * @return {number}
 */
var numWaterBottles = function(numBottles, numExchange) {
    let bottlesDrunk = 0
    let emptyBottles = 0
    
    while (numBottles > 0) {
        bottlesDrunk += numBottles
        emptyBottles += numBottles
        numBottles = Math.floor(emptyBottles / numExchange)
        emptyBottles %= numExchange
    }
    
    return bottlesDrunk
};
```

## 1523. Count Odd Numbers in an Interval Range
```javascript
/**
 * @param {number} low
 * @param {number} high
 * @return {number}
 */
var countOdds = function(low, high) {
    if (low % 2 === 0 && high % 2 === 0) {
        return Math.floor((high - low) / 2)
    }
    
    return Math.floor((high - low) / 2) + 1
};
```

## 1544. Make The String Great
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var makeGood = function(s) {
    const stack = []
    
    for (const char of s) {
        if (!stack.length) {
            stack.push(char)
            continue
        }
        
        const top = stack[stack.length - 1]
        if (top !== char && top.toLowerCase() === char.toLowerCase()) {
            stack.pop()
            continue
        }
        
        stack.push(char)
    }
    
    return stack.join('')
};
```

## 1534. Count Good Triplets
```javascript
/**
 * @param {number[]} arr
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */
var countGoodTriplets = function(arr, a, b, c) {
    let triplets = 0
    
    for (let i = 0; i < arr.length - 2; i++) {
        for (let j = i + 1; j < arr.length - 1; j++) {
            if (Math.abs(arr[i] - arr[j]) > a) continue
            for (let k = j + 1; k < arr.length; k++) {
                triplets += Math.abs(arr[j] - arr[k]) <= b &&
                            Math.abs(arr[i] - arr[k]) <= c
            }
        }
    }
    
    return triplets
};
```

## 55. Jump Game
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    let reachable = 0
    
    for (let i = 0; i < nums.length; i++) {
        if (i > reachable) return false
        reachable = Math.max(reachable, i + nums[i])
    }
    
    return true
};
```

## 1502. Can Make Arithmetic Progression From Sequence
```javascript
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var canMakeArithmeticProgression = function(arr) {
    const set = new Set()
    
    let a = arr[0]
    let lastNum = arr[0]
    
    for (const num of arr) {
        a = Math.min(a, num)
        lastNum = Math.max(lastNum, num)
        set.add(num)
    }
    
    const d = (lastNum - a) / (arr.length - 1)
    for (let i = 1; i <= arr.length; i++) {
        const term = a + (i - 1) * d
        if (!set.has(term)) return false
    }
    
    return true
};
```

## 1486. XOR Operation in an Array
```javascript
/**
 * @param {number} n
 * @param {number} start
 * @return {number}
 */
var xorOperation = function(n, start) {
    let result = 0
    
    for (let i = 0; i < n; i++) {
        result ^= (start + (2 * i))
    }
    
    return result
};
```

## 1503. Last Moment Before All Ants Fall Out of a Plank
```javascript
/**
 * @param {number} n
 * @param {number[]} left
 * @param {number[]} right
 * @return {number}
 */
var getLastMoment = function(n, left, right) {
    return Math.max(Math.max(...left), n - Math.min(...right))
};
```

## 658. Find K Closest Elements
```javascript
// https://www.youtube.com/watch?v=ZZmIVlgDIlQ
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 */
var findClosestElements = function(arr, k, x) {
    let left = 0
    let right = arr.length - k
    
    while (left < right) {
        // m is starting index of window of size k
        const mid = Math.trunc((right - left) / 2 ) + left
        
        const windowStartVal = arr[mid]
        const windowEndVal = arr[mid + k]
        const windowMidVal = Math.trunc((windowEndVal - windowStartVal) / 2) + windowStartVal
        if (x > windowMidVal) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return arr.slice(left, left + k)
};
```

## 1182. Shortest Distance to Target Color
```javascript
/**
 * @param {number[]} colors
 * @param {number[][]} queries
 * @return {number[]}
 */
var shortestDistanceColor = function(colors, queries) {
    const map = {}
    for (let i = 0; i < colors.length; i++) {
        if (!map[colors[i]]) map[colors[i]] = []
        map[colors[i]].push(i)
    }
    
    return queries.map(pair => closest(pair[0], map[pair[1]]))
};

const closest = (index, indices) => {
    if (!indices || !indices.length) return -1
    
    let left = 0
    let right = indices.length - 1
    
    while (right - left > 1) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (indices[mid] === index) {
            return 0
        } else if (indices[mid] < index) {
            left = mid
        } else {
            right = mid
        }   
    }
    
    const leftDist = Math.abs(indices[left] - index)
    const rightDist = Math.abs(indices[right] - index)
    return leftDist <= rightDist ? leftDist : rightDist
}
```

## 1475. Final Prices With a Special Discount in a Shop
```javascript
/**
 * @param {number[]} prices
 * @return {number[]}
 */
var finalPrices = function(prices) {
    const result = prices.slice()
    const stack = []
    
    for (let i = 0; i < prices.length; i++) {
        while (stack.length && prices[stack[stack.length - 1]] >= prices[i]) {
            result[stack.pop()] -= prices[i]
        }
        
        stack.push(i)
    }
    
    return result
};
```

## 1550. Three Consecutive Odds
```javascript
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var threeConsecutiveOdds = function(arr) {
    for (let i = 0; i < arr.length - 2; i++) {
        if (isOdd(arr[i]) && isOdd(arr[i + 1]) && isOdd(arr[i + 2])) {
            return true
        }
    }
    
    return false
};

const isOdd = num => num & 1
```

## 1484. Group Sold Products By The Date
```sql
# Write your MySQL query statement below
SELECT sell_date, 
       COUNT(DISTINCT product) AS num_sold,
       GROUP_CONCAT(DISTINCT product ORDER BY product) AS products
FROM Activities
GROUP BY sell_date
```

## 916. Word Subsets
```javascript
/**
 * @param {string[]} A
 * @param {string[]} B
 * @return {string[]}
 */
var wordSubsets = function(A, B) {
    const bMap = Array(26).fill(0)
    for (const b of B) {
        const currCounts = counts(b)
        for (let i = 0; i < 26; i++) {
            bMap[i] = Math.max(bMap[i], currCounts[i])
        }
    }
    
    return A.filter(a => {
        const aMap = counts(a)
        
        for (let i = 0; i < 26; i++) {
            if (aMap[i] < bMap[i]) return false
        }
        
        return true
    })
};

const counts = word => {
    const charMap = Array(26).fill(0)
    
    for (const char of word) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        charMap[index]++
    }
    
    return charMap
}
```

## 1556. Thousand Separator
```javascript
/**
 * @param {number} n
 * @return {string}
 */
var thousandSeparator = function(n) {
    if (n < 1000) return `${n}`
    
    const result = []
    
    let place = 0
    while (n) {
        if (place === 3) {
            result.push('.')
            place = 0
        }
        
        const digit = n % 10
        result.push(digit)
        n = Math.floor(n / 10)
        place++
    }
    
    result.reverse()
    return result.join('')
};
```

## 1543. Fix Product Name Format
```sql
# Write your MySQL query statement below
SELECT LOWER(TRIM(product_name)) AS product_name,
       DATE_FORMAT(sale_date,'%Y-%m') AS sale_date,
       COUNT(*) AS total
FROM Sales
GROUP BY 1, 2
ORDER BY 1, 2
```

## 705. Design HashSet
```javascript
/**
 * Initialize your data structure here.
 */
var MyHashSet = function() {
    this.elements = Array(10_000).fill(null)
    this.loadFactor = 0.75
    this.count = 0
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.add = function(key) {
    let index = this.hash(key)
    
    while (this.elements[index] !== null) {
        if (this.elements[index] === key) return
        index++
        index %= this.elements.length
    }
    
    this.elements[index] = key
    this.count++
        
    if (this.shouldRehash()) {
        this.rehash()
    }
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.remove = function(key) {
    let index = this.hash(key)
    
    while (this.elements[index] !== null) {
        if (this.elements[index] === key) {
            this.elements[index] = -1
            this.count--
            return
        }
        
        index++
        index %= this.elements.length
    }
};

/**
 * Returns true if this set contains the specified element 
 * @param {number} key
 * @return {boolean}
 */
MyHashSet.prototype.contains = function(key) {
    let index = this.hash(key)
    let firstLazyIndex = null
    
    while (this.elements[index] !== null) {
        if (this.elements[index] === key) {
            break
        }
        
        if (this.elements[index] === -1 && firstLazyIndex === null) {
            firstLazyIndex = index
        }
        
        index++
        index %= this.elements.length
    }
    
    if (this.elements[index] === null)
        return false
    
    if (firstLazyIndex !== null) {
        this.elements[firstLazyIndex] = this.elements[index]
        this.elements[index] = -1
    }
    
    return true
};

MyHashSet.prototype.hash = function(key) {
    return key % this.elements.length
}

MyHashSet.prototype.rehash = function() {
    const prevElements = this.elements
    this.elements = Array(this.elements.length * 2).fill(null)
    
    for (let i = 0; i < prevElements.length; i++) {
        if (prevElements[i] === null || prevElements[i] === -1) continue
        this.add(prevElements[i])
    }
}

MyHashSet.prototype.shouldRehash = function() {
    return this.count / this.elements.length >= this.loadFactor
}

/** 
 * Your MyHashSet object will be instantiated and called as such:
 * var obj = new MyHashSet()
 * obj.add(key)
 * obj.remove(key)
 * var param_3 = obj.contains(key)
 */
```

## 1060. Missing Element in Sorted Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var missingElement = function(nums, k) {
    const missingNums = i => nums[i] - nums[0] - i
    
    let left = 1
    let right = nums.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (missingNums(mid) < k) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return nums[left - 1] + k - missingNums(left - 1)
};
```

## 1010. Pairs of Songs With Total Durations Divisible by 60
```javascript
/**
 * @param {number[]} time
 * @return {number}
 */
var numPairsDivisibleBy60 = function(time) {
    const map = Array(60).fill(0)
    for (const t of time) {
        map[t % 60]++
    }
    
    let count = 0
    count += (map[0] * (map[0] - 1)) / 2
    count += (map[30] * (map[30] - 1)) / 2
    
    for (let i = 1; i < 30; i++) {
        count += map[i] * map[60 - i]
    }
    
    return count
};
```

## 1539. Kth Missing Positive Number
```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var findKthPositive = function(arr, k) {
    const missingNums = index => {
        return arr[index] - 1 - index
    }
    
    if (missingNums(0) >= k) {
        return k
    }
    
    let left = 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (missingNums(mid) < k) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return arr[left - 1] + k - missingNums(left - 1)
};
```

## 1565. Unique Orders and Customers Per Month
```sql
# Write your MySQL query statement below
SELECT DATE_FORMAT(order_date, "%Y-%m") AS month,
       COUNT(DISTINCT order_id) order_count,
       COUNT(DISTINCT customer_id) customer_count
FROM orders
WHERE invoice > 20
GROUP BY 1
```

## 1555. Bank Account Summary
```sql
# Write your MySQL query statement below
SELECT user_id, user_name, 
       credit + IFNULL(in_cash, 0) - IFNULL(out_cash, 0) AS credit,
       IF(credit + IFNULL(in_cash, 0) - IFNULL(out_cash, 0) >= 0, 'No', 'Yes') AS credit_limit_breached
FROM Users
LEFT JOIN (SELECT paid_by, SUM(amount) as out_cash
           FROM transactions
           GROUP BY paid_by) AS d1
ON user_id = paid_by
LEFT JOIN (SELECT paid_to, SUM(amount) as in_cash
           FROM transactions
           GROUP BY paid_to) AS d2
ON user_id = paid_to
```

## 1447. Simplified Fractions
```javascript
// Set
/**
 * @param {number} n
 * @return {string[]}
 */
var simplifiedFractions = function(n) {
    const result = []
    const seen = new Set()
    for (let numerator = 1; numerator < n; numerator++) {
        for (let denominator = numerator + 1; denominator <= n; denominator++) {
            const decimal = numerator / denominator
            if (seen.has(decimal)) continue
            seen.add(decimal)
            result.push(`${numerator}/${denominator}`)
        }
    }
    
    return result
};

// GCD
/**
 * @param {number} n
 * @return {string[]}
 */
var simplifiedFractions = function(n) {
    const result = []
    
    for (let numerator = 1; numerator < n; numerator++) {
        for (let denominator = numerator + 1; denominator <= n; denominator++) {
            if (gcd(numerator, denominator) === 1) {
                result.push(`${numerator}/${denominator}`)
            }
        }
    }
    
    return result
};

const gcd = (a, b) => {
    while (b) {
        const temp = a
        a = b
        b = temp % b
    }
    
    return a
}
```

## 1344. Angle Between Hands of a Clock
```javascript
/**
 * @param {number} hour
 * @param {number} minutes
 * @return {number}
 */
var angleClock = function(hour, minutes) {
    const h = 30 * (hour % 12) + 0.5 * minutes
    const m = 6 * minutes
    const angle = Math.abs(h - m)
    return Math.min(angle, 360 - angle)
};
```

## 255. Verify Preorder Sequence in Binary Search Tree
```javascript
/**
 * @param {number[]} preorder
 * @return {boolean}
 */
var verifyPreorder = function(preorder) {
    const stack = []
    let low = -Infinity
    
    for (const p of preorder) {
        if (p < low) {
            return false
        }
        
        while (stack.length && stack[stack.length - 1] < p) {
            low = stack.pop()
        }
        
        stack.push(p)
    }
    
    return true
};

// O(1) Space
/**
 * @param {number[]} preorder
 * @return {boolean}
 */
var verifyPreorder = function(preorder) {
    let low = -Infinity
    let i = -1
    
    for (const p of preorder) {
        if (p < low) {
            return false
        }
        
        while (i >= 0 && preorder[i] < p) {
            low = preorder[i--]
        }
        
        preorder[++i] = p
    }
    
    return true
};
```

## 556. Next Greater Element III
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var nextGreaterElement = function(n) {
    const nums = `${n}`.split('')
    
    let i = nums.length - 2
    while (i >= 0 && nums[i + 1] <= nums[i])
        i--
    
    if (i < 0) return -1
    
    let j = nums.length - 1
    while (j >= 0 && nums[j] <= nums[i])
        j--

    swap(nums, i, j)
    reverse(nums, i + 1)
    
    const num = nums.join('')
    if (num > 2 ** 31 - 1) return -1
    return num
};

const reverse = (arr, start) => {
    let i = start
    let j = arr.length - 1
    
    while (i < j) {
        swap(arr, i, j)
        i++
        j--
    }
}

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 1466. Reorder Routes to Make All Paths Lead to the City Zero
```javascript
// DFS
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minReorder = function(n, connections) {
    const graph = buildGraph(n, connections)
    const visited = new Set([0])
    return dfs(0, graph, visited)
};

const dfs = (vertex, graph, visited) => {
    let count = 0

    for (const [neighbor, dir] of graph[vertex]) {
        if (visited.has(neighbor)) continue
        visited.add(neighbor)

        count += dir
        count += dfs(neighbor, graph, visited)
    }
    
    return count
}

const buildGraph = (n, connections) => {
    const graph = Array(n).fill()
    
    for (const [vertex, neighbor] of connections) {
        if (!graph[vertex]) graph[vertex] = []
        if (!graph[neighbor]) graph[neighbor] = []
        graph[vertex].push([neighbor, 1])
        graph[neighbor].push([vertex, 0])
    }
    
    return graph
}

// BFS
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minReorder = function(n, connections) {
    const graph = {}
    for (const [u, v] of connections) {
        if (!graph[u]) graph[u] = []
        if (!graph[v]) graph[v] = []
        graph[u].push([v, true])
        graph[v].push([u, false])
    }
    
    const visited = new Set()
    visited.add(0)
    
    let count = 0
    const queue = [0]
    while (queue.length) {
        const node = queue.shift()
        
        for (const [neighbor, roadGoingAwayFromCapital] of graph[node]) {
            if (visited.has(neighbor)) continue
            visited.add(neighbor)

            count += roadGoingAwayFromCapital
            queue.push(neighbor)
        }
    }
    
    return count
};
```

## 84. Largest Rectangle in Histogram
```javascript
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    const stack = [-1]
    let max = 0
    for (let i = 0; i < heights.length; i++) {
        while (stack[stack.length - 1] !== -1 && 
               heights[stack[stack.length - 1]] >= heights[i]) {
            const height = heights[stack.pop()]
            const width = i - stack[stack.length - 1] - 1
            max = Math.max(max, height * width)
        }
        
        stack.push(i)
    }
    
    while (stack[stack.length - 1] !== -1) {
        const height = heights[stack.pop()]
        const width = heights.length - stack[stack.length - 1] - 1
        max = Math.max(max, height * width)
    }
    
    return max
};
```

## 5. Longest Palindromic Substring
```javascript
// Dynammic Programming Time: O(n^2) Space: O(n^2)
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    const dp = Array(s.length).fill().map(a => Array(s.length).fill(false))
    let maxStart = 0
    let maxEnd = 0
    
    for (let i = 0; i < s.length; i++) {
        dp[i][i] = true
    }
    
    for (let i = 0; i < s.length - 1; i++) {
        if (s[i] === s[i + 1]) {
            dp[i][i + 1] = true
            maxStart = i
            maxEnd = i + 1
        }
    }
    
    for (let currLen = 3; currLen <= s.length; currLen++) {
        for (let start = 0; start < s.length - currLen + 1; start++) {
            const end = start + currLen - 1
            if (s[start] === s[end] && dp[start + 1][end - 1]) {
                dp[start][end] = true
                
                if (end - start + 1 > maxEnd - maxStart + 1) {
                    maxStart = start
                    maxEnd = end
                }
                
            }
        }
    }
    
    return s.slice(maxStart, maxEnd + 1)  
};

// Expand From Center Time: O(n^2) Space: O(1)
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let start = 0
    let end = 0
    let maxLen = 0
    
    for (let i = 0; i < s.length; i++) {
        const [l1, r1] = palindrome(s, i, i)
        const len1 = r1 - l1 + 1
        if (maxLen < len1) {
            start = l1
            end = r1
            maxLen = len1
        }
        
        const [l2, r2] = palindrome(s, i, i + 1)
        const len2 = r2 - l2 + 1
        if (maxLen < len2) {
            start = l2
            end = r2
            maxLen = len2
        }
    }
    
    return s.slice(start, end + 1)
};

const palindrome = (s, left, right) => {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
        left--
        right++
    }
    
    return [left + 1, right - 1]
}
```

## 131. Palindrome Partitioning
```javascript
// Time: O(2^n * n)
// Space: O(n)
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    const _partition = (baseIndex, curr) => {
        if (baseIndex >= s.length) {
            result.push(curr.slice())
            return
        }
        
        for (let i = baseIndex; i < s.length; i++) {
            if (!isPalindrome(s, baseIndex, i)) continue
            const str = s.slice(baseIndex, i + 1)
            curr.push(str)
            _partition(i + 1, curr)
            curr.pop()
        }
    }
    
    const result = []
    _partition(0, [])
    return result
};

const isPalindrome = (s, left, right) => {
    while (left < right) {
        if (s[left] !== s[right]) return false
        
        left++
        right--
    }
    
    return true
}
```

## 140. Word Break II
```javascript
// Top Down + Memoization
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
    const _wordBreak = (baseIndex, curr) => {
        if (memo[baseIndex]) return memo[baseIndex]
        
        if (baseIndex === s.length) {
            return ['']
        }
        
        const list = []
        
        for (let i = baseIndex; i < s.length; i++) {
            const word = s.slice(baseIndex, i + 1)
            if (!dict.has(word)) continue
            const rest = _wordBreak(i + 1)
            for (const comb of rest) {
                list.push(word + (comb === '' ? '' : ' ') + comb)
            }
        }
        
        memo[baseIndex] = list
        return list
    }
    
    const memo = {}
    const dict = new Set(wordDict)
    return _wordBreak(0)
};

// Bottom Up DP - Doesn't Run, Takes Too Much Memory
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
    const words = new Set(wordDict)
    const dp = Array(s.length + 1).fill().map(a => [])
    dp[0] = ['']
    
    for (let i = 1; i <= s.length; i++) {
        for (let j = 0; j < i; j++) {
            const str = s.slice(j, i)
            
            if (!words.has(str)) continue
            for (const prefix of dp[j]) {
                dp[i].push(prefix + (prefix === '' ? '' : ' ') + str)
            }
        }
    }
    
    return dp[s.length]
};
```

## 981. Time Based Key-Value Store
```javascript
/**
 * Initialize your data structure here.
 */
var TimeMap = function() {
    this.map = {}
};

/** 
 * @param {string} key 
 * @param {string} value 
 * @param {number} timestamp
 * @return {void}
 */
TimeMap.prototype.set = function(key, value, timestamp) {
    if (this.map[key] === undefined) {
        this.map[key] = []
    }
    
    this.map[key].push([value, timestamp])
};

/** 
 * @param {string} key 
 * @param {number} timestamp
 * @return {string}
 */
TimeMap.prototype.get = function(key, timestamp) {
    const entries = this.map[key]
    const index = binarySearch(entries, timestamp)
    if (index === -1) return ''
    return entries[index][0]
};

/** 
 * Your TimeMap object will be instantiated and called as such:
 * var obj = new TimeMap()
 * obj.set(key,value,timestamp)
 * var param_2 = obj.get(key,timestamp)
 */

const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.trunc((right - left) / 2) + left
        
        if (arr[mid][1] <= target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left - 1
}
```

## 37. Sudoku Solver
```javascript
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
    const _solveSudoku = (row, col) => {
        if (row === n) return true
        
        const nextRow = col === n - 1 ? row + 1 : row
        const nextCol = col === n - 1 ? 0 : col + 1
        
        if (board[row][col] !== '.')
            return _solveSudoku(nextRow, nextCol)
        
        for (let num = 1; num <= 9; num++) {
            if (isValid(board, num, row, col, rows, cols, subboxes))
                continue
            
            addNum(board, num, row, col, rows, cols, subboxes)
            
            if (_solveSudoku(nextRow, nextCol))
                return true
            
            removeNum(board, num, row, col, rows, cols, subboxes)
        }
        
        return false
    }
    
    const n = board.length
    const rows = Array(n).fill(0)
    const cols = Array(n).fill(0)
    const subboxes = Array(n).fill(0)
    
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < n; col++) {
            if (board[row][col] === '.') continue
            addNum(board, board[row][col], row, col, rows, cols, subboxes)
        }
    }
    
    _solveSudoku(0, 0)
};

const addNum = (board, num, row, col, rows, cols, subboxes) => {
    const mask = 1 << num
    const subbox = Math.floor(row / 3) * 3 + Math.floor(col / 3)
    
    rows[row] |= mask
    cols[col] |= mask
    subboxes[subbox] |= mask
    
    board[row][col] = `${num}`
}

const removeNum = (board, num, row, col, rows, cols, subboxes) => {
    const mask = 1 << num
    const subbox = Math.floor(row / 3) * 3 + Math.floor(col / 3)
    
    rows[row] ^= mask
    cols[col] ^= mask
    subboxes[subbox] ^= mask
    
    board[row][col] = '.'
}

const isValid = (board, num, row, col, rows, cols, subboxes) => {
    const mask = 1 << num
    const subbox = Math.floor(row / 3) * 3 + Math.floor(col / 3)
    
    return (rows[row] & mask) || 
           (cols[col] & mask) || 
           (subboxes[subbox] & mask)
}
```

## 1576. Replace All ?'s to Avoid Consecutive Repeating Characters
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var modifyString = function(s) {
    const result = s.split('')
    
    for (let i = 0; i < result.length; i++) {
        if (result[i] !== '?') continue
        
        const leftNeighbor = result[i - 1]
        const rightNeighbor = result[i + 1]
        
        for (const char of 'abc') {
            if (leftNeighbor === char || rightNeighbor === char)
                continue
            
            result[i] = char
            break
        }
    }
    
    return result.join('')
};
```

## 1571. Warehouse Manager
```sql
# Write your MySQL query statement below
SELECT name AS warehouse_name, SUM(volume * units) AS volume
FROM Warehouse
LEFT JOIN (SELECT product_id, Width * Length * Height AS volume
           FROM Products) AS t
USING (product_id)
GROUP BY name
```

## 1572. Matrix Diagonal Sum
```javascript
/**
 * @param {number[][]} mat
 * @return {number}
 */
var diagonalSum = function(mat) {
    let sum = 0
    
    for (let i = 0; i < mat.length; i++) {
        sum += mat[i][i]
        
        if (i !== mat.length - 1 - i)
            sum += mat[i][mat.length - 1 - i]
    }
    
    return sum
};
```

## 212. Word Search II
```javascript
/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    const result = []
    const trie = new Trie(words)
    
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[0].length; col++) {
            const letter = board[row][col]
            if (!trie.root.children[letter]) continue
            dfs(result, board, row, col, trie.root.children[letter])
        }
    }
    
    return result
};

const dfs = (result, board, row, col, root) => {
    const _dfs = (row, col, root, word) => {
        if (root.isEnd) {
            result.push(word.join(''))
            root.isEnd = false
        }
        
        for (const [dRow, dCol] of dirs) {
            const nRow = dRow + row
            const nCol = dCol + col
            
            if (nRow < 0 || nRow >= board.length || 
                nCol < 0 || nCol >= board[0].length ||
                root.children[board[nRow][nCol]] === undefined || 
                board[nRow][nCol] === '1') {
                continue
            }
            
            const char = board[nRow][nCol]            
            word.push(char)
            board[nRow][nCol] = '1'
            
            _dfs(nRow, nCol, root.children[char], word)
            
            board[nRow][nCol] = char
            word.pop()
        }
    }
    
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const char = board[row][col]
    board[row][col] = '1'
    _dfs(row, col, root, [char])
    board[row][col] = char
}

class TrieNode {
    constructor(key = '') {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}

class Trie {
    constructor(words) {
        this.root = new TrieNode()
        
        for (const word of words) {
            this.insert(word)
        }
    }
    
    insert(word) {
        let curr = this.root
        for (const char of word) {
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            curr = curr.children[char]
        }
        
        curr.isEnd = true
    }
}
```

## 52. N-Queens II
```javascript
// Backtracking + Set
// the function for the main diagonal is y = mx + b, the function for the anti diagonal is y = -mx + b.
// m is 1 and -1 respectively so equations can be simplified to y = mx + b and y = -x + b.
// To uniquely identify a diagonal, because we know every diagonal has the same slope of 1 for diagonal and -1 for all anti diagonals, we need to know the y-intercept to identify. Therefore, to know which diagonal the queen is on, we simply need the value b = y-x and b = y+x
/**
 * @param {number} n
 * @return {number}
 */
var totalNQueens = function(n) {
    const _totalNQueens = row => {
        if (row === n) {
            count++
            return
        }
                
        for (let col = 0; col < n; col++) {
            if (cols[col] || diags1[row - col] || diags2[row + col])
                continue
            
            cols[col] = true
            diags1[row - col] = true
            diags2[row + col] = true
            
            _totalNQueens(row + 1)
            
            cols[col] = false
            diags1[row - col] = false
            diags2[row + col] = false
        }
    }
    
    const cols = Array(n).fill(false)
    const diags1 = Array(2 * n - 1).fill(false)
    const diags2 = Array(2 * n - 1).fill(false)
    
    let count = 0
    _totalNQueens(0, [])
    return count
};

// Backtracking + Bitmask
/**
 * @param {number} n
 * @return {number}
 */
var totalNQueens = function(n) {
    const _totalNQueens = (row, diag1, diag2, cols) => {
        if (row >= n) return 1
        
        let count = 0
        for (let col = 0; col < n; col++) {
            const d1 = row - col + n
            const d2 = row + col
            
            if (cols & 1 << col || 
                diag1 & 1 << d1 || 
                diag2 & 1 << d2) continue
            
            count += _totalNQueens(row + 1, 
                                   diag1 | 1 << d1, 
                                   diag2 | 1 << d2,
                                   cols | 1 << col)
        }
        
        return count
    }
    
    return _totalNQueens(0, 0, 0, 0)
};
```

## 51. N-Queens
```javascript
// Backtracking + Array
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
    const _solveNQueens = (row, curr) => {
        if (row === n) {
            result.push(curr.map(r => r.join('')))
            return
        }
                
        for (let col = 0; col < n; col++) {
            if (cols[col] || diags1[row - col] || diags2[row + col])
                continue
            
            cols[col] = true
            diags1[row - col] = true
            diags2[row + col] = true
            curr[row][col] = 'Q'
            
            _solveNQueens(row + 1, curr)
            
            cols[col] = false
            diags1[row - col] = false
            diags2[row + col] = false
            curr[row][col] = '.'
        }
    }
    
    const cols = Array(n).fill(false)
    const diags1 = Array(2 * n - 1).fill(false)
    const diags2 = Array(2 * n - 1).fill(false)
    
    const result = []
    const board = Array(n).fill().map(a => Array(n).fill('.'))
    _solveNQueens(0, board)
    return result
};

// Backtracking + Bitmask
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
    const _solveNQueens = (row, colUsed, diag1Used, diag2Used) => {
        if (row >= n) {
            result.push(board.map(r => r.join('')))
            return
        }
        
        for (let col = 0; col < n; col++) {
            const colMask = 1 << col
            const diag1Mask = 1 << (row + col)
            const diag2Mask = 1 << (row - col + n) 
            
            if (colUsed & colMask || diag1Used & diag1Mask || diag2Used & diag2Mask) 
                continue
            
            board[row][col] = 'Q'            
            _solveNQueens(row + 1, colUsed | colMask, diag1Used | diag1Mask, diag2Used | diag2Mask)
            board[row][col] = '.'
        }
    }
    
    const result = []
    const board = Array(n).fill().map(a => Array(n).fill('.'))
    
    _solveNQueens(0, 0, 0, 0)
    return result
};
```

## 1395. Count Number of Teams
```javascript
// O(n^3)
/**
 * @param {number[]} rating
 * @return {number}
 */
var numTeams = function(rating) {
    let count = 0
    
    for (let i = 0; i < rating.length; i++) {
        for (let j = i + 1; j < rating.length; j++) {
            for (let k = j + 1; k < rating.length; k++) {
                if (rating[i] < rating[j] && rating[j] < rating[k] ||
                    rating[i] > rating[j] && rating[j] > rating[k]) {
                    count++
                }
            }
        }
    }
    
    return count
};

// O(n^2)
/**
 * @param {number[]} rating
 * @return {number}
 */
var numTeams = function(rating) {
    let count = 0
    
    for (let j = 1; j < rating.length - 1; j++) {
        let leftSmaller = 0
        let leftLarger = 0
        let rightSmaller = 0
        let rightLarger = 0
        
        for (let i = 0; i < j; i++) {
            leftSmaller += rating[i] < rating[j]
            leftLarger += rating[i] > rating[j]
        }
        
        for (let k = j + 1; k < rating.length; k++) {
            rightSmaller += rating[k] < rating[j]
            rightLarger += rating[k] > rating[j]
        }
        
        count += leftSmaller * rightLarger + leftLarger * rightSmaller
    }
    
    return count
};
```

## 1289. Minimum Falling Path Sum II
```javascript
/**
 * @param {number[][]} arr
 * @return {number}
 */
var minFallingPathSum = function(arr) {
    let prevRow = arr[0]
    
    for (let i = 1; i < arr.length; i++) {
        const currRow = arr[i].slice()
        
        let min1Col = -1
        let min2Col = -1
        
        for (let j = 0; j < arr.length; j++) {
            if (min1Col === -1 || prevRow[min1Col] > prevRow[j]) {
                min2Col = min1Col
                min1Col = j
            } else if (min2Col === -1 || prevRow[min2Col] > prevRow[j]) {
                min2Col = j
            }
        }
        
        for (let j = 0; j < arr.length; j++) {
            if (min1Col === j) {
                currRow[j] += prevRow[min2Col]
            } else {
                currRow[j] += prevRow[min1Col]
            }
        }
        
        prevRow = currRow
    }
    
    return Math.min(...prevRow)
};
```

## 1582. Special Positions in a Binary Matrix
```javascript
/**
 * @param {number[][]} mat
 * @return {number}
 */
var numSpecial = function(mat) {
    const matRow = Array(mat.length).fill(0)
    const matCol = Array(mat[0].length).fill(0)
    
    for (let row = 0; row < mat.length; row++) {
        for (let col = 0; col < mat[0].length; col++) {
            if (!mat[row][col]) continue
            matRow[row]++
            matCol[col]++
        }
    }
    
    let count = 0
    for (let row = 0; row < mat.length; row++) {
        for (let col = 0; col < mat[0].length; col++) {
            count += mat[row][col] && matRow[row] === 1 && matCol[col] === 1
        }
    }
    
    return count
};
```

## 1581. Customer Who Visited but Did Not Make Any Transactions
```sql
-- Sub-query
SELECT customer_id, COUNT(*) AS count_no_trans
FROM Visits
WHERE visit_id NOT IN (SELECT visit_id FROM Transactions)
GROUP BY customer_id

-- Left JOIN
SELECT customer_id, COUNT(*) AS count_no_trans
FROM Visits AS v
LEFT JOIN Transactions AS t
USING(visit_id)
WHERE transaction_id IS NULL
GROUP BY customer_id
```

## 10. Regular Expression Matching
```javascript
// Top Down DP
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    const _isMatch = (i, j) => {
        if (i < -1 || j < -1) 
            return false
        
        if (i === -1 && j === -1)
            return true
        
        if (j === -1)
            return false
        
        if (memo[i + 1][j + 1])
            return memo[i + 1][j + 1]
        
        if (s[i] === p[j] || p[j] === '.') {
            memo[i + 1][j + 1] = _isMatch(i - 1, j - 1)
        } else if (p[j] === '*') {
            memo[i + 1][j + 1] = _isMatch(i, j - 2)
            if (p[j - 1] === s[i] || p[j - 1] === '.') {
                memo[i + 1][j + 1] = memo[i + 1][j + 1] || _isMatch(i - 1, j)
            }
        }
        
        return memo[i + 1][j + 1]
    }
    
    const memo = Array(s.length + 1).fill()
                    .map(a => Array(p.length + 1).fill(false))
    return _isMatch(s.length - 1, p.length - 1)
};

// Bottom Up DP

```

## 1385. Find the Distance Value Between Two Arrays
```javascript
/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @param {number} d
 * @return {number}
 */
var findTheDistanceValue = function(arr1, arr2, d) {
    let count = 0
    arr2.sort((a, b) => a - b)
    
    for (const num of arr1) {
        const closest = binarySearch(arr2, num)
        count += Math.abs(num - closest) > d
    }
    
    return count
};

const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length - 1
    
    while (right - left > 1) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid] < target) {
            left = mid
        } else {
            right = mid
        }
    }
    
    const leftDiff = Math.abs(arr[left] - target)
    const rightDiff = Math.abs(arr[right] - target)
    return leftDiff < rightDiff ? arr[left] : arr[right]
}

// Linear
/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @param {number} d
 * @return {number}
 */
var findTheDistanceValue = function(arr1, arr2, d) {
    const sortedArr1 = bucketSort(arr1)
    const sortedArr2 = bucketSort(arr2)
    
    let count = 0
    
    let p = 0
    let q = 0
    while (p < sortedArr1.length && q < sortedArr2.length) {
        const diff = Math.abs(sortedArr1[p] - sortedArr2[q])
        
        if (diff > d) {
            if (sortedArr1[p] > sortedArr2[q]) {
                q++
            } else {
                p++
                count++
            }
        } else {
            p++
        }
    }
    
    count += sortedArr1.length - p
    return count
};

const bucketSort = arr => {
    const buckets = Array(2001).fill(0)
    for (const num of arr) {
        buckets[num + 1000]++
    }
    
    const result = []
    for (let i = 0; i < buckets.length; i++) {
        while (buckets[i]--) {
            result.push(i - 1000)
        }
    }
    
    return result
}
```

## 72. Edit Distance
```javascript
// Top Down DP
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    const _minDistance = (i, j) => {
        if (i >= word1.length) {
            // insert remaining chars
            return word2.length - j
        }
        
        if (j >= word2.length) {
            // delete remaining chars
            return word1.length - i
        }
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }
        
        if (word1[i] !== word2[j]) {
            const insertChar = _minDistance(i, j + 1)
            const deleteChar = _minDistance(i + 1, j)
            const replaceChar = _minDistance(i + 1, j + 1)
            memo[i][j] = 1 + Math.min(insertChar, deleteChar, replaceChar)
        } else {
            memo[i][j] = _minDistance(i + 1, j + 1)
        }
        
        return memo[i][j]
    }
    
    const memo = new Array(word1.length).fill().map(a => new Array(word2.length))
    return _minDistance(0, 0)
};

// Bottom Up DP
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    const dp = Array(word1.length + 1).fill().map(a => Array(word2.length + 1).fill(0))
    dp[0][0] = 0
    
    for (let i = 1; i <= word1.length; i++) {
        dp[i][0] = i
    }
    
    for (let i = 1; i <= word2.length; i++) {
        dp[0][i] = i
    }
    
    for (let i = 1; i <= word1.length; i++) {
        for (let j = 1; j <= word2.length; j++) {
            dp[i][j] = Math.min(1 + dp[i][j - 1],
                                1 + dp[i - 1][j],
                                (word1[i - 1] === word2[j - 1] ? 0 : 1) + dp[i - 1][j - 1])
        }
    }
    
    return dp[word1.length][word2.length]
};
```

## 839. Similar String Groups
```javascript
/**
 * @param {string[]} A
 * @return {number}
 */
var numSimilarGroups = function(A) {
    const unionFind = new UnionFind(A.length)
    
    for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
            if (!isSimilar(A[i], A[j])) continue
            unionFind.union(i, j)
            
            if (unionFind.numOfComponents === 1)
                return 1
        }
    }
    
    return unionFind.numOfComponents
};

const isSimilar = (word1, word2) => {
    let diff = 0
    for (let i = 0; i < word1.length && diff <= 2; i++) {
        diff += word1[i] !== word2[i]
    }
    return diff <= 2
}

class UnionFind {
    constructor(n) {
        this.sizes = Array(n).fill(1)
        this.parent = Array(n).fill()
        for (let i = 0; i < n; i++) {
            this.parent[i] = i
        }
        
        this.numOfComponents = n
    }
    
    find(a) {
        let root = this.parent[a]
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (a !== root) {
            const next = this.parent[a]
            this.parent[a] = root
            a = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB)
            return
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parent[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parent[parentB] = parentA
        }
        
        this.numOfComponents--
    }
}
```

## 778. Swim in Rising Water
```javascript
// Union Find Gird Percolation - Time: O(n^2) Space: O(n^2)
/**
 * @param {number[][]} grid
 * @return {number}
 */
var swimInWater = function(grid) {
    const n = grid.length
    const map = Array(n).fill()
    const unionFind = new UnionFind(n * n)
    const dirs = [[1, 0], [-1, 0], [0, -1], [0, 1]]
    
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            map[grid[row][col]] = [row, col]
        }
    }
    
    for (let t = 0; t < n * n; t++) {
        const [row, col] = map[t]
        for (const [deltaRow, deltaCol] of dirs) {
            const neighborRow = deltaRow + row
            const neighborCol = deltaCol + col
            
            if (!isValid(grid, neighborRow, neighborCol, n, t)) continue
            
            const curr = row * n + col
            const neighbor = neighborRow * n + neighborCol
            unionFind.union(curr, neighbor)
        }
        
        const start = 0
        const end = n * n - 1
        if (unionFind.connected(start, end))
            return t
    }
    
    return n - 1
};

const isValid = (grid, row, col, n, time) => {
    return row >= 0 && row < n && col >= 0 && col < n && grid[row][col] <= time
}

class UnionFind {
    constructor(n) {
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        
        for (let i = 0; i < n; i++) {
            this.parents[i] = i
        }
    }
    
    connected(a, b) {
        return this.find(a) === this.find(b) 
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB)
            return
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
    }
    
    find(a) {
        let root = this.parents[a]
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (root !== a) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
}
```

## 924. Minimize Malware Spread
```javascript
/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    const n = graph.length
    const unionFind = new UnionFind(n)
    const infected = Array(n).fill(0)
    
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < n; col++) {
            if (graph[row][col] !== 1) continue
            unionFind.union(row, col)
        }
    }
    
    for (const node of initial) {
        infected[unionFind.find(node)]++
    }
    
    let maxSize = 0
    let i = Math.min(...initial)
    
    for (const node of initial) {
        if (infected[unionFind.find(node)] !== 1) continue
        const size = unionFind.size(node)
        if (size > maxSize) {
            maxSize = size
            i = node
        } else if (size === maxSize && i > node) {
            i = node
        }
    }
    
    return i
};

class UnionFind {
    constructor(n) {
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        for (let i = 0; i < n; i++) {
            this.parents[i] = i
        }
        
        this.numOfComponents = n
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
    
    find(a) {
        let root = this.parents[a]
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
    
    size(a) {
        return this.sizes[this.find(a)]
    }
}
```

## 1589. Maximum Sum Obtained of Any Permutation
```javascript
/**
 * @param {number[]} nums
 * @param {number[][]} requests
 * @return {number}
 */
var maxSumRangeQuery = function(nums, requests) {
    const MOD = 10 ** 9 + 7
    const counts = Array(nums.length).fill(0)
    
    for (const [start, end] of requests) {
        counts[start]++
        if (end + 1 < counts.length) counts[end + 1]--
    }
    
    for (let i = 1; i < nums.length; i++) {
        counts[i] += counts[i - 1]
    }
    
    nums.sort((a, b) => b - a)
    counts.sort((a, b) => b - a)
    
    let sum = 0
    for (let i = 0; i < nums.length; i++) {
        sum += nums[i] * counts[i]
        sum %= MOD
    }
    
    return sum
};
```

## 1109. Corporate Flight Bookings
```javascript
/**
 * @param {number[][]} bookings
 * @param {number} n
 * @return {number[]}
 */
var corpFlightBookings = function(bookings, n) {
    const seats = Array(n).fill(0)
    
    for (let [start, end, count] of bookings) {
        start = start - 1
        end = end - 1
        
        seats[start] += count
        if (end + 1 < n) seats[end + 1] -= count
    }
    
    for (let i = 1; i < seats.length; i++) {
        seats[i] += seats[i - 1]
    }
    
    return seats
};
```

## 1587. Bank Account Summary II
```sql
# Write your MySQL query statement below
SELECT name, SUM(amount) as balance
FROM Users
JOIN Transactions
USING(account)
GROUP BY account
HAVING SUM(amount) > 10000
```

## 1594. Maximum Non Negative Product in a Matrix
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxProductPath = function(grid) {
    const MOD = 10 ** 9 + 7
    const m = grid.length
    const n = grid[0].length
    
    grid[0][0] = [grid[0][0], grid[0][0]]
    
    for (let row = 1; row < m; row++) {
        const num = grid[row][0]
        const max = Math.max(num * grid[row - 1][0][0], num * grid[row - 1][0][1])
        const min = Math.min(num * grid[row - 1][0][0], num * grid[row - 1][0][1])
        grid[row][0] = [max, min]
    }
    
    for (let col = 1; col < n; col++) {
        const num = grid[0][col]
        const max = Math.max(num * grid[0][col - 1][0], num * grid[0][col - 1][1])
        const min = Math.min(num * grid[0][col - 1][0], num * grid[0][col - 1][1])
        grid[0][col] = [max, min]
    }
    
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            const num = grid[row][col]
            const max = Math.max(num * grid[row - 1][col][0], 
                                 num * grid[row - 1][col][1],
                                 num * grid[row][col - 1][0],
                                 num * grid[row][col - 1][1])
            
            const min = Math.min(num * grid[row - 1][col][0], 
                                 num * grid[row - 1][col][1],
                                 num * grid[row][col - 1][0],
                                 num * grid[row][col - 1][1])
            grid[row][col] = [max, min]
        }
    }
    
    const max = grid[m - 1][n - 1][0] % MOD
    return max >= 0 ? max : -1
};
```

## 1593. Split a String Into the Max Number of Unique Substrings
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maxUniqueSplit = function(s) {
    const _maxUniqueSplit = (start, count) => {
        if (start >= s.length) {
            max = Math.max(max, count)
            return
        }
        
        for (let i = start; i < s.length; i++) {
            const str = s.slice(start, i + 1)
            if (used.has(str)) continue
            used.add(str)
            _maxUniqueSplit(i + 1, count + 1)
            used.delete(str)
        }
    }
    
    const used = new Set()
    let max = 0
    _maxUniqueSplit(0, 0)
    return max
};
```

## 68. Text Justification
```javascript
/**
 * @param {string[]} words
 * @param {number} maxWidth
 * @return {string[]}
 */
var fullJustify = function(words, maxWidth) {
    const result = []
    
    let i = 0
    while (i < words.length) {
        let j = i + 1
        let lineLength = words[i].length
        
        while (j < words.length && lineLength + words[j].length + j - i - 1 < maxWidth) {
            lineLength += words[j].length
            j++
        }
        
        const diff = maxWidth - lineLength
        const wordCount = j - i
        
        if (wordCount === 1 || j >= words.length) {
            result.push(leftJustify(words, diff, i, j))
        } else {
            result.push(middleJustify(words, diff, i, j))
        }
        
        i = j
    }
    
    return result
};

const leftJustify = (words, diff, i, j) => {
    const line = [words[i]]
    const spacesOnRight = diff - (j - i - 1)
    
    for (let k = i + 1; k < j; k++) {
        line.push(' ')
        line.push(words[k])
    }
    
    line.push(' '.repeat(spacesOnRight))
    return line.join('')
}

const middleJustify = (words, diff, i, j) => {
    const line = [words[i]]
    const spacesNeeded = j - i - 1
    const spaceBetween = Math.floor(diff / spacesNeeded)
    let spaceExtra = diff % spacesNeeded
    
    for (let k = i + 1; k < j; k++) {
        if (spaceExtra > 0) {
            line.push(' ')
            spaceExtra--
        }
        
        line.push(' '.repeat(spaceBetween))
        line.push(words[k])
    }
    
    return line.join('')
}
```

## 1592. Rearrange Spaces Between Words
```javascript
/**
 * @param {string} text
 * @return {string}
 */
var reorderSpaces = function(text) {
    const words = []
    let currWord = []
    let spaces = 0
    for (let i = 0; i < text.length; i++) {
        if (text[i] === ' ') {
            spaces++
            
            if (currWord.length) {
                words.push(currWord.join(''))
                currWord = []    
            }
            
            continue
        }
        
        currWord.push(text[i])
    }
    
    if (currWord.length) {
        words.push(currWord.join(''))
    }
    
    const result = [words[0]]
    const spacesBetween = words.length <= 1 ? 0 : Math.floor(spaces / (words.length - 1))
    const spacesEnd = words.length <= 1 ? spaces : spaces % (words.length - 1)
    
    for (let i = 1; i < words.length; i++) {
        result.push(' '.repeat(spacesBetween))
        result.push(words[i])
    }
    
    result.push(' '.repeat(spacesEnd))
    return result.join('')
};
```

## 421. Maximum XOR of Two Numbers in an Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaximumXOR = function(nums) {
    const trie = new Trie(nums)
    let max = 0
    
    for (const num of nums) {
        max = Math.max(max, trie.maxNum(num))
    }
    
    return max
};

class Trie {
    constructor(nums) {
        this.root = new TrieNode(NaN)
        
        for (const num of nums) {
            this.insert(num)
        }
    }
    
    insert(num) {
        let curr = this.root
        
        for (let i = 30; i >= 0; i--) {
            const bit = num >> i & 1
            
            if (!curr.children[bit]) {
                curr.children[bit] = new TrieNode(bit)
            }

            curr = curr.children[bit]
        }
    }
    
    maxNum(num) {
        let max = 0
        let curr = this.root
        
        for (let i = 30; i >= 0; i--) {
            const bit = num >> i & 1
            const oppositeBit = bit ^ 1
            
            if (curr.children[oppositeBit]) {
                max |= (oppositeBit << i)
                curr = curr.children[oppositeBit]
            } else {
                max |= (bit << i)
                curr = curr.children[bit]
            }
        }
        
        return max ^ num
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
    }
}
```

## 642. Design Search Autocomplete System
```javascript
/**
 * @param {string[]} sentences
 * @param {number[]} times
 */
var AutocompleteSystem = function(sentences, times) {
    this.currSearch = []
    this.trie = new Trie()
    for (let i = 0; i < sentences.length; i++) {
        this.trie.insert(sentences[i], times[i])
    }
};

/** 
 * @param {character} c
 * @return {string[]}
 */
AutocompleteSystem.prototype.input = function(c) {
    if (c === '#') {
        this.trie.insert(this.currSearch.join(''), 1)
        this.currSearch = []
        return []
    }
    
    this.currSearch.push(c)
    return this.trie.search(this.currSearch.join(''))
};

/** 
 * Your AutocompleteSystem object will be instantiated and called as such:
 * var obj = new AutocompleteSystem(sentences, times)
 * var param_1 = obj.input(c)
 */

class Trie {
    constructor() {
        this.root = new TrieNode('')
    }
    
    insert(sentence, times) {
        let curr = this.root
        
        for (const char of sentence) {
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
        }
        
        curr.sentence = sentence
        curr.times += times
        
        let node = this.root
        for (const char of sentence) {
            node = node.children[char]
            node.insertHot(curr)
        }
    }
    
    search(searchTerm) {
        let curr = this.root
        for (const char of searchTerm) {
            if (!curr.children[char]) {
                return []
            }
            
            curr = curr.children[char]
        }
        
        return curr.hot.map(node => node.sentence)
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.times = 0
        this.sentence = ''
        this.children = {}
        this.hot = []
    }
    
    insertHot(node) {
        if (!this.hot.includes(node)) {
            this.hot.push(node)
        }
        
        this.hot.sort((a, b) => {
            if (a.times === b.times) {
                return a.sentence.localeCompare(b.sentence)
            }
            
            return b.times - a.times
        })
        
        if (this.hot.length > 3) {
            this.hot.pop()
        }
    }
}
```

## 1361. Validate Binary Tree Nodes
```javascript
/**
 * @param {number} n
 * @param {number[]} leftChild
 * @param {number[]} rightChild
 * @return {boolean}
 */
var validateBinaryTreeNodes = function(n, leftChild, rightChild) {
    const indegrees = {}
    for (let i = 0; i < n; i++) {
        indegrees[i] = 0
    }
    
    for (let i = 0; i < n; i++) {
        if (leftChild[i] !== -1 && ++indegrees[leftChild[i]] > 1) {
            return false
        }
        
        if (rightChild[i] !== -1 && ++indegrees[rightChild[i]] > 1) {
            return false
        }   
    }
    
    const queue = []
    for (let i = 0; i < n; i++) {
        if (indegrees[i] === 0) {
            queue.push(i)
            
            if (queue.length > 1) return false
        }
    }
    
    const result = []
    while (queue.length) {
        const node = queue.shift()
        result.push(node)
        
        if (leftChild[node] !== -1 && --indegrees[leftChild[node]] === 0) {
            queue.push(leftChild[node])
        }
        
        if (rightChild[node] !== -1 && --indegrees[rightChild[node]] === 0) {
            queue.push(rightChild[node])
        }
    }
    
    return result.length === n
};
```

## 1032. Stream of Characters
```javascript
/**
 * @param {string[]} words
 */
var StreamChecker = function(words) {
    this.queryString = []
    this.maxWordLength = 0
    this.trie = new Trie()
    for (const word of words) {
        this.trie.insert(word)
        this.maxWordLength = Math.max(this.maxWordLength, word.length)
    }
};

/** 
 * @param {character} letter
 * @return {boolean}
 */
StreamChecker.prototype.query = function(letter) {
    this.queryString.push(letter)
    
    if (this.queryString.length > this.maxWordLength) {
        this.queryString.shift()
    }
    
    return this.trie.search(this.queryString)
};

/** 
 * Your StreamChecker object will be instantiated and called as such:
 * var obj = new StreamChecker(words)
 * var param_1 = obj.query(letter)
 */

class Trie {
    constructor() {
        this.root = new TrieNode('')
    }
    
    insert(word) {
        let curr = this.root
        for (let i = word.length; i >= 0; i--) {
            const char = word[i]
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
        }
        
        curr.isEnd = true
    }
    
    search(word) {
        let curr = this.root
        for (let i = word.length; i >= 0; i--) {
            const char = word[i]
            if (!curr.children[char]) {
                return false
            }
            curr = curr.children[char]
            if (curr.isEnd) {
                return true
            }
        }
        
        return false
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 336. Palindrome Pairs
```javascript
/**
 * @param {string[]} words
 * @return {number[][]}
 */
var palindromePairs = function(words) {
    const trie = new Trie()
    for (let i = 0; i < words.length; i++) {
        const reversedWord = words[i].split('').reverse().join('')
        trie.insert(reversedWord, i)
    }
    
    const pairs = []
    for (let i = 0; i < words.length; i++) {
        trie.search(pairs, words[i], i)
    }
    return pairs
};

class Trie {
    constructor() {
        this.root = new TrieNode()
    }
    
    insert(word, index) {
        let curr = this.root
        for (let i = 0; i < word.length; i++) {
            const char = word[i]
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            
            if (isPalindrome(word, i)) {
                curr.palindromes.push(index)
            }
            
            curr = curr.children[char]
        }
        
        curr.index = index
    }
    
    search(pairs, word, index) {
        let curr = this.root
        for (let i = 0; i < word.length; i++) {
            const char = word[i]
            if (curr.index !== -1 && isPalindrome(word, i)) {
                pairs.push([index, curr.index])
            }
            
            if (!curr.children[char]) return
            curr = curr.children[char]
        }
        
        if (curr.index !== -1 && curr.index !== index) {
            pairs.push([index, curr.index])
        }
        
        for (const palindrome of curr.palindromes) {
            pairs.push([index, palindrome])
        }
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.index = -1
        this.palindromes = []
    }
}

const isPalindrome = (arr, i) => {
    let j = arr.length - 1
    
    while (i < j) {
        if (arr[i] !== arr[j]) {
            return false
        }
        
        i++
        j--
    }
    
    return true
}
```

## 1203. Sort Items by Groups Respecting Dependencies
```javascript
/**
 * @param {number} n
 * @param {number} m
 * @param {number[]} group
 * @param {number[][]} beforeItems
 * @return {number[]}
 */
var sortItems = function(numOfItems, numOfGroups, itemToGroupMap, beforeItems) {
    const groupToItemMap = {}
    let groupID = numOfGroups
    for (let i = 0; i < numOfItems; i++) {
        if (itemToGroupMap[i] === -1) {
            itemToGroupMap[i] = groupID
            groupID++
        }
        
        const itemGroup = itemToGroupMap[i]
        if (!groupToItemMap[itemGroup]) 
            groupToItemMap[itemGroup] = []
        
        groupToItemMap[itemGroup].push(i)
    }
    
    const itemGraph = {}
    const itemIndegree = {}
    for (const [item, befores] of beforeItems.entries()) {
        const itemGroup = itemToGroupMap[item]
        for (const before of befores) {
            const beforeGroup = itemToGroupMap[before]
            if (beforeGroup !== itemGroup) continue
            if (!itemGraph[before]) {
                itemGraph[before] = []
            }
            
            if (!itemIndegree[item]) {
                itemIndegree[item] = 0
            }
            
            itemGraph[before].push(item)
            itemIndegree[item]++
        }
    }
    
    for (const [group, items] of Object.entries(groupToItemMap)) {
        const sortedItems = topSort(items, itemGraph, itemIndegree)
        
        if (sortedItems.length !== items.length)
            return []
        
        groupToItemMap[group] = sortedItems
    }
    
    const groupGraph = {}
    const groupIndegree = {}
    for (const [item, befores] of beforeItems.entries()) {
        const itemGroup = itemToGroupMap[item]
        for (const before of befores) {
            const beforeGroup = itemToGroupMap[before]
            if (beforeGroup === itemGroup) continue
            if (!groupGraph[beforeGroup]) {
                groupGraph[beforeGroup] = []
            }
            
            if (!groupIndegree[itemGroup]) {
                groupIndegree[itemGroup] = 0
            }
            
            groupGraph[beforeGroup].push(itemGroup)
            groupIndegree[itemGroup]++
        }
    }
    
    const uniqueGroups = new Set(itemToGroupMap)
    const groups = Array.from(uniqueGroups)
    const sortedGroups = topSort(groups, groupGraph, groupIndegree)
    if (sortedGroups.length !== groups.length) {
        return []
    }
    
    let result = []
    for (const group of sortedGroups) {
        for (const node of groupToItemMap[group]) {
            result.push(node)
        }
    }
    
    return result
};

const topSort = (nodes, graph, indegrees) => {
    const result = []
    const queue = []
    
    for (const node of nodes) {
        if (!indegrees[node]) {
            queue.push(node)
        }
    }
    
    while (queue.length) {
        const node = queue.shift()
        result.push(node)
        
        if (graph[node]) {
            for (const neighbor of graph[node]) {
                indegrees[neighbor]--
                
                if (indegrees[neighbor] === 0) {
                    queue.push(neighbor)
                }
            }
        }
    }
    
    return result
}
```

## 745. Prefix and Suffix Search
```javascript
/**
 * @param {string[]} words
 */
var WordFilter = function(words) {
    const wrappedWords = []
    
    for (const [weight, word] of words.entries()) {
        for (let i = word.length - 1; i >= 0; i--) {
            const wrappedWord = word.slice(i) + '#' + word
            wrappedWords.push([wrappedWord, weight])
        }
    }
    
    this.prefixTrie = new Trie(wrappedWords)
};

/** 
 * @param {string} prefix 
 * @param {string} suffix
 * @return {number}
 */
WordFilter.prototype.f = function(prefix, suffix) {
    return this.prefixTrie.search(suffix + '#' + prefix)
};

/** 
 * Your WordFilter object will be instantiated and called as such:
 * var obj = new WordFilter(words)
 * var param_1 = obj.f(prefix,suffix)
 */

class Trie {
    constructor(words) {
        this.root = new TrieNode('')

        for (const [word, weight] of words) {
            this.insert(word, weight)
        }
    }
    
    insert(word, weight) {
        let curr = this.root
        for (const char of word) {
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
            curr.weight = weight
        }
    }
    
    search(word) {
        let curr = this.root
        
        for (const char of word) {
            if (!curr.children[char]) {
                return -1
            }
            
            curr = curr.children[char]
        }
        
        return curr.weight
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.weight = -1
    }
}
```

## 291. Word Pattern II
```javascript
/**
 * @param {string} pattern
 * @param {string} s
 * @return {boolean}
 */
var wordPatternMatch = function(pattern, s) {
    const _wordPatternMatch = (pIndex, sIndex) => {
        if (sIndex === s.length && pIndex === pattern.length) {
            return true
        }
        
        if (sIndex === s.length || pIndex === pattern.length) {
            return false
        }
        
        const pStr = map[pattern[pIndex]]
        if (pStr) {
            const str = s.slice(sIndex, sIndex + pStr.length)
            return str === pStr && _wordPatternMatch(pIndex + 1, sIndex + pStr.length)
        }
        
        for (let i = sIndex; i < s.length; i++) {
            const str = s.slice(sIndex, i + 1)
            if (map[str] !== undefined) continue
            
            map[pattern[pIndex]] = str
            map[str] = pattern[pIndex]
            
            if (_wordPatternMatch(pIndex + 1, i + 1))
                return true
            
            map[pattern[pIndex]] = undefined
            map[str] = undefined
        }
        
        return false
    }
    
    const map = {}
    return _wordPatternMatch(0, 0)
};
```

## 425. Word Squares
```javascript
/**
 * @param {string[]} words
 * @return {string[][]}
 */
var wordSquares = function(words) {
    const _wordSquares = col => {
        if (col >= n) {
            result.push(square.slice())
            return
        }
        
        const prefix = []
        for (let row = 0; row < col; row++) {
            prefix.push(square[row][col])
        }
        
        const words = trie.wordsWithPrefix(prefix)
        for (const word of words) {
            square.push(word)
            _wordSquares(col + 1)
            square.pop()
        }
    }
    
    if (!words.length) return []
    
    const trie = new Trie(words)
    const n = words[0].length
    
    const result = []
    const square = []
    _wordSquares(0)
    return result
};

class Trie {
    constructor(words) {
        this.root = new TrieNode()
        
        for (const word of words) {
            this.insert(word)
        }
    }
    
    insert(word) {
        let curr = this.root
        for (const char of word) {
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
        }
        
        curr.isEnd = word
    }
    
    wordsWithPrefix(prefix) {
        let curr = this.root
        for (const char of prefix) {
            if (!curr.children[char]) {
                return []
            }
            
            curr = curr.children[char]
        }
        
        const result = []
        this.dfs(result, curr)
        return result
    }
    
    dfs(result, curr) {
        if (curr.isEnd) {
            result.push(curr.isEnd)
            return
        }
        
        for (const node of Object.values(curr.children)) {
            this.dfs(result, node)
        }
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = ''
    }
}
```

## 294. Flip Game II
```javascript
// Backtracking - Time: O(N!!)
/**
 * @param {string} s
 * @return {boolean}
 */
var canWin = function(s) {
    const _canWin = () => {
        for (let i = 1; i < board.length; i++) {
            if (board[i] === '+' && board[i - 1] === '+') {
                board[i] = '-'
                board[i - 1] = '-'
                
                const result = !_canWin()

                board[i] = '+'
                board[i - 1] = '+'
                
                if (result) return true
            }
        }
        
        return false
    }
    
    const board = s.split('')
    return _canWin()
};

// Backtracking + Memo - Time: O(n * 2^(n/2))
/**
 * @param {string} s
 * @return {boolean}
 */
var canWin = function(s) {
    const _canWin = (s) => {
        if (memo[s] !== undefined) {
            return memo[s]
        }
        
        const str = s.split('')
        for (let i = 0; i < str.length - 1; i++) {
            if (str[i] === '+' && str[i + 1] === '+') {
                str[i] = '-'
                str[i + 1] = '-'
                
                const nextState = compressState(str)
                const result = !_canWin(nextState)
                
                str[i] = '+'
                str[i + 1] = '+'
                
                if (result) {
                    memo[s] = true
                    return true
                }
            }
        }
        
        memo[s] = false
        return false
    }
    
    const memo = {}
    return _canWin(s)
};

const compressState = str => {
    const result = []
    
    for (let i = 0; i < str.length; i++) {
        if (str[i] === '-' && str[i + 1] !== '-') {
            result.push(str[i])
        } else if (str[i] === '+') {
            result.push(str[i])
        }
    }
    
    return result.join('')
}
```

## 357. Count Numbers with Unique Digits
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var countNumbersWithUniqueDigits = function(n) {
    const _countNumbersWithUniqueDigits = (num, used) => {
        if (num >= upper) return
        count++
        
        for (let digit = 0; digit <= 9; digit++) {
            if (digit === 0 && num === 0) continue
            if (used & 1 << digit) continue
            const nextNum = num * 10 + digit
            _countNumbersWithUniqueDigits(nextNum, used | (1 << digit))
        }
    }
    
    const upper = 10 ** n
    let count = 0
    _countNumbersWithUniqueDigits(0, 0)
    return count
};
```

## 305. Number of Islands II
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @param {number[][]} positions
 * @return {number[]}
 */
var numIslands2 = function(m, n, positions) {
    const result = []
    const unionFind = new UnionFind()
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    for (const [row, col] of positions) {
        unionFind.add([row, col])
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            
            if (nextRow < 0 || nextCol < 0 || nextRow >= m || nextCol >= n)
                continue
            
            unionFind.union([row, col], [nextRow, nextCol])
        }
        
        result.push(unionFind.numOfComponents)
    }
    
    return result
};

class UnionFind {
    constructor() {
        this.numOfComponents = 0
        this.sizes = []
        this.parents = []
        this.map = {}
    }
    
    add(a) {
        if (this.map[a] !== undefined)
            return
        
        this.sizes.push(1)
        const id = this.parents.length
        this.parents.push(id)
        this.map[a] = id
        this.numOfComponents++
    }
    
    find(a) {
        if (this.map[a] === undefined) {
            return null
        }
        
        let start = this.map[a]
        let root = start
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (start !== root) {
            const next = this.parents[start]
            this.parents[start] = root
            start = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === null || parentB === null)
            return
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
}
```

## 827. Making A Large Island
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var largestIsland = function(grid) {
    let max = 0
    const map = {}
    
    let islandID = 2
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 1) {
                const size = getIslandSize(grid, row, col, islandID)
                max = Math.max(max, size)
                map[islandID] = size
                islandID++
            }
        }
    }
    
    const dirs = [[1, 0], [-1, 0], [0, -1], [0, 1]]
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 0) {
                const ids = new Set()
                for (const [deltaRow, deltaCol] of dirs) {
                    const nextRow = deltaRow + row
                    const nextCol = deltaCol + col
                    
                    if (nextRow < 0 || nextCol < 0 || 
                        nextRow >= grid.length || nextCol >= grid[0].length)
                        continue
                    
                    ids.add(grid[nextRow][nextCol])
                }
                
                let size = 1
                for (const id of ids) {
                    size += (map[id] || 0)
                }
                
                max = Math.max(max, size)
            }
        }
    }
    
    return max
};

const getIslandSize = (grid, row, col, islandID) => {
    if (row < 0 || col < 0 || 
        row >= grid.length || col >= grid[0].length || 
        grid[row][col] !== 1) return 0
    
    grid[row][col] = islandID
    
    return 1 + getIslandSize(grid, row + 1, col, islandID) + 
               getIslandSize(grid, row - 1, col, islandID) + 
               getIslandSize(grid, row, col + 1, islandID) + 
               getIslandSize(grid, row, col - 1, islandID)
}
```

## 684. Redundant Connection
```javascript
/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantConnection = function(edges) {
    const set = new DisjointSet(edges.length + 1)
    
    for (const [start, end] of edges) {
        if (set.find(start) === set.find(end))
            return [start, end]
            
        set.union(start, end)
    }
};

class DisjointSet {
    constructor(n) {
        this.numOfComponents = n
        this.componentSize = Array(n).fill(0)
        this.parent = []
        
        for (let i = 0; i < n; i++) {
            this.parent[i] = i
        }
    }
    
    find(p) {
        let root = p
        while (root !== this.parent[root])
            root = this.parent[root]
        
        while (p !== root) {
            const next = this.parent[p]
            this.parent[p] = root
            p = next
        }
        
        return root
    }
    
    union(p, q) {
        const rootP = this.find(p)
        const rootQ = this.find(q)
        
        if (rootP === rootQ) return
        
        if (this.componentSize[rootP] < this.componentSize[rootQ]) {
            this.componentSize[rootQ] += this.componentSize[rootP]
            this.parent[rootP] = rootQ 
        } else {
            this.componentSize[rootP] += this.componentSize[rootQ]
            this.parent[rootQ] = rootP
        }
        
        this.numOfComponents--
    }
}
```

## 1584. Min Cost to Connect All Points
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var minCostConnectPoints = function(points) {
    const unionFind = new UnionFind(points.length)
    let minCost = 0
    
    const edges = []
    for (let i = 0; i < points.length; i++) {
        for (let j = i + 1; j < points.length; j++) {
            const edge = [i, j, dist(points[i], points[j])]
            edges.push(edge)
        }
    }
    
    edges.sort((a, b) => a[2] - b[2])
    
    for (const [x, y, dist] of edges) {
        if (unionFind.find(x) === unionFind.find(y)) {
            continue
        }
        
        minCost += dist
        unionFind.union(x, y)
        
        if (unionFind.numOfComponents === 1) break
    }
    
    return minCost
};

const dist = (p1, p2) => {
    const [x1, y1] = p1
    const [x2, y2] = p2
    return Math.abs(x1 - x2) + Math.abs(y1 - y2)
}

class UnionFind {
    constructor(n) {
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill(0)
        for (let i = 0; i < n; i++) {
            this.parents[i] = i
        }
        
        this.numOfComponents = n
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB)
            return
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
}
```

## 1598. Crawler Log Folder
```javascript
/**
 * @param {string[]} logs
 * @return {number}
 */
var minOperations = function(logs) {
    let depth = 0
    
    for (const log of logs) {
        if (log === './') continue
        
        if (log === '../') {
            if (depth > 0) depth--
        } else {
            depth++
        }
    }
    
    return depth
};
```

## 952. Largest Component Size by Common Factor
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var largestComponentSize = function(A) {
    const unionFind = new UnionFind()
    
    for (const a of A) {
        unionFind.add(a)
        
        for (let i = 2; i <= Math.sqrt(a); i++) {
            if (a % i === 0) {
                unionFind.add(i)
                unionFind.add(a / i)
                
                unionFind.union(a, i)
                unionFind.union(a, a / i)
            }
        }
    }
    
    const groups = {}
    let count = 0
    
    for (const a of A) {
        const id = unionFind.find(a)
        groups[id] = 1 + (groups[id] || 0)
        count = Math.max(count, groups[id])
    }
    
    return count
};

class UnionFind {
    constructor() {
        this.map = {}
        this.parents = []
        this.sizes = []
        this.numOfComponents = 0
    }
    
    add(num) {
        if (this.map[num] !== undefined)
            return
        
        const id = this.parents.length
        this.map[num] = id
        this.parents.push(id)
        this.sizes.push(1)
        this.numOfComponents++
    }
    
    find(a) {
        if (this.map[a] === undefined) {
            return null
        }
        
        let id = this.map[a]
        let root = this.parents[id]
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (id !== root) {
            const next = this.parents[id]
            this.parents[id] = root
            id = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === null || parentB === null || parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
}
```

## 803. Bricks Falling When Hit
```javascript
/**
 * @param {number[][]} grid
 * @param {number[][]} hits
 * @return {number[]}
 */
var hitBricks = function(grid, hits) {
    const m = grid.length
    const n = grid[0].length
    const unionFind = new UnionFind(m * n + 1)
    
    for (const [row, col] of hits) {
        if (grid[row][col] === 1) {
            grid[row][col] = -1
        }
    }
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === 1) {
                unionFind.unionAround(row, col, grid)
            }
        }
    }
    
    const result = Array(hits.length).fill(0)
    for (let i = hits.length - 1; i >= 0; i--) {
        const [row, col] = hits[i]
        if (grid[row][col] !== -1)
            continue
        
        grid[row][col] = 1
        
        const prevRoofSize = unionFind.size(m * n)
        unionFind.unionAround(row, col, grid)
        const newRoofSize = unionFind.size(m * n)
        
        const count = newRoofSize - prevRoofSize - 1
        if (count > 0) result[i] = count
    }
    
    return result
};

class UnionFind {
    constructor(n) {
        this.numOfComponents = n
        this.roof = n - 1
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        for (let i = 0; i < this.parents.length; i++) {
            this.parents[i] = i
        }
    }
    
    size(a) {
        return this.sizes[this.find(a)]
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
    
    unionAround(row, col, grid) {
        const rowIndex = row * grid[0].length + col 
        
        for (const [deltaRow, deltaCol] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            
            if (nextRow < 0 || nextCol < 0 || 
                nextRow >= grid.length || nextCol >= grid[0].length || 
                grid[nextRow][nextCol] !== 1) continue
            
            const nextIndex = nextRow * grid[0].length + nextCol
            this.union(rowIndex, nextIndex)
        }
        
        if (row === 0) this.union(rowIndex, this.roof)
    }
}
```

## 1168. Optimize Water Distribution in a Village
```javascript
/**
 * @param {number} n
 * @param {number[]} wells
 * @param {number[][]} pipes
 * @return {number}
 */
var minCostToSupplyWater = function(n, wells, pipes) {
    const unionFind = new UnionFind(n + 1)
    const edges = []
    for (let i = 0; i < wells.length; i++) {
        edges.push([0, i + 1, wells[i]])
    }
    
    for (const pipe of pipes) {
        edges.push(pipe)
    }
    
    edges.sort((a, b) => a[2] - b[2])
    let minCost = 0
    
    for (const [start, end, cost] of edges) {
        if (unionFind.connected(start, end)) continue
        unionFind.union(start, end)
        minCost += cost
    }
    
    return minCost
};

class UnionFind {
    constructor(n) {
        this.numOfComponents = n
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        for (let i = 0; i < this.parents.length; i++) {
            this.parents[i] = i
        }
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
        
    }
    
    connected(a, b) {
        return this.find(a) === this.find(b)
    }
}
```

## 1579. Remove Max Number of Edges to Keep Graph Fully Traversable
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var maxNumEdgesToRemove = function(n, edges) {
    const unionFindA = new UnionFind(n + 1)
    const unionFindB = new UnionFind(n + 1)
    
    let count = 0
    for (const [type, start, end] of edges) {
        if (type !== 3) continue
        
        if (unionFindA.connected(start, end)) continue
        unionFindA.union(start, end)
        unionFindB.union(start, end)
        count++
        
        if (unionFindA.numOfComponents === 1 && unionFindB.numOfComponents === 1) {
            return edges.length - count
        }
    }
    
    for (const [type, start, end] of edges) {
        if (type === 3) continue
        
        if (type === 1) {
            if (unionFindA.connected(start, end)) continue
            unionFindA.union(start, end)
            count++
        } else if (type === 2) {
            if (unionFindB.connected(start, end)) continue
            unionFindB.union(start, end)
            count++
        }
        
        if (unionFindA.numOfComponents === 1 && unionFindB.numOfComponents === 1) {
            return edges.length - count
        }
    }
    
    return -1
};

class UnionFind {
    constructor(n) {
        this.numOfComponents = n - 1
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        for (let i = 0; i < this.parents.length; i++) {
            this.parents[i] = i
        }
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) {
            return
        }
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
        
    }
    
    connected(a, b) {
        return this.find(a) === this.find(b)
    }
}
```

## 41. First Missing Positive
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    if (!nums.length) return 1
    
    for (let i = 0; i < nums.length; i++) {
        // If negative, invalid so set to Infinity
        if (nums[i] <= 0) {
            nums[i] = Infinity
            continue
        }
    }
    
    for (let i = 0; i < nums.length; i++) {
        if (Math.abs(nums[i]) === Infinity) continue
        
        const index = Math.abs(nums[i]) - 1
        if (index < nums.length) {
            nums[index] = -Math.abs(nums[index])
        }
    }
    
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) return i + 1
    }
    
    return nums.length + 1
};
```

## 1305. All Elements in Two Binary Search Trees
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {number[]}
 */
var getAllElements = function(root1, root2) {
    const result = []
    const stack1 = []
    const stack2 = []
    let curr1 = root1
    let curr2 = root2
    
    while (curr1 || curr2 || stack1.length || stack2.length) {
        while (curr1) {
            stack1.push(curr1)
            curr1 = curr1.left
        }
        
        while (curr2) {
            stack2.push(curr2)
            curr2 = curr2.left
        }
        
        if (!stack2.length || 
            stack1.length && stack1[stack1.length - 1].val <= stack2[stack2.length - 1].val) {
            curr1 = stack1.pop()
            result.push(curr1.val)
            curr1 = curr1.right
        } else {
            curr2 = stack2.pop()
            result.push(curr2.val)
            curr2 = curr2.right
        }
    }
    
    return result
};
```

## 928. Minimize Malware Spread II
```javascript
// DFS
/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    const infected = new Set(initial)
    let maxSaved = -1
    let result = Math.min(...initial)
    
    for (const i of initial) {
        const saved = dfs(i, graph, infected)
        
        if (maxSaved < saved) {
            result = i
            maxSaved = Math.max(maxSaved, saved)
        } else if (maxSaved === saved) {
            result = Math.min(result, i)
        } 
    }
    
    return result
};

const dfs = (i, graph, infected) => {
    const _dfs = node => {
        if (visited.has(node)) return 0
        if (infected.has(node)) return -1
        visited.add(node)
            
        let saved = 1
        for (let j = 0; j < graph[node].length; j++) {
            if (node === j || graph[node][j] !== 1) continue
            const result = _dfs(j)
            if (result === -1) {
                infected.add(node)
                return -1
            }
            saved += result
        }
        
        return saved
    }
    
    const visited = new Set([i])
    
    let saved = 0
    for (let j = 0; j < graph[i].length; j++) {
        if (i === j || graph[i][j] !== 1) continue
        const result = _dfs(j)
        if (result === -1) continue
        saved += result
        
    }
    
    return saved
}

// Union Find

```

## 854. K-Similar Strings
```javascript
/**
 * @param {string} A
 * @param {string} B
 * @return {number}
 */
var kSimilarity = function(A, B) {
    if (A === B) return 0
    
    const queue = [A]
    const visited = new Set([A])
    let level = 0
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            if (node === B) return level
            
            for (const neighbour of getNeighbors(node, B)) {
                if (visited.has(neighbour)) continue
                queue.push(neighbour)
                visited.add(neighbour)
            }
        }
        
        level++
    }
    
    return -1
};

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

const getNeighbors = (S, B) => {
    const result = []
    const charArr = S.split('')
    
    let i = 0
    while (i < charArr.length && charArr[i] === B[i]) {
        i++
    }
    
    for (let j = i + 1; j < charArr.length; j++) { 
        if (charArr[j] === B[i]) {
            swap(charArr, i, j)     
            result.push(charArr.join(''))
            swap(charArr, i, j)
        }
    }
    
    return result
}
```

## 765. Couples Holding Hands
```javascript
/**
 * @param {number[]} row
 * @return {number}
 */
var minSwapsCouples = function(row) {
    let result = 0
    
    const map = {}
    for (let i = 0; i < row.length; i++) {
        map[row[i]] = i
    }
    
    for (let i = 0; i < row.length; i += 2) {
        const x = row[i]
        const target = x & 1 ? x - 1 : x + 1
        
        if (row[i + 1] === target) continue
        result++
        
        const targetIndex = map[target]
        row[targetIndex] = row[i + 1]
        row[i + 1] = target
        map[row[targetIndex]] = targetIndex
        map[row[i + 1]] = i + 1
    }
    
    return result
};
```

## 1602. Find Nearest Right Node in Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} u
 * @return {TreeNode}
 */
var findNeartestRightNode = function(root, u) {
    const queue = [root]
    
    while (queue.length) {
        const size = queue.length
        let isLevel = false
        for (let i = 0; i < size; i++) {
            const node = queue.shift()            
            if (isLevel) return node
            
            if (node.val === u.val) {
                isLevel = true
            }
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        
        if (isLevel) break
    }
    
    return null
};
```

## 1217. Minimum Cost to Move Chips to The Same Position
```javascript
/**
 * @param {number[]} chips
 * @return {number}
 */
var minCostToMoveChips = function(chips) {
    let evens = 0
    let odds = 0
    
    for (let i = 0; i < chips.length; i++) {
        chips[i] & 1 ? odds++ : evens++
    }
    
    return Math.min(evens, odds)
};
```

## 1603. Design Parking System
```javascript
/**
 * @param {number} big
 * @param {number} medium
 * @param {number} small
 */
var ParkingSystem = function(big, medium, small) {
    this.counts = [big, medium, small]
};

/** 
 * @param {number} carType
 * @return {boolean}
 */
ParkingSystem.prototype.addCar = function(carType) {
    return this.counts[carType - 1]-- > 0
};

/** 
 * Your ParkingSystem object will be instantiated and called as such:
 * var obj = new ParkingSystem(big, medium, small)
 * var param_1 = obj.addCar(carType)
 */
```

## 1604. Alert Using Same Key-Card Three or More Times in a One Hour Period
```javascript
/**
 * @param {string[]} keyName
 * @param {string[]} keyTime
 * @return {string[]}
 */
var alertNames = function(keyName, keyTime) {
    const result = []
    const map = {}
    
    for (let i = 0; i < keyName.length; i++) {
        if (!map[keyName[i]]) map[keyName[i]] = []
        map[keyName[i]].push(keyTime[i])
    }
    
    for (const [key, val] of Object.entries(map)) {
        map[key].sort()
        if (alerted(val)) result.push(key)
    }
    
    result.sort()
    return result
};

const alerted = times => {
    let i = 0
    for (let j = 0; j < times.length; j++) {
        while (minsBetween(times[i], times[j]) > 60)
            i++
        
        if (j - i + 1 >= 3) return true
    }
    
    return false
}

const minsBetween = (start, end) => {
    const [sHour, sMin] = start.split(':')
    const [eHour, eMin] = end.split(':')
    const sMins = (+sHour * 60) + +sMin
    const eMins = (+eHour * 60) + +eMin
    return Math.abs(eMins - sMins)
}
```

## 1605. Find Valid Matrix Given Row and Column Sums
```javascript
// Time: O(n * m)
/**
 * @param {number[]} rowSum
 * @param {number[]} colSum
 * @return {number[][]}
 */
var restoreMatrix = function(rowSum, colSum) {
    const n = rowSum.length
    const m = colSum.length
    const matrix = Array(n).fill(0).map(a => Array(m).fill(0))

    for (let row = 0; row < n; row++) {
        for (let col = 0; col < m && rowSum[row] > 0; col++) {
            matrix[row][col] = Math.min(rowSum[row], colSum[col])
            rowSum[row] -= matrix[row][col]
            colSum[col] -= matrix[row][col]
            
        }
    }
    
    return matrix
};

// Time: O(n + m)
/**
 * @param {number[]} rowSum
 * @param {number[]} colSum
 * @return {number[][]}
 */
var restoreMatrix = function(rowSum, colSum) {
    const n = rowSum.length
    const m = colSum.length
    const matrix = Array(n).fill(0).map(a => Array(m).fill(0))

    let row = 0
    let col = 0
    while (row < n && col < m) {
        matrix[row][col] = Math.min(rowSum[row], colSum[col])
        rowSum[row] -= matrix[row][col]
        colSum[col] -= matrix[row][col]
        row += rowSum[row] === 0
        col += colSum[col] === 0
    }
    
    return matrix
};
```

## 1607. Sellers With No Sales
```sql
# Write your MySQL query statement below
SELECT seller_name
FROM Seller AS s
LEFT JOIN Orders AS o
ON s.seller_id = o.seller_id AND YEAR(sale_date) = 2020
WHERE order_id IS NULL
ORDER BY seller_name
```

## 711. Number of Distinct Islands II
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var numDistinctIslands2 = function(grid) {
    const islands = new Set()
    
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 0) continue
            const island = getIsland(grid, row, col)
            islands.add(normalize(island))
        }
    }
    
    return islands.size
};

const normalize = island => {
    const transformedIslands = Array(8).fill().map(a => [])
    for (const [row, col] of island) {
        transformedIslands[0].push([row, col])
        transformedIslands[1].push([-row, col])
        transformedIslands[2].push([row, -col])
        transformedIslands[3].push([-row, -col])
        transformedIslands[4].push([col, row])
        transformedIslands[5].push([-col, row])
        transformedIslands[6].push([col, -row])
        transformedIslands[7].push([-col, -row])
    }
    
    for (const transformedIsland of transformedIslands) {
        transformedIsland.sort((a, b) => {
            if (a[0] === b[0]) {
                return a[1] - b[1]
            }
            
            return a[0] - b[0]
        })
    }
    
    for (const transformedIsland of transformedIslands) {
        const originRow = transformedIsland[0][0]
        const originCol = transformedIsland[0][1]
        for (let i = 1; i < island.length; i++) {
            const row = transformedIsland[i][0] - originRow
            const col = transformedIsland[i][1] - originCol
            transformedIsland[i] = [row, col]
        }
        
        transformedIsland[0] = [0, 0]
    }
    
    transformedIslands.sort()
    return transformedIslands[0].join('')
}

const getIsland = (grid, startRow, startCol) => {
    const dfs = (row, col) => {
        if (row < 0 || col < 0 || 
            row >= grid.length || col >= grid[0].length || 
            grid[row][col] === 0)
            return
        
        island.push([row, col])
        grid[row][col] = 0
        
        dfs(row + 1, col)
        dfs(row - 1, col)
        dfs(row, col + 1)
        dfs(row, col - 1)
    }
    
    const island = []
    dfs(startRow, startCol)
    return island
}
```

## 1608. Special Array With X Elements Greater Than or Equal X
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var specialArray = function(nums) {
    const counts = Array(1001).fill(0)
    for (const num of nums) {
        counts[num]++
    }
    
    for (let i = counts.length - 2; i >= 0; i--) {
        counts[i] += counts[i + 1] 
    }
    
    for (let i = nums.length; i >= 0; i--) {
        if (counts[i] === i) {
            return i
        }
    }
    
    return -1
};
```

## 1609. Even Odd Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isEvenOddTree = function(root) {
    const queue = [root]
    let level = 0
    while (queue.length) {
        const size = queue.length
        let lastVal = isEven(level) ? -Infinity : Infinity
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (isEven(level) && (isEven(node.val) || lastVal >= node.val)) {
                return false
            }
            
            if (!isEven(level) && (!isEven(node.val) || lastVal <= node.val)) {
                return false
            }
            
            lastVal = node.val
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        level++
    }
    
    return true
};

const isEven = num => num % 2 === 0
```

## 1568. Minimum Number of Days to Disconnect Island
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minDays = function(grid) {
    const [numOfComponents, onesCount] = getNumOfComponents(grid)
    if (numOfComponents !== 1) return 0
    if (onesCount <= 2) return onesCount
    
    const articulationPoints = getArticulationPoints(grid)
    if (articulationPoints.length) return 1
    
    return 2
};

const getNumOfComponents = grid => {
    const dirs = [[1, 0], [0, 1]]
    const m = grid.length
    const n = grid[0].length
    let onesCount = 0
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            onesCount += grid[row][col]
        }
    }
    
    const unionFind = new UnionFind(m * n, onesCount)
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === 0) continue
            
            for (const [deltaRow, deltaCol] of dirs) {
                const nextRow = deltaRow + row
                const nextCol = deltaCol + col
                
                if (nextRow < 0 || nextRow >= m || 
                    nextCol < 0 || nextCol >= n ||
                    grid[nextRow][nextCol] === 0) continue
                
                unionFind.union(row * n + col, nextRow * n + nextCol)
            }
        }
    }
    
    return [unionFind.numOfComponents, onesCount]
}

const getArticulationPoints = grid => {
    const graph = buildGraph(grid)
    const articulationPoints = new Set()
    const visited = new Set()
    const low = {}
    const discovery = {}
    
    for (const [vertex, neighbors] of Object.entries(graph)) {
        if (visited.has(vertex)) continue
        const children = tarjan(graph, vertex, articulationPoints, visited, low, discovery)
        if (children > 1) articulationPoints.add(+vertex)
    }
    
    return Array.from(articulationPoints)
}

const tarjan = (graph, root, articulationPoints, visited, low, discovery) => {
    const _tarjan = (vertex, parent) => {
        visited.add(+vertex)
        low[vertex] = time
        discovery[vertex] = time
        time++
        
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                if (!visited.has(neighbor)) {
                    if (vertex === root)
                        children++
                    
                    _tarjan(neighbor, vertex)
                    low[vertex] = Math.min(low[vertex], low[neighbor])
                    
                    if (parent !== null && discovery[vertex] <= low[neighbor]) {
                        articulationPoints.add(vertex)
                    }

                } else if (neighbor !== parent) {
                    low[vertex] = Math.min(discovery[neighbor], low[vertex])
                }
            }
        }
    }
    
    let children = 0
    let time = 0
    _tarjan(root, null)
    return children
}

const buildGraph = grid => {
    const graph = {}
    const dirs = [[1, 0], [0, 1]]
    const m = grid.length
    const n = grid[0].length
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === 0) continue
            
            for (const [deltaRow, deltaCol] of dirs) {
                const nextRow = deltaRow + row
                const nextCol = deltaCol + col
                
                if (nextRow < 0 || nextRow >= m || 
                    nextCol < 0 || nextCol >= n ||
                    grid[nextRow][nextCol] === 0) continue
                
                const id1 = row * n + col
                const id2 = nextRow * n + nextCol
                if (!graph[id1]) graph[id1] = []
                if (!graph[id2]) graph[id2] = []
                graph[id1].push(id2)
                graph[id2].push(id1)
            }
        }
    }
    
    return graph
}

class UnionFind {
    constructor(n, count) {
        this.numOfComponents = count
        this.sizes = Array(n).fill(1)
        this.parents = Array(n).fill()
        for (let i = 0; i < this.parents.length; i++) {
            this.parents[i] = i
        }
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) return
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.sizes[parentB] += this.sizes[parentA]
            this.parents[parentA] = parentB
        } else {
            this.sizes[parentA] += this.sizes[parentB]
            this.parents[parentB] = parentA
        }
        
        this.numOfComponents--
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (a !== root) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
}
```

## 1192. Critical Connections in a Network
```javascript
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number[][]}
 */
var criticalConnections = function(n, connections) {
    const graph = buildGraph(n, connections)
    const bridges = tarjan(n, graph)
    return bridges
};

const tarjan = (n, graph) => {
    const _tarjan = (vertex, parent) => {
        discovery[vertex] = time
        low[vertex] = time
        time++
        
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                if (discovery[neighbor] === -1) {
                    _tarjan(neighbor, vertex)
                    low[vertex] = Math.min(low[vertex], low[neighbor])
                    
                    if (discovery[vertex] < low[neighbor]) {
                        bridges.push([vertex, neighbor])
                    }
                    
                } else if (neighbor !== parent) {
                    low[vertex] = Math.min(low[vertex], discovery[neighbor])
                }
            }
        }
    }
    
    const bridges = []
    const discovery = Array(n).fill(-1)
    const low = Array(n).fill(-1)
    let time = 0
    
    for (let vertex = 0; vertex < n; vertex++) {
        if (discovery[vertex] !== -1) continue
        _tarjan(vertex, null)
    }
    
    return bridges
}

const buildGraph = (n, connections) => {
    const graph = Array(n).fill()
    
    for (const [a, b] of connections) {
        if (!graph[a]) graph[a] = []
        if (!graph[b]) graph[b] = []
        graph[a].push(b)
        graph[b].push(a)
    }
    
    return graph
}
```

## 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance
```javascript
// Floyd-Warshall: Time: O(V^3), Space: O(V^2)
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} distanceThreshold
 * @return {number}
 */
var findTheCity = function(n, edges, distanceThreshold) {
    const matrix = Array(n).fill().map(a => Array(n).fill(Infinity))
    
    for (const [from, to, weight] of edges) {
        matrix[from][to] = weight
        matrix[to][from] = weight
    }
    
    for (let i = 0; i < n; i++) {
        matrix[i][i] = 0
    }
    
    for (let intermediate = 0; intermediate < n; intermediate++) {
        for (let from = 0; from < n; from++) {
            for (let to = 0; to < n; to++) {
                matrix[from][to] = Math.min(matrix[from][to],
                                            matrix[from][intermediate] + matrix[intermediate][to])
            }
        }
    }
    
    let result = 0
    let smallest = n
    for (let from = 0; from < n; from++) {
        let count = 0
        for (let to = 0; to < n; to++) {
            if (matrix[from][to] <= distanceThreshold) {
                count++
            }
        }
        
        if (count <= smallest) {
            result = from
            smallest = count
        }
    }
    
    return result
};
```

## 544. Output Contest Matches
```javascript
/**
 * @param {number} n
 * @return {string}
 */
// Recursive
var findContestMatch = function(n) {
    const _findContestMatch = (curr) => {
        if (curr.length === 1)
            return curr[0]
        
        const next = []
        let left = 0
        let right = curr.length - 1
        
        while (left < right) {
            next.push(`(${curr[left]},${curr[right]})`)
            left++
            right--
        }
        
        return _findContestMatch(next)
    }
    
    const start = []
    for (let team = 1; team <= n; team++) {
        start.push(team)
    }
    
    return _findContestMatch(start)
};

/**
 * @param {number} n
 * @return {string}
 */
// Iterative
var findContestMatch = function(n) {
    let result = []
    for (let i = 1; i <= n; i++) {
        result.push(i)
    }
    
    while (result.length > 1) {
        let i = 0
        let j = result.length - 1
        const next = []
        while (i < j) {
            next.push(`(${result[i]},${result[j]})`)
            i++
            j--
        }
        
        result = next
    }
    
    return result.join('')
};
```

## 1614. Maximum Nesting Depth of the Parentheses
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maxDepth = function(s) {
    let balance = 0
    let depth = 0
    
    for (const char of s) {
        if (char === '(') {
            balance++
            depth = Math.max(depth, balance)
        } else if (char === ')') {
            balance--
        }
    }
    
    return depth
};
```

## 1615. Maximal Network Rank
```javascript
/**
 * @param {number} n
 * @param {number[][]} roads
 * @return {number}
 */
var maximalNetworkRank = function(n, roads) {
    const degrees = Array(n).fill(0)
    const connected = Array(n).fill(0).map(a => Array(n).fill(false))
    
    for (let i = 0; i < roads.length; i++) {
        const [u, v] = roads[i]
        degrees[u]++
        degrees[v]++
        
        connected[u][v] = true
        connected[v][u] = true
    }
    
    let max = 0
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const rank = degrees[i] + degrees[j] - connected[i][j]
            max = Math.max(max, rank)
        }
    }
    
    return max
};
```

## 1557. Minimum Number of Vertices to Reach All Nodes
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var findSmallestSetOfVertices = function(n, edges) {
    const indegrees = Array(n).fill(0)
    for (const [u, v] of edges) {
        indegrees[v]++
    }
    
    const result = []
    for (let vertex = 0; vertex < n; vertex++) {
        if (indegrees[vertex] === 0) {
            result.push(vertex)
        }
    }
    
    return result
};
```

## 332. Reconstruct Itinerary
```javascript
/**
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = function(tickets) {
    const graph = buildGraph(tickets)
    const result = []
    hierholzer(graph, result)
    result.reverse()
    return result
};

const hierholzer = (graph, result) => {
    const _hierholzer = vertex => {
        while (graph[vertex] && graph[vertex].length) {
            _hierholzer(graph[vertex].shift())
        }
        
        result.push(vertex)
    }
    
    _hierholzer('JFK')
}

const buildGraph = tickets => {
    tickets.sort()
    
    const graph = {}
    
    for (const [u, v] of tickets) {
        if (!graph[u]) graph[u] = []
        graph[u].push(v)
    } 
    
    return graph
}

// Heap
/**
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = function(tickets) {
    const graph = buildGraph(tickets)
    return dfs(graph, 'JFK')
};

const dfs = (graph, vertex) => {
    const _dfs = vertex => {
        if (graph[vertex]) {
            while (graph[vertex].length()) {
                _dfs(graph[vertex].remove())
            }
        }
        
        stack.push(vertex)
    }
    
    const seen = new Set()
    const stack = []
    _dfs(vertex)
    return stack.reverse()
}

const buildGraph = tickets => {
    const graph = {}
    
    for (const [u, v] of tickets) {
        if (!graph[u]) graph[u] = new Heap()
        graph[u].insert(v)
    }
    
    return graph
}

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 967. Numbers With Same Consecutive Differences
```javascript
// DFS / Backtracking
/**
 * @param {number} n
 * @param {number} k
 * @return {number[]}
 */
var numsSameConsecDiff = function(n, k) {
    const _numsSameConsecDiff = (num, length) => {
        if (length === n) {
            result.push(num)
            return
        }
        
        const currDigit = num % 10
        
        let nextDigit = currDigit - k
        if (nextDigit >= 0) {
            _numsSameConsecDiff(num * 10 + nextDigit, length + 1)
        }
        
        nextDigit = currDigit + k
        if (k !== 0 && nextDigit <= 9) {
            _numsSameConsecDiff(num * 10 + nextDigit, length + 1)
        }
    }
    
    const result = []
    for (let num = 1; num <= 9; num++) {
        _numsSameConsecDiff(num, 1)
    }
    
    return result
};

// BFS
/**
 * @param {number} n
 * @param {number} k
 * @return {number[]}
 */
var numsSameConsecDiff = function(n, k) {
    const queue = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    let level = 0
    while (queue.length && level < n - 1) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const num = queue.shift()
            
            const currDigit = num % 10
            
            let nextDigit = currDigit - k
            if (nextDigit >= 0) {
                queue.push(num * 10 + nextDigit)
            }
            
            nextDigit = currDigit + k
            if (k !== 0 && nextDigit <= 9) {
                queue.push(num * 10 + nextDigit)
            }
        }
        level++
    }
    
    return queue
};
```

## 1485. Clone Binary Tree With Random Pointer
```javascript
// DFS
/**
 * // Definition for a Node.
 * function Node(val, left, right, random) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.random = random === undefined ? null : random;
 * };
 */

/**
 * @param {Node} root
 * @return {NodeCopy}
 */
var copyRandomBinaryTree = function(root) {
    const dfs = node => {
        if (!node) return null
        if (map.get(node)) return map.get(node)
        
        const clonedNode = new NodeCopy(node.val)
        map.set(node, clonedNode)

        clonedNode.left = dfs(node.left)
        clonedNode.right = dfs(node.right)
        clonedNode.random = dfs(node.random)
        return clonedNode
    }
    
    const map = new Map()
    return dfs(root)
};

// BFS
/**
 * // Definition for a Node.
 * function Node(val, left, right, random) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.random = random === undefined ? null : random;
 * };
 */

/**
 * @param {Node} root
 * @return {NodeCopy}
 */
var copyRandomBinaryTree = function(root) {
    if (!root) return root
    
    const map = new Map()
    map.set(root, new NodeCopy(root.val))
    
    const queue = [root]
    while (queue.length) {
        const node = queue.shift()
        const cloneNode = map.get(node)
        
        if (node.left) {
            if (!map.get(node.left)) {
                const newNode = new NodeCopy(node.left.val)
                map.set(node.left, newNode)
            }
            cloneNode.left = map.get(node.left)
            queue.push(node.left)
        }
        
        if (node.right) {
            if (!map.get(node.right)) {
                const newNode = new NodeCopy(node.right.val)
                map.set(node.right, newNode)
            }
            cloneNode.right = map.get(node.right)
            queue.push(node.right)
        }
        
        if (node.random) {
            if (!map.get(node.random)) {
                const newNode = new NodeCopy(node.random.val)
                map.set(node.random, newNode)
            }
            cloneNode.random = map.get(node.random)
        }
    }
    
    return map.get(root)
};
```

## 1624. Largest Substring Between Two Equal Characters
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maxLengthBetweenEqualCharacters = function(s) {
    let max = -1
    const map = Array(26).fill()
    for (let i = 0; i < s.length; i++) {
        const char = s[i]
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        
        if (map[index] === undefined) {
            map[index] = i
        }
        
        max = Math.max(max, i - map[index] - 1)
    }
    
    return max
};
```

## 1623. All Valid Triplets That Can Represent a Country
```sql
# Write your MySQL query statement below
SELECT a.student_name AS 'member_A', 
       b.student_name AS 'member_B', 
       c.student_name AS 'member_C'
FROM SchoolA AS a
JOIN SchoolB AS b
JOIN SchoolC AS c
WHERE a.student_id <> b.student_id AND 
      b.student_id <> c.student_id AND 
      a.student_id <> c.student_id AND 
      a.student_name <> b.student_name AND 
      b.student_name <> c.student_name AND 
      a.student_name <> c.student_name
```

## 1619. Mean of Array After Removing Some Elements
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var trimMean = function(arr) {
    arr.sort((a, b) => a - b)
    
    const percent = arr.length * 0.05
    let count = 0
    let sum = 0
    for (let i = percent; i <= arr.length - 1 - percent; i++) {
        count++
        sum += arr[i]
    }
    return sum / count
};
```

## 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
```javascript
/**
 * @param {number[][]} mat
 * @return {number}
 */
var minFlips = function(mat) {
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    const rowLen = mat.length
    const colLen = mat[0].length
    
    const target = 0
    let start = 0
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            start |= mat[row][col] << row * colLen + col
        }
    }
    
    const visited = new Set([start])
    const queue = [start]
    
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const currMat = queue.shift()
            if (currMat === target) return level

            for (let row = 0; row < rowLen; row++) {
                for (let col = 0; col < colLen; col++) {
                    let nextMat = currMat
                    nextMat ^= 1 << row * colLen + col
                    
                    for (const [dRow, dCol] of dirs) {
                        const nextRow = dRow + row
                        const nextCol = dCol + col
                        
                        if (nextRow < 0 || nextRow >= rowLen || 
                            nextCol < 0 || nextCol >= colLen) continue
                        
                        nextMat ^= 1 << nextRow * colLen + nextCol
                    }
                    
                    if (visited.has(nextMat)) continue
                    visited.add(nextMat)
                    
                    queue.push(nextMat)
                }
            }
        }
        level++
    }
    return -1
};
```

## 1298. Maximum Candies You Can Get from Boxes
```javascript
/**
 * @param {number[]} status
 * @param {number[]} candies
 * @param {number[][]} keys
 * @param {number[][]} containedBoxes
 * @param {number[]} initialBoxes
 * @return {number}
 */
var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {
    let result = 0
    
    const available = new Set(initialBoxes)
    const visited = new Set(initialBoxes)
    const queue = initialBoxes
    
    while (queue.length) {
        const box = queue.shift()
        
        result += candies[box]
        
        for (const containedBox of containedBoxes[box]) {
            if (visited.has(containedBox)) continue
            
            available.add(containedBox)
            
            if (status[containedBox] === 1) {
                visited.add(containedBox)
                queue.push(containedBox)
            }
        }
        
        for (const key of keys[box]) {
            if (visited.has(key)) continue
            
            status[key] = 1
            
            if (available.has(key)) {
                visited.add(key)
                queue.push(key)
            }
        }
    }
    
    return result
};
```

## 847. Shortest Path Visiting All Nodes
```javascript
/**
 * @param {number[][]} graph
 * @return {number}
 */
var shortestPathLength = function(graph) {
    const n = graph.length
    
    const visited = Array(1 << n).fill().map(a => Array(n).fill(false))
    const queue = []
    for (let i = 0; i < n; i++) {
        const seen = 1 << i
        queue.push([i, seen])
        visited[i][seen] = true
    }
    
    const target = (1 << n) - 1
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [node, seen] = queue.shift()
            if (seen === target) return level
            
            for (const neighbor of graph[node]) {
                let nextSeen = seen
                nextSeen |= 1 << neighbor
                
                if (visited[neighbor][nextSeen]) continue
                visited[neighbor][nextSeen] = true
                queue.push([neighbor, nextSeen])
            }
        }
        level++
    }
};
```

## 317. Shortest Distance from All Buildings
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var shortestDistance = function(grid) {
    const rowLen = grid.length
    const colLen = grid[0].length
    
    const dists = Array(rowLen).fill().map(a => Array(colLen).fill(0))
    const reached = Array(rowLen).fill().map(a => Array(colLen).fill(0))
    let numOfBuildings = 0
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (grid[row][col] === 1) {
                bfs(row, col, grid, dists, reached)
                numOfBuildings++
            }
        }
    }
    
    let minPath = Infinity
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (reached[row][col] === numOfBuildings) {
                minPath = Math.min(minPath, dists[row][col])
            }
        }
    }
    
    return minPath === Infinity ? -1 : minPath
};

const bfs = (row, col, grid, dists, reached) => {
    const rowLen = grid.length
    const colLen = grid[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const visited = Array(rowLen).fill().map(a => Array(colLen).fill(false))
    const queue = [[row, col]]
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()

            for (const [dRow, dCol] of dirs) {
                const nextRow = dRow + row
                const nextCol = dCol + col

                if (nextRow < 0 || nextRow >= rowLen || 
                    nextCol < 0 || nextCol >= colLen || 
                    grid[nextRow][nextCol] !== 0) continue

                if (visited[nextRow][nextCol]) continue
                visited[nextRow][nextCol] = true

                dists[nextRow][nextCol] += level + 1
                reached[nextRow][nextCol]++

                queue.push([nextRow, nextCol])
            }
        }
        level++
    }
}
```

## 675. Cut Off Trees for Golf Event
```javascript
// BFS
/**
 * @param {number[][]} forest
 * @return {number}
 */
var cutOffTree = function(forest) {
    const rowLen = forest.length
    const colLen = forest[0].length
    
    const cells = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (forest[row][col] === 0 || forest[row][col] === 1) continue
            cells.push([row, col])
        }
    }
    
    let curr = [0, 0]
    let minDist = 0
    const heap = new Heap(cells, (a, b) => {
        const [aRow, aCol] = a
        const [bRow, bCol] = b
        return forest[aRow][aCol] < forest[bRow][bCol]
    })
    
    while (heap.length()) {
        const [currRow, currCol] = curr
        const [nextRow, nextCol] = heap.remove()
        const dist = shortestPath(currRow, currCol, nextRow, nextCol, forest)
        if (dist === -1)
            return -1
        
        minDist += dist
        curr = [nextRow, nextCol]
    }
    
    return minDist === Infinity ? -1 : minDist
};

const shortestPath = (currRow, currCol, targetRow, targetCol, forest) => {
    if (currRow === targetRow && currCol === targetCol)
        return 0
    
    const rowLen = forest.length
    const colLen = forest[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const visited = Array(rowLen).fill().map(a => Array(colLen).fill(false))
    visited[currRow][currCol] = true
    
    const queue = [[currRow, currCol]]
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()

            for (const [dRow, dCol] of dirs) {
                const nextRow = dRow + row
                const nextCol = dCol + col

                if (nextRow < 0 || nextRow >= rowLen || 
                    nextCol < 0 || nextCol >= colLen || 
                    forest[nextRow][nextCol] === 0) continue

                if (nextRow === targetRow && nextCol === targetCol) {
                    return level + 1
                }
                
                if (visited[nextRow][nextCol]) continue
                visited[nextRow][nextCol] = true
                
                queue.push([nextRow, nextCol])
            }
        }
        level++
    }
    
    return -1
}

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}

// A*
/**
 * @param {number[][]} forest
 * @return {number}
 */
var cutOffTree = function(forest) {
    const rowLen = forest.length
    const colLen = forest[0].length
    
    const cells = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (forest[row][col] <= 1) continue
            cells.push([row, col])
        }
    }
    
    let curr = [0, 0]
    let minDist = 0
    const heap = new Heap(cells, (a, b) => {
        const [aRow, aCol] = a
        const [bRow, bCol] = b
        return forest[aRow][aCol] < forest[bRow][bCol]
    })
    
    while (heap.length()) {
        const [currRow, currCol] = curr
        const [nextRow, nextCol] = heap.remove()
        const dist = shortestPath(currRow, currCol, nextRow, nextCol, forest)
        if (dist === -1)
            return -1
        
        minDist += dist
        curr = [nextRow, nextCol]
    }
    
    return minDist === Infinity ? -1 : minDist
};

const shortestPath = (currRow, currCol, targetRow, targetCol, forest) => {
    if (currRow === targetRow && currCol === targetCol)
        return 0
    
    const rowLen = forest.length
    const colLen = forest[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const dists = Array(rowLen).fill().map(a => Array(colLen).fill(Infinity))
    dists[currRow][currCol] = 0
    
    const start = [currRow, currCol, 0, heuristic(currRow, currCol, targetRow, targetCol)]
    const queue = new Heap([start], (a, b) => {
        const [, , aG, aH] = a
        const [, , bG, bH] = b
        return aG + aH < bG + bH
    })
    
    while (queue.length()) {
        const [row, col, level] = queue.remove()

        for (const [dRow, dCol] of dirs) {
            const nextRow = dRow + row
            const nextCol = dCol + col

            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen || 
                forest[nextRow][nextCol] === 0) continue
            
            if (dists[nextRow][nextCol] <= dists[row][col] + 1) {
                continue
            }
            
            dists[nextRow][nextCol] = dists[row][col] + 1
            
            if (nextRow === targetRow && nextCol === targetCol) {
                return dists[nextRow][nextCol]
            }
            
            queue.insert([nextRow, 
                          nextCol, 
                          level + 1, 
                          heuristic(nextRow, nextCol, targetRow, targetCol)])
        }
    }
    
    return -1
}

const heuristic = (x1, y1, x2, y2) => {
    return Math.abs(x2 - x1) + Math.abs(y2 - y1)
}

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 1210. Minimum Moves to Reach Target with Rotations
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumMoves = function(grid) {
    const n = grid.length
    
    const visited = new Set()
    const queue = [['h', [0,0,0,1]]]
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [dir, pos] = queue.shift()
            
            if (reachedEnd(dir, pos, n)) {
                return level
            }
            
            moveRight(dir, pos, queue, grid, visited)
            moveDown(dir, pos, queue, grid, visited)
            rotateClockwise(dir, pos, queue, grid, visited)
            rotateCounterClockwise(dir, pos, queue, grid, visited)
        }
        
        level++
    }
    
    return -1
};

const reachedEnd = (dir, pos, n) => {
    const [rowT, colT, rowH, colH] = pos
    return rowT === n - 1 && colT === n - 2 && 
           rowH === n - 1 && colH === n - 1
}

const moveRight = (dir, pos, queue, grid, visited) => {
    const [rowT, colT, rowH, colH] = pos
    if (!isValid(rowT, colT + 1, grid) || !isValid(rowH, colH + 1, grid))
        return
    
    const state = [dir, [rowT, colT + 1, rowH, colH + 1]]
    const stateStr = JSON.stringify(state)

    if (visited.has(stateStr)) return
    visited.add(stateStr)

    queue.push(state)
}

const moveDown = (dir, pos, queue, grid, visited) => {
    const [rowT, colT, rowH, colH] = pos
    if (!isValid(rowT + 1, colT, grid) || !isValid(rowH + 1, colH, grid))
        return
    
    const state = [dir, [rowT + 1, colT, rowH + 1, colH]]
    const stateStr = JSON.stringify(state)

    if (visited.has(stateStr)) return
    visited.add(stateStr)

    queue.push(state)
}

const rotateClockwise = (dir, pos, queue, grid, visited) => {
    if (dir === 'v') return
    
    const [rowT, colT, rowH, colH] = pos
    if (!isValid(rowT + 1, colT, grid) || !isValid(rowH + 1, colH, grid))
        return
    
    const state = ['v', [rowT, colT, rowT + 1, colT]]
    const stateStr = JSON.stringify(state)
    
    if (visited.has(stateStr)) return
    visited.add(stateStr)
    
    queue.push(state)
}

const rotateCounterClockwise = (dir, pos, queue, grid, visited) => {
    if (dir === 'h') return
    
    const [rowT, colT, rowH, colH] = pos
    if (!isValid(rowT, colT + 1, grid) || !isValid(rowH, colH + 1, grid))
        return
    
    const state = ['h', [rowT, colT, rowT, colT + 1]]
    const stateStr = JSON.stringify(state)
    
    if (visited.has(stateStr)) return
    visited.add(stateStr)
    
    queue.push(state)
}

const isValid = (row, col, grid) => {
    const n = grid.length
    return row >= 0 && col >= 0 && 
           row < n && col < n && 
           grid[row][col] === 0
}
```

## 1368. Minimum Cost to Make at Least One Valid Path in a Grid
```javascript
// Dijkstra's
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minCost = function(grid) {
    const dirs = [[0, 1, 1], [0, -1, 2], [1, 0, 3], [-1, 0, 4]]
    const m = grid.length
    const n = grid[0].length
    
    const costs = Array(m).fill().map(a => Array(n).fill(Infinity))
    costs[0][0] = 0
    
    const queue = new Heap([[0, 0, 0]], (a, b) => a[2] < b[2])
    while (queue.length()) {
        const [row, col, cost] = queue.remove()
        
        if (row === m - 1 && col === n - 1) {
            return costs[row][col]
        }
        
        const dir = grid[row][col]
        for (const [dRow, dCol, nextDir] of dirs) {
            const nextRow = dRow + row
            const nextCol = dCol + col
            
            if (nextRow < 0 || nextCol < 0 || nextRow >= m || nextCol >= n)
                continue
            
            const nextCost = costs[row][col] + (dir !== nextDir)
            if (costs[nextRow][nextCol] <= nextCost) continue
            costs[nextRow][nextCol] = nextCost
            
            queue.insert([nextRow, nextCol, nextCost])
        }
    }
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}

// 0-1 BFS: Dial's Algorithm
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minCost = function(grid) {
    const dirs = [[0, 1, 1], [0, -1, 2], [1, 0, 3], [-1, 0, 4]]
    const m = grid.length
    const n = grid[0].length
    
    const costs = Array(m).fill().map(a => Array(n).fill(Infinity))
    costs[0][0] = 0
    
    const queue = [[0, 0, 0]]
    while (queue.length) {
        const [row, col, cost] = queue.shift()
    
        if (row === m - 1 && col === n - 1) {
            return costs[row][col]
        }
        
        const dir = grid[row][col]
        for (const [dRow, dCol, nextDir] of dirs) {
            const nextRow = dRow + row
            const nextCol = dCol + col
            
            if (nextRow < 0 || nextCol < 0 || nextRow >= m || nextCol >= n)
                continue
            
            const nextCost = costs[row][col] + (dir !== nextDir)
            if (costs[nextRow][nextCol] <= nextCost) continue
            costs[nextRow][nextCol] = nextCost
            
            if (cost === nextCost) {
                queue.unshift([nextRow, nextCol, nextCost])
            } else {
                queue.push([nextRow, nextCol, nextCost])
            }
        }
    }
};
```

## 1263. Minimum Moves to Move a Box to Their Target Location
```javascript
// 0-1 BFS: Dial's Algorithm
/**
 * @param {character[][]} grid
 * @return {number}
 */
var minPushBox = function(grid) {
    const m = grid.length
    const n = grid[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    let startPerson = []
    let startBox = []
    let target = []
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === 'S') {
                startPerson = [row, col]
            } else if (grid[row][col] === 'B') {
                startBox = [row, col]
            } else if (grid[row][col] === 'T') {
                target = [row, col]
            }
        }
    }
    
    const dists = {}
    dists[`${startPerson[0]}-${startPerson[1]}-${startBox[0]}-${startBox[1]}`] = 0
    
    const queue = [[startPerson, startBox, 0]]
    while (queue.length) {
        const [person, box, steps] = queue.shift()
        
        if (box[0] === target[0] && box[1] === target[1]) {
            return steps
        }
        
        for (const [dRow, dCol] of dirs) {
            const nextPersonRow = person[0] + dRow
            const nextPersonCol = person[1] + dCol
            
            let nextBoxRow = box[0]
            let nextBoxCol = box[1]
            
            let nextSteps = steps
            
            if (!isValid(nextPersonRow, nextPersonCol, grid))
                continue
            
                        
            if (nextPersonRow === box[0] && nextPersonCol === box[1]) {
                nextBoxRow += dRow
                nextBoxCol += dCol
                
                if (!isValid(nextBoxRow, nextBoxCol, grid))
                    continue
                
                nextSteps++
            }
            
            const key = `${nextPersonRow}-${nextPersonCol}-${nextBoxRow}-${nextBoxCol}`
            if (dists[key] !== undefined && dists[key] <= nextSteps) continue
            dists[key] = nextSteps
            
            const state = [[nextPersonRow, nextPersonCol], [nextBoxRow, nextBoxCol], nextSteps]
            if (nextSteps > steps) {
                queue.push(state)
            } else {
                queue.unshift(state)
            }            
        }
    }
    
    return -1
};

const isValid = (row, col, grid) => {
    return row >= 0 && row < grid.length && 
        col >= 0 && col < grid[0].length && 
        grid[row][col] !== '#'
}

// Biconnected Components

```

## 864. Shortest Path to Get All Keys
```javascript
/**
 * @param {string[]} grid
 * @return {number}
 */
var shortestPathAllKeys = function(grid) {
    const m = grid.length
    const n = grid[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const visited = new Set()
    const queue = []
    
    let keyCount = 0
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === '@') {
                visited.add(`${row}-${col}-0`)
                queue.push([row, col, 0, 0])
            } else if (grid[row][col] >= 'a' && grid[row][col] <= 'f') {
                keyCount++
            }
        }
    }
    
    let target = 0
    for (let i = 0; i < keyCount; i++) {
        target |= 1 << i
    }
    
    while (queue.length) {
        const [row, col, keys, steps] = queue.shift()
        if (keys === target) return steps
        
        for (const [dRow, dCol] of dirs) {
            const nextRow = dRow + row
            const nextCol = dCol + col
            let nextKeys = keys
            
            if (nextRow < 0 || nextRow >= m || 
                nextCol < 0 || nextCol >= n ||
                grid[nextRow][nextCol] === '#') continue
            
            const nextChar = grid[nextRow][nextCol]
            
            if (nextChar >= 'A' && nextChar <= 'F' && !(keys & 1 << index(nextChar)))
                continue
            
            if (nextChar >= 'a' && nextChar <= 'f')
                nextKeys = keys | 1 << index(nextChar)
            
            const state = `${nextRow}-${nextCol}-${nextKeys}`
            if (visited.has(state)) continue
            visited.add(state)
            
            queue.push([nextRow, nextCol, nextKeys, steps + 1])
        }
    }
    
    return -1
};

const index = char => char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)
```

## 42. Trapping Rain Water
```javascript
// Brute Force
// Time: O(n^2)
// Space: O(1)
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let totalWater = 0
    
    for (let i = 1; i < height.length - 1; i++) { 
        let leftMax = 0
        for (let j = 0; j <= i; j++) {
            leftMax = Math.max(leftMax, height[j])
        }
        
        let rightMax = 0
        for (let j = height.length - 1; j >= i; j--) {
            rightMax = Math.max(rightMax, height[j])
        }
        
        totalWater += Math.min(leftMax, rightMax) - height[i]
    }
    
    return totalWater
};

// DP
// Time: O(n)
// Space: O(n)
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let totalWater = 0
    const leftMax = Array(height.length).fill(0)
    const rightMax = Array(height.length).fill(0)
    
    for (let i = 0; i < height.length; i++) {
        if (i === 0) {
            leftMax[i] = height[i]
        } else {
            leftMax[i] = Math.max(leftMax[i - 1], height[i])
        }
    }
    
    for (let i = height.length - 1; i >= 0; i--) {
        if (i === height.length - 1) {
            rightMax[i] = height[i]
        } else {
            rightMax[i] = Math.max(rightMax[i + 1], height[i])
        }
    }
    
    for (let i = 1; i < height.length - 1; i++) { 
        totalWater += Math.min(leftMax[i], rightMax[i]) - height[i]
    }
    
    return totalWater
};

// Two Pointer
// Time: O(n)
// Space: O(1)
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let totalWater = 0
    
    let left = 0
    let right = height.length - 1
    
    let leftMax = 0
    let rightMax = 0
    
    while (left < right) {
        leftMax = Math.max(leftMax, height[left])
        rightMax = Math.max(rightMax, height[right])
        
        if (leftMax < rightMax) {
            totalWater += leftMax - height[left]
            left++
        } else {
            totalWater += rightMax - height[right]
            right--
        }
    }
    
    return totalWater
};

// Monotonic Stack
// Time: O(n)
// Space: O(n)
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let totalWater = 0
    let stack = []
    for (let i = 0; i < height.length; i++) {
        while (stack.length && height[stack[stack.length - 1]] < height[i]) {
            const top = stack.pop()
            
            if (!stack.length) break
            
            const distance = i - stack[stack.length - 1] - 1
            const boundedHeight = Math.min(height[i], height[stack[stack.length - 1]]) - height[top]
            totalWater += distance * boundedHeight
        }
        
        stack.push(i)
    }
    
    return totalWater
};
```

## 407. Trapping Rain Water II
```javascript
/**
 * @param {number[][]} heightMap
 * @return {number}
 */
var trapRainWater = function(heightMap) {
    const m = heightMap.length
    const n = heightMap[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const heap = new Heap([], (a, b) => {
        const [aRow, aCol] = a
        const [bRow, bCol] = b
        return heightMap[aRow][aCol] < heightMap[bRow][bCol]
    })
    
    const visited = Array(m).fill().map(a => Array(n).fill(false))
    let totalWater = 0
    let max = 0
    
    for (let row = 0; row < m; row++) {
        visited[row][0] = true
        visited[row][n - 1] = true
        
        heap.insert([row, 0])
        heap.insert([row, n - 1])
    }
    
    for (let col = 0; col < n; col++) {
        visited[0][col] = true
        visited[m - 1][col] = true
        
        heap.insert([0, col])
        heap.insert([m - 1, col])
    }
    
    while (heap.length()) {
        const [row, col] = heap.remove()
        max = Math.max(max, heightMap[row][col])
        
        for (const [dRow, dCol] of dirs) {
            const nRow = dRow + row
            const nCol = dCol + col
            
            if (nRow < 0 || nCol < 0 || nRow >= m || nCol >= n || 
                visited[nRow][nCol]) continue
            
            visited[nRow][nCol] = true
            totalWater += Math.max(0, max - heightMap[nRow][nCol])
            heap.insert([nRow, nCol])
        }
    }
    
    return totalWater
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 499. The Maze III
```javascript
// Dijkstra
/**
 * @param {number[][]} maze
 * @param {number[]} ball
 * @param {number[]} hole
 * @return {string}
 */
var findShortestWay = function(maze, ball, hole) {
    const m = maze.length
    const n = maze[0].length
    const dirs = [[1, 0, 'd'], [0, -1, 'l'], [0, 1, 'r'], [-1, 0, 'u']]
    
    const visited = Array(m).fill().map(a => Array(n).fill(false))
    
    const start = [...ball, '', 0]
    const queue = new Heap([start], (a, b) => {
        const [, , aPath, aDist] = a
        const [, , bPath, bDist] = b
        if (aDist === bDist) {
            return aPath < bPath
        }
        
        return aDist < bDist
    })
    
    while (queue.length()) {
        const [row, col, path, dist] = queue.remove()
        
        if (row === hole[0] && col === hole[1]) {
            return path
        }
        
        visited[row][col] = true
        
        for (const [dRow, dCol, dir] of dirs) {
            let nextRow = row
            let nextCol = col
            let nextDist = 0
            while (nextRow >= 0 && nextRow < maze.length && 
                   nextCol >= 0 && nextCol < maze[0].length && 
                   maze[nextRow][nextCol] !== 1) {
                nextRow += dRow
                nextCol += dCol
                nextDist++
                
                if (nextRow === hole[0] && nextCol === hole[1]) {
                    break
                }
            }
            
            if (nextRow !== hole[0] || nextCol !== hole[1]) {
                nextRow -= dRow
                nextCol -= dCol
                nextDist--
            }
            
            if (visited[nextRow][nextCol]) continue            
            queue.insert([nextRow, nextCol, path + dir, dist + nextDist])
        }
    }
    
    return 'impossible'
};

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}

// A*
/**
 * @param {number[][]} maze
 * @param {number[]} ball
 * @param {number[]} hole
 * @return {string}
 */
var findShortestWay = function(maze, ball, hole) {
    const m = maze.length
    const n = maze[0].length
    const dirs = [[1, 0, 'd'], [0, -1, 'l'], [0, 1, 'r'], [-1, 0, 'u']]
    
    const visited = Array(m).fill().map(a => Array(n).fill(false))
    
    const start = [...ball, '', 0]
    const queue = new Heap([start], (a, b) => {
        const [, , aPath, aDist, aH] = a
        const [, , bPath, bDist, bH] = b
        
        const aF = aDist + aH
        const bF = bDist + bH
        if (aF === bF) {
            return aPath < bPath
        }
        
        return aF < bF
    })
    
    while (queue.length()) {
        const [row, col, path, dist] = queue.remove()
        
        if (row === hole[0] && col === hole[1]) {
            return path
        }
        
        visited[row][col] = true
        
        for (const [dRow, dCol, dir] of dirs) {
            let nextRow = row
            let nextCol = col
            let nextDist = 0
            while (nextRow >= 0 && nextRow < maze.length && 
                   nextCol >= 0 && nextCol < maze[0].length && 
                   maze[nextRow][nextCol] !== 1) {
                nextRow += dRow
                nextCol += dCol
                nextDist++
                
                if (nextRow === hole[0] && nextCol === hole[1]) {
                    break
                }
            }
            
            if (nextRow !== hole[0] || nextCol !== hole[1]) {
                nextRow -= dRow
                nextCol -= dCol
                nextDist--
            }
            
            if (visited[nextRow][nextCol]) continue            
            queue.insert([nextRow, nextCol, 
                          path + dir, 
                          dist + nextDist, 
                          h(nextRow, nextCol, hole[0], hole[1])])
        }
    }
    
    return 'impossible'
};

const h = (x1, y1, x2, y2) => {
    return Math.abs(x1 - x2) + Math.abs(y1 - y2)
}

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 1519. Number of Nodes in the Sub-Tree With the Same Label
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {string} labels
 * @return {number[]}
 */
var countSubTrees = function(n, edges, labels) {
    const graph = buildGraph(n, edges)
    const result = Array(n).fill(0)
    dfs(graph, result, labels)
    return result
};

const dfs = (tree, result, labels) => {
    const _dfs = (node, parent) => {
        const labelCounts = Array(26).fill(0)
        for (const neighbor of tree[node]) {
            if (neighbor === parent) continue
            const nextLabelCounts = _dfs(neighbor, node)
            for (let i = 0; i < 26; i++) {
                labelCounts[i] += nextLabelCounts[i]
            }
        }
        
        const index = labels[node].charCodeAt(0) - 'a'.charCodeAt(0)
        labelCounts[index]++
        result[node] += labelCounts[index]
        return labelCounts
    }
    
    _dfs(0, null)
}

const buildGraph = (n, edges) => {
    const graph = Array(n).fill().map(a => [])
    
    for (const [u, v] of edges) {
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}
```

## 1391. Check if There is a Valid Path in a Grid
```javascript
/**
 * @param {number[][]} grid
 * @return {boolean}
 */
var hasValidPath = function(grid) {
    const m = grid.length
    const n = grid[0].length
    
    const visited = Array(m).fill().map(a => Array(n).fill(false))
    visited[0][0] = true
    
    const queue = [[0, 0]]
    while (queue.length) {
        const [row, col] = queue.shift()
        
        if (row === m - 1 && col === n - 1) {
            return true
        }
        
        visited[row][col] = true
        
        const streetType = grid[row][col]
        for (const [dRow, dCol, dir] of outgoing[streetType]) {
            const nextRow = dRow + row
            const nextCol = dCol + col
            
            if (nextRow < 0 || nextRow >= m || 
                nextCol < 0 || nextCol >= n || 
                visited[nextRow][nextCol]) continue
            
            const nextStreetType = grid[nextRow][nextCol]
            if (!incoming[nextStreetType].includes(dir)) continue            
            queue.push([nextRow, nextCol])
        }
    }
    
    return false
};

const outgoing = {
    1: [[0, -1, 'l'], [0, 1, 'r']],
    2: [[-1, 0, 'u'], [1, 0, 'd']],
    3: [[0, -1, 'l'], [1, 0, 'd']],
    4: [[0, 1, 'r'], [1, 0, 'd']],
    5: [[0, -1, 'l'], [-1, 0, 'u']],
    6: [[0, 1, 'r'], [-1, 0, 'u']]
}

const incoming = {
    1: 'rl',
    2: 'ud',
    3: 'ru',
    4: 'lu',
    5: 'rd',
    6: 'ld'
}
```

## 1625. Lexicographically Smallest String After Applying Operations
```javascript
/**
 * @param {string} s
 * @param {number} a
 * @param {number} b
 * @return {string}
 */
var findLexSmallestString = function(s, a, b) {
    let min = s
    
    const visited = new Set([s])
    const queue = [s]
    while (queue.length) {
        const str = queue.shift()
        if (min > str) min = str
        
        const addArr = str.split('')
        for (let i = 1; i < addArr.length; i += 2) {
            addArr[i] = (+addArr[i] + a) % 10
        }
        
        const addStr = addArr.join('')
        if (!visited.has(addStr)) {
            visited.add(addStr)
            queue.push(addStr)
        }
        
        const rotateArr = str.split('')
        rotate(rotateArr, b)
        
        const rotateStr = rotateArr.join('')
        if (!visited.has(rotateStr)) {
            visited.add(rotateStr)
            queue.push(rotateStr)
        }   
    }
    
    return min
};

const rotate = (arr, k) => {
    reverse(arr, 0, arr.length - 1)
    reverse(arr, 0, k - 1)
    reverse(arr, k, arr.length - 1)
}

const reverse = (arr, i, j) => {
    while (i < j) {
        const temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
        
        i++
        j--
    }
}
```

## 1629. Slowest Key
```javascript
/**
 * @param {number[]} releaseTimes
 * @param {string} keysPressed
 * @return {character}
 */
var slowestKey = function(releaseTimes, keysPressed) {
    let maxDur = releaseTimes[0]
    let charIndex = 0
    for (let i = 0; i < releaseTimes.length; i++) {
        const dur = releaseTimes[i] - releaseTimes[i - 1]
        if (maxDur < dur || maxDur === dur && keysPressed[charIndex] < keysPressed[i]) {
            maxDur = dur
            charIndex = i
        }
    }
    
    return keysPressed[charIndex]
};
```

## 1633. Percentage of Users Attended a Contest
```sql
# Write your MySQL query statement below
SELECT contest_id, 
       ROUND(COUNT(user_id) / (SELECT COUNT(*) FROM Users) * 100, 2) AS percentage
FROM Register
GROUP BY contest_id
ORDER BY percentage DESC, contest_id ASC
```

## 1631. Path With Minimum Effort
```javascript
/**
 * @param {number[][]} heights
 * @return {number}
 */
var minimumEffortPath = function(heights) {
    const m = heights.length
    const n = heights[0].length
    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    const visited = Array(m).fill().map(a => Array(n).fill(false))
    const pq = new Heap([[0, 0, 0]], (a, b) => a[2] < b[2])
    while (pq.length()) {
        const [row, col, effort] = pq.remove()
        
        if (row === m - 1 && col === n - 1) {
            return effort
        }
        
        visited[row][col] = true
        
        for (const [dRow, dCol] of dirs) {
            const nextRow = dRow + row
            const nextCol = dCol + col
            
            if (nextRow < 0 || nextRow >= m || 
                nextCol < 0 || nextCol >= n ||
                visited[nextRow][nextCol]) continue
            
            const nextEffort = Math.abs(heights[row][col] - heights[nextRow][nextCol])
            const maxEffort = Math.max(effort, nextEffort)
            pq.insert([nextRow, nextCol, maxEffort])
        }
    }
};

class Heap {
    constructor(elements, sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 464. Can I Win
```javascript
// Minimax + Top-Down DP
/**
 * @param {number} maxChoosableInteger
 * @param {number} desiredTotal
 * @return {boolean}
 */
var canIWin = function(maxChoosableInteger, desiredTotal) {
    const _canIWin = (sum, used) => {
        if (sum >= desiredTotal) {
            return false
        }
        
        if (dp[used] !== undefined) {
            return dp[used]
        }
        
        for (let num = 1; num <= maxChoosableInteger; num++) {
            const mask = 1 << num
            if (used & mask) continue
            
            if (!_canIWin(sum + num, used | mask)) {
                dp[used] = true
                return true
            }
        }
        
        dp[used] = false
        return false
    }
    
    const sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2
    if (sum < desiredTotal) return false
    if (desiredTotal <= 0) return true
    
    const dp = []
    return _canIWin(0, 0)
};


```

## 375. Guess Number Higher or Lower II
```javascript
// Top Down DP
/**
 * @param {number} n
 * @return {number}
 */
var getMoneyAmount = function(n) {
    const _getMoneyAmount = (left, right) => {
        if (left >= right) return 0
        
        if (dp[left][right] !== undefined)
            return dp[left][right]
        
        let temp = Infinity
        for (let k = left; k <= right; k++) {
            const result = k + Math.max(_getMoneyAmount(left, k - 1), 
                                        _getMoneyAmount(k + 1, right))
            temp = Math.min(result, temp)
        }
        
        dp[left][right] = temp
        return temp
    }
    
    const dp = Array(n + 1).fill().map(a => Array(n + 1).fill())
    return _getMoneyAmount(1, n)
};

// Bottom Up DP
/**
 * @param {number} n
 * @return {number}
 */
var getMoneyAmount = function(n) {
    const dp = Array(n + 1).fill().map(a => Array(n + 1).fill(0))
    
    for (let len = 2; len <= n; len++) {
        for (let start = 1; start <= n - len + 1; start++) {
            const end = start + len - 1
            
            let temp = Infinity
            for (let k = start; k <= end; k++) {
                const op1 = k - 1 >= 0 ? dp[start][k - 1] : 0
                const op2 = k + 1 <= n ? dp[k + 1][end] : 0
                
                const result = Math.max(op1, op2) + k
                temp = Math.min(temp, result)   
            }
            
            dp[start][end] = temp
        }
    }
    
    return dp[1][n]
};
```

## 877. Stone Game
```javascript
// Minimax
/**
 * @param {number[]} piles
 * @return {boolean}
 */
var stoneGame = function(piles) {
    const _stoneGame = (left, right, maximizingPlayer) => {
        if (left > right) return 0
        
        if (dp[left][right][maximizingPlayer] !== undefined) {
            return dp[left][right][maximizingPlayer]
        }
        
        if (maximizingPlayer) {
            const op1 = _stoneGame(left + 1, right, 0) + piles[left]
            const op2 = _stoneGame(left, right - 1, 0) + piles[right]
            dp[left][right][maximizingPlayer] = Math.max(op1, op2)
        } else {
            const op1 = _stoneGame(left + 1, right, 1) - piles[left]
            const op2 = _stoneGame(left, right - 1, 1) - piles[right]
            dp[left][right][maximizingPlayer] = Math.min(op1, op2)
        }
        
        return dp[left][right][maximizingPlayer]
    }
    
    const dp = Array(piles.length).fill()
                .map(a => Array(piles.length).fill()
                .map(a => Array(2)))
    
    return _stoneGame(0, piles.length - 1, 1)
};

// Negamax
/**
 * @param {number[]} piles
 * @return {boolean}
 */
var stoneGame = function(piles) {
    const _stoneGame = (left, right) => {
        if (left > right) return 0
        
        if (dp[left][right] !== undefined) {
            return dp[left][right]
        }
        
        dp[left][right] = Math.min(piles[left] - _stoneGame(left + 1, right, 1), 
                                   piles[right] - _stoneGame(left, right - 1, 1))
        return dp[left][right]
    }
    
    const n = piles.length
    const dp = Array(n).fill().map(a => Array(n))
    return _stoneGame(0, n - 1)
};
```

## 486. Predict the Winner
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var PredictTheWinner = function(nums) {
    const _predictTheWinner = (left, right) => {
        if (left > right) return 0
        if (memo[left][right]) return memo[left][right]
        
        memo[left][right] = Math.max(nums[left] - _predictTheWinner(left + 1, right),
                                     nums[right] - _predictTheWinner(left, right - 1))
        return memo[left][right]
    }
    
    const memo = new Array(nums.length).fill().map(a => new Array(nums.length))
    return _predictTheWinner(0, nums.length - 1, true) >= 0
};
```

## 1630. Arithmetic Subarrays
```javascript
/**
 * @param {number[]} nums
 * @param {number[]} l
 * @param {number[]} r
 * @return {boolean[]}
 */
var checkArithmeticSubarrays = function(nums, l, r) {
    const result = []
    for (let i = 0; i < l.length; i++) {
        result.push(isArithmetic(nums, l[i], r[i]))
    }
    return result
};

const isArithmetic = (num, start, end) => {
    const length = end - start + 1
    let max = -Infinity
    let min = Infinity
    const set = new Set()
    
    for (let i = start; i <= end; i++) {
        max = Math.max(max, num[i])
        min = Math.min(min, num[i])
        set.add(num[i])
    }
    
    const d = (max - min) / (length - 1)
    for (let i = 1; i <= length; i++) {
        const num = min + (i - 1) * d
        if (!set.has(num)) return false
    }
    
    return true
}
```

## 1561. Maximum Number of Coins You Can Get
```javascript
/**
 * @param {number[]} piles
 * @return {number}
 */
var maxCoins = function(piles) {
    const buckets = Array(10001).fill(0)
    for (const num of piles) {
        buckets[num]++
    }
    
    const sorted = []
    for (let i = 0; i < buckets.length; i++) {
        while (buckets[i]--) {
            sorted.push(i)
        }
    }
    
    let maxSum = 0
    let minIndex = 0
    for (let i = sorted.length - 2; i > minIndex; i -= 2) {
        maxSum += sorted[i]
        minIndex++
    }
    
    return maxSum
};
```

## 1288. Remove Covered Intervals
```javascript
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var removeCoveredIntervals = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1])
    
    let removed = 0
    let maxEnd = 0
    
    for (let i = 0; i < intervals.length; i++) {
        const [start, end] = intervals[i]
        
        if (end <= maxEnd) {
            removed++
        }
        
        maxEnd = Math.max(end, maxEnd)
    }
    
    return intervals.length - removed
};
```

## 1481. Least Number of Unique Integers after K Removals
```javascript
// O(n + m log m) where m = # of unique keys
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var findLeastNumOfUniqueInts = function(arr, k) {
    const map = {}
    for (const num of arr) {
        map[num] = 1 + (map[num] || 0)
    }
    
    const sorted = Object.entries(map)
    sorted.sort((a, b) => a[1] - b[1])
    
    let result = sorted.length
    for (let i = 0; i < sorted.length; i++) {
        if (k >= sorted[i][1]) {
            k -= sorted[i][1]
            result--
            continue
        }
        
        break
    }
    
    return result
};

// O(n)
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var findLeastNumOfUniqueInts = function(arr, k) {
    const map = {}
    for (const num of arr) {
        map[num] = 1 + (map[num] || 0)
    }
    
    const buckets = Array(arr.length + 1).fill().map(a => [])
    for (const [key, val] of Object.entries(map)) {
        buckets[val].push(key) 
    }
    
    let count = Object.entries(map).length
    for (let freq = 0; freq < buckets.length; freq++) {
        for (const num of buckets[freq]) {
            if (k >= freq) {
                k -= freq
                count--
                continue
            }
            
            break
        }
    }
    
    return count
};
```

## 315. Count of Smaller Numbers After Self
```javascript
// Fenwick Tree
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
    if (!nums.length) return []
    
    const result = Array(nums.length).fill()
    let j = result.length - 1
    
    const fenwickTree = new FenwickTree(20_001)
    const offset = 10_000
    for (let i = nums.length - 1; i >= 0; i--) {
        result[j--] = fenwickTree.query(nums[i] + offset - 1)
        fenwickTree.update(nums[i] + offset, 1)
    }
    
    return result
};

class FenwickTree {
    constructor(n) {
        this.tree = Array(n + 1).fill(0)
    }
    
    update(i, delta) {
        i++
        while (i < this.tree.length) {
            this.tree[i] += delta
            i += this.lsb(i)
        }
    }

    query(i) {
        let sum = 0
        
        i++
        while (i > 0) {
            sum += this.tree[i]
            i -= this.lsb(i)
        }
        return sum
    }
    
    lsb(i) {
        return i & -i
    }
}
```

## 493. Reverse Pairs
```javascript
// Fenwick Tree
/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
    if (!nums.length) return []
    
    const set = new Set()
    for (const num of nums) {
        set.add(num)
        set.add(num * 2)
    }
    
    const sortedSet = Array.from(set).sort((a, b) => a - b)
    const fenwickTree = new FenwickTree(sortedSet.length)
    
    const ranks = {}
    for (let i = 0; i < sortedSet.length; i++) {
        ranks[sortedSet[i]] = i + 1
    }
    
    let count = 0
    for (let i = nums.length - 1; i >= 0; i--) {
        count += fenwickTree.query(ranks[nums[i]] - 1)
        fenwickTree.update(ranks[nums[i] * 2], 1)
    }
    
    return count
};

class FenwickTree {
    constructor(n) {
        this.tree = Array(n + 1).fill(0)
    }
    
    update(i, delta) {
        while (i < this.tree.length) {
            this.tree[i] += delta
            i += this.lsb(i)
        }
    }
    
    query(i) {
        let sum = 0
        
        while (i > 0) {
            sum += this.tree[i]
            i -= this.lsb(i)
        }
        return sum
    }
    
    lsb(i) {
        return i & -i
    }
}
```

## 308. Range Sum Query 2D - Mutable
```javascript
/**
 * @param {number[][]} matrix
 */
var NumMatrix = function(matrix) {
    if (!matrix.length || !matrix[0].length) 
        return
    
    this.m = matrix.length
    this.n = matrix[0].length
    
    this.nums = Array(this.m).fill().map(a => Array(this.n).fill(0))
    this.tree = Array(this.m + 1).fill().map(a => Array(this.n + 1).fill(0))
    
    for (let row = 0; row < this.m; row++) {
        for (let col = 0; col < this.n; col++) {
            this.update(row, col, matrix[row][col])
        }
    }
};

/** 
 * @param {number} row 
 * @param {number} col 
 * @param {number} val
 * @return {void}
 */
NumMatrix.prototype.update = function(row, col, val) {
    const delta = val - this.nums[row][col]
    this.nums[row][col] = val
    
    row++
    col++
    while (row < this.tree.length) {
        let currCol = col
        while (currCol < this.tree[0].length) {
            this.tree[row][currCol] += delta
            currCol += this.lsb(currCol)
        }
        row += this.lsb(row)
    }
};

/** 
 * @param {number} row1 
 * @param {number} col1 
 * @param {number} row2 
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
  return this.sum(row2, col2) - 
         this.sum(row1 - 1, col2) - 
         this.sum(row2, col1 - 1) + 
         this.sum(row1 - 1, col1 - 1)
};

NumMatrix.prototype.sum = function(row, col) {
  let sum = 0
  
  row++
  col++
  while (row > 0) {
      let currCol = col
      while (currCol > 0) {
          sum += this.tree[row][currCol]
          currCol -= this.lsb(currCol)
      }
      row -= this.lsb(row)
  }

  return sum
}

/** 
 * Your NumMatrix object will be instantiated and called as such:
 * var obj = new NumMatrix(matrix)
 * obj.update(row,col,val)
 * var param_2 = obj.sumRegion(row1,col1,row2,col2)
 */

NumMatrix.prototype.lsb = function(i) {
    return i & (-i)
}
```

## 1641. Count Sorted Vowel Strings
```javascript
// Top Down DP
/**
 * @param {number} n
 * @return {number}
 */
var countVowelStrings = function(n) {
    const _countVowelStrings = (n, i) => {
        if (n === 0) return 1
        
        if (memo[n][i] !== undefined)
            return memo[n][i]
        
        let count = 0
        for (let curr = i; curr < 5; curr++) {
            count += _countVowelStrings(n - 1, curr)
        }
        
        memo[n][i] = count
        return count
    }
    
    const memo = Array(n + 1).fill().map(a => Array(5))
    return _countVowelStrings(n, 0)
};

// Bottom Up DP
/**
 * @param {number} n
 * @return {number}
 */
var countVowelStrings = function(n) {
    const dp = Array(n + 1).fill().map(a => Array(6).fill())
    
    for (let i = 0; i < 6; i++) {
        dp[1][i] = i
    }
    
    for (let i = 2; i < dp.length; i++) {
        dp[i][1] = 1
        for (let j = 2; j < dp[0].length; j++) {
            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
        }
    }
    
    return dp[n][5]
};
```

## 1415. The k-th Lexicographical String of All Happy Strings of Length n
```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getHappyString = function(n, k) {
    const _getHappyString = curr => {
        if (count >= k) return
        
        if (curr.length === n) {
            result = curr.join('')
            count++
            return
        }
        
        for (const char of 'abc') {
            if (curr.length && char === curr[curr.length - 1]) continue
            curr.push(char)
            _getHappyString(curr)
            curr.pop()
        }
    }
    
    let result = ''
    let count = 0
    _getHappyString([])
    return count >= k ? result : ''
};

// DP
/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getHappyString = function(n, k) {
    let result = ['a', 'b', 'c']
    
    for (let i = 2; i <= n; i++) {
        const nextResult = []
        for (let j = 0; j < result.length && nextResult.length < k; j++) {
            const str = result[j]
            
            for (const char of 'abc') {
                if (str[str.length - 1] === char) continue
                nextResult.push(str + char)
            }
        }
        result = nextResult
    }
    
    return result.length >= k ? result[k - 1] : ''
}
```

## 1066. Campus Bikes II
```javascript
// Top Down DP
/**
 * @param {number[][]} workers
 * @param {number[][]} bikes
 * @return {number}
 */
var assignBikes = function(workers, bikes) {
    const _assignBikes = (workerIndex, bikesUsed) => {
        if (workerIndex >= workers.length) {
            return 0
        }
        
        if (memo[`${workerIndex}-${bikesUsed}`] !== undefined) {
            return memo[`${workerIndex}-${bikesUsed}`]
        }
        
        let min = Infinity
        for (let i = 0; i < bikes.length; i++) {
            const mask = 1 << i
            if (bikesUsed & mask) continue
            
            const currDist = manhattan(workers[workerIndex], bikes[i]) + 
                             _assignBikes(workerIndex + 1, bikesUsed | mask)
            min = Math.min(min, currDist)
        }
        
        memo[`${workerIndex}-${bikesUsed}`] = min
        return min
    }
    
    const memo = {}
    return _assignBikes(0, 0)
};

const manhattan = (p1, p2) => {
    return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1])
}
```

## 351. Android Unlock Patterns
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var numberOfPatterns = function(m, n) {
    const _numberOfPatterns = (curr, used, length) => {
        if (length >= m) {
            count++
        }
        
        if (length === n) {
            return
        }
        
        for (let num = 1; num <= 9; num++) {
            const mask = 1 << num
            if (used & mask) continue
            
            const key = `${Math.min(curr, num)}-${Math.max(curr, num)}`
            if (skip[key] && !(used & 1 << skip[key])) continue
            
            _numberOfPatterns(num, used | mask, length + 1)
        }
    }
    
    const skip = { '1-7': 4, '2-8': 5, '3-9': 6, '1-3': 2, 
                   '4-6': 5, '7-9': 8, '1-9': 5, '3-7': 5 }
    let count = 0
    _numberOfPatterns(1, 1 << 1, 1)
    _numberOfPatterns(2, 1 << 2, 1)
    count *= 4
    _numberOfPatterns(5, 1 << 5, 1)
    return count
};
```

## 89. Gray Code
```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    const result = [0]
    for (let i = 0; i < n; i++) {
        const size = result.length
        for (let j = size - 1; j >= 0; j--) {
            result.push(result[j] | 1 << i)
        }
    }
    
    return result
};
```

## 211. Design Add and Search Words Data Structure
```javascript
/**
 * Initialize your data structure here.
 */
var WordDictionary = function() {
    this.trie = new Trie()
};

/** 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
    this.trie.add(word)
};

/** 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
    return this.trie.has(word)
};

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */

class Trie {
    constructor() {
        this.root = new TrieNode()
    }
    
    add(word) {
        let curr = this.root
        for (const char of word) {
            if (curr.children[char] === undefined) {
                curr.children[char] = new TrieNode(char)
            }
            
            curr = curr.children[char]
        }
        
        curr.isEnd = true
    }
    
    has(word) {
        const _has = (startIndex, curr) => {
            for (let i = startIndex; i < word.length; i++) {
                const char = word[i]

                if (word[i] === '.') {
                    for (const [key, node] of Object.entries(curr.children)) {
                        if (_has(i + 1, node)) {
                            return true
                        }
                    }
                    return false
                }

                if (curr.children[char] === undefined) {
                    return false
                }
                
                curr = curr.children[char]
            }

            return curr.isEnd
        }
        
        return _has(0, this.root)
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 1258. Synonymous Sentences
```javascript
// Union Find + Recursion
/**
 * @param {string[][]} synonyms
 * @param {string} text
 * @return {string[]}
 */
var generateSentences = function(synonyms, text) {
    const unionFind = new UnionFind()
    for (const [word1, word2] of synonyms) {
        unionFind.add(word1)
        unionFind.add(word2)
        unionFind.union(word1, word2)
    }
    
    const synonymMap = {}
    for (const [word1, word2] of synonyms) {
        const group1 = unionFind.find(word1)
        const group2 = unionFind.find(word2)
        
        if (!synonymMap[group1]) synonymMap[group1] = new Set()
        if (!synonymMap[group2]) synonymMap[group2] = new Set()
        synonymMap[group1].add(word1)
        synonymMap[group2].add(word2)
    }
    
    for (const key of Object.keys(synonymMap)) {
        synonymMap[key] = Array.from(synonymMap[key]).sort() 
    }
    
    const words = text.split(' ')
    const result = []
    _generateSentences(words, [], synonymMap, result, 0, unionFind)
    return result
};

const _generateSentences = (words, curr, synonymMap, result, i, unionFind) => {
    if (curr.length === words.length) {
        result.push(curr.join(' '))
        return
    }
    
    const group = unionFind.find(words[i])
    if (synonymMap[group] === undefined) {
        curr.push(words[i])
        _generateSentences(words, curr, synonymMap, result, i + 1, unionFind)
        curr.pop()
    } else {
        for (const word of synonymMap[group]) {
            curr.push(word)
            _generateSentences(words, curr, synonymMap, result, i + 1, unionFind)
            curr.pop()
        }
    }
}

class UnionFind {
    constructor(n) {
        this.size = {}
        this.parent = {}
        this.ids = {}
        this.id = 0
    }
    
    add(a) {
        if (this.ids[a] !== undefined) return
        
        this.ids[a] = this.id
        this.parent[this.id] = this.id 
        this.size[this.id] = 1
        this.id++
    }
    
    find(a) {
        let id = this.ids[a]
        if (id === undefined) return -1
        
        let root = this.parent[id]
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (id !== root) {
            const next = this.parent[id]
            this.parent[id] = root
            id = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) return
        
        if (this.size[parentA] < this.size[parentB]) {
            this.size[parentB] += this.size[parentA]
            this.parent[parentA] = parentB
        } else {
            this.size[parentA] += this.size[parentB]
            this.parent[parentB] = parentA
        }
    }
}

// BFS + Recursion
/**
 * @param {string[][]} synonyms
 * @param {string} text
 * @return {string[]}
 */
var generateSentences = function(synonyms, text) {
    const _generateSentences = (curr, index) => {
        if (index === words.length) {
            result.push(curr.join(' '))
            return
        }
        
        if (graph[(words[index])]) {
            const queue = [words[index]]
            const visited = new Set()

            while (queue.length) {
                const next = queue.shift()
                visited.add(next)

                curr.push(next)
                _generateSentences(curr, index + 1)
                curr.pop()

                for (let vertex of graph[next]) {
                    if (!visited.has(vertex))
                        queue.push(vertex)
                }
            }
        } else {
            curr.push(words[index])
            _generateSentences(curr, index + 1)
            curr.pop()
        }
    }
    
    const graph = {}
    for (const [start, end] of synonyms) {
        graph[start] ? graph[start].push(end) : graph[start] = [end]
        graph[end] ? graph[end].push(start) : graph[end] = [start]
    }
    
    const words = text.split(' ')
    const result = []
    _generateSentences([], 0)
    result.sort()
    return result
};
```

## 1286. Iterator for Combination
```javascript
// Precompute Bitmasks
/**
 * @param {string} characters
 * @param {number} combinationLength
 */
var CombinationIterator = function(characters, combinationLength) {
    const n = characters.length
    const k = combinationLength
    
    this.stack = []
    for (let i = 0; i < 1 << n; i++) {
        if (bitCount(i) !== k) continue
        this.stack.push(comboFromBin(i, n, characters))
    }
};

/**
 * @return {string}
 */
CombinationIterator.prototype.next = function() {
    return this.stack.pop()
};

/**
 * @return {boolean}
 */
CombinationIterator.prototype.hasNext = function() {
    return this.stack.length !== 0
};

/** 
 * Your CombinationIterator object will be instantiated and called as such:
 * var obj = new CombinationIterator(characters, combinationLength)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */

const bitCount = bin => {
    let count = 0
    while (bin) {
        count++
        bin &= bin - 1
    }
    return count
}

const comboFromBin = (bin, n, arr) => {
    const curr = []
    for (let i = 0; i < n; i++) {
        if (bin & 1 << n - 1 - i) {
            curr.push(arr[i])
        }
    }
    return curr.join('')   
}

// Get Next Bitmasks
/**
 * @param {string} characters
 * @param {number} combinationLength
 */
var CombinationIterator = function(characters, combinationLength) {
    this.n = characters.length
    this.k = combinationLength
    this.characters = characters
    this.bitMask = (1 << this.n) - 1
    this.setNextBitMask()
};

/**
 * @return {string}
 */
CombinationIterator.prototype.next = function() {
    const result = comboFromBin(this.bitMask--, this.n, this.characters)
    this.setNextBitMask()
    return result
};

/**
 * @return {boolean}
 */
CombinationIterator.prototype.hasNext = function() {
    return this.bitMask > 0
};

CombinationIterator.prototype.setNextBitMask = function() {
    while (this.bitMask > 0 && bitCount(this.bitMask) !== this.k) {
        this.bitMask--
    }
};

/** 
 * Your CombinationIterator object will be instantiated and called as such:
 * var obj = new CombinationIterator(characters, combinationLength)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */

const bitCount = bin => {
    let count = 0
    while (bin) {
        count++
        bin &= bin - 1
    }
    return count
}

const comboFromBin = (bin, n, arr) => {
    const curr = []
    for (let i = 0; i < n; i++) {
        if (bin & 1 << n - 1 - i) {
            curr.push(arr[i])
        }
    }
    return curr.join('')   
}
```

## 980. Unique Paths III
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var uniquePathsIII = function(grid) {
    const _uniquePathsIII = (row, col, squareCount, visited) => {
        if (grid[row][col] === 2) return 1
        
        const state = `${getIndex(grid, row, col)}-${visited}`
        if (memo[state] !== undefined) return memo[state]
        memo[state] = 0
        
        for (const [dRow, dCol] of dirs) {
            const nextRow = row + dRow
            const nextCol = col + dCol
            const index = getIndex(grid, nextRow, nextCol)
            const mask = 1 << index
            
            if (nextRow < 0 || nextRow >= grid.length || 
                nextCol < 0 || nextCol >= grid[0].length ||
                visited & mask ||
                grid[nextRow][nextCol] === -1 || 
                grid[nextRow][nextCol] === 2 && squareCount) {
                continue
            }
            
            memo[state] += _uniquePathsIII(nextRow, 
                                           nextCol, 
                                           squareCount - 1, 
                                           visited | 1 << index)
        }
        
        return memo[state]
    }
    
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    let startRow = 0
    let startCol = 0
    let squareCount = 0
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === 1) {
                startRow = row
                startCol = col
            } else if (grid[row][col] === 0) {
                squareCount++
            }
        }
    }
    
    const memo = {}
    const index = getIndex(grid, startRow, startCol)
    return _uniquePathsIII(startRow, startCol, squareCount, 1 << index)
};

const getIndex = (grid, row, col) => {
    return row * grid[0].length + col
}
```

## 1617. Count Subtrees With Max Distance Between Cities
```javascript
// Bitmask + Tree Diameter
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var countSubgraphsForEachDiameter = function(n, edges) {
    const result = Array(n - 1).fill(0)
    const graph = buildGraph(n, edges)
    
    for (let subset = 1; subset < 1 << n; subset++) {
        const maxDist = getMaxDist(subset, graph, n)
        if (maxDist === 0) continue
        result[maxDist - 1]++
    }
    
    return result
};
const getMaxDist = (subset, graph, n) => {
    const dfs = (vertex) => {
        const _dfs = (vertex, parent, length) => {
            if (length > maxLength) {
                maxLength = length
                endNode = vertex
            }
            
            for (const neighbor of graph[vertex]) {
                if ((subset & 1 << neighbor) === 0) continue
                if (neighbor === parent) continue
                reached++
                _dfs(neighbor, vertex, length + 1)
            }
        }
        
        let maxLength = 0
        let endNode = null
        _dfs(vertex, null, 0)
        return [maxLength, endNode]
    }
    
    const numOfVertices = countOnes(subset)
    if (numOfVertices <= 1) return false
    
    let startVertex = -1
    for (let vertex = 0; vertex < n; vertex++) {
        if (subset & 1 << vertex) {
            startVertex = vertex
            break
        }
    }
    
    let reached = 1
    const [, endVertex] = dfs(startVertex)
    if (reached !== numOfVertices) return 0
    
    const [length, ] = dfs(endVertex)
    return length
}

const buildGraph = (n, edges) => {
    const graph = {}
    
    for (let [u, v] of edges) {
        u--
        v--
        
        if (!graph[u]) graph[u] = []
        if (!graph[v]) graph[v] = []
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}

const countOnes = subset => {
    let count = 0
    while (subset) {
        count++
        subset &= subset - 1
    }
    
    return count
}

// Bitmask + Floyd Warshall
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var countSubgraphsForEachDiameter = function(n, edges) {
    const result = Array(n - 1).fill(0)
    
    const graph = Array(n).fill().map(a => Array(n).fill(Infinity))
    for (let [u, v] of edges) {
        u--
        v--
        
        graph[u][v] = 1
        graph[v][u] = 1
    }
    
    for (let i = 0; i < n; i++) {
        graph[i][i] = 0
    }
    
    for (let intermediate = 0; intermediate < n; intermediate++) {
        for (let from = 0; from < n; from++) {
            for (let to = 0; to < n; to++) {
                graph[from][to] = Math.min(graph[from][to], graph[from][intermediate] + graph[intermediate][to])
            }
        }
    }
    
    for (let subset = 1; subset < 1 << n; subset++) {
        const maxDist = getMaxDist(subset, graph, n)
        if (maxDist === 0) continue
        result[maxDist - 1]++
    }
    
    return result
};

const getMaxDist = (subset, graph, n) => {
    let max = 0
    let countCity = 0
    let countEdge = 0
    
    for (let from = 0; from < n; from++) {
        if ((subset & 1 << from) === 0) continue
        countCity++
        
        for (let to = from + 1; to < n; to++) {
            if ((subset & 1 << to) === 0) continue
            countEdge += graph[from][to] === 1
            max = Math.max(max, graph[from][to])
        }
    }
    
    if (countEdge !== countCity - 1) return 0
    return max
}
```

## 1088. Confusing Number II
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var confusingNumberII = function(N) {
    const _confusingNumberII = curr => {
        if (curr > N) return 0
        count += curr > 1 && isConfusing(curr, map)
        
        for (const num of nums) {
            if (num === 0 && curr === 0) continue
            _confusingNumberII(curr * 10 + num)
        }
    }
    
    const nums = [0, 1, 6, 8, 9]
    const map = { 0: 0, 1: 1, 6: 9, 8: 8, 9: 6 }
    let count = 0
    _confusingNumberII(0)
    return count
};

const isConfusing = (num, map) => {
    let rotatedNum = 0
    let n = num
    while (n) {
        const digit = n % 10
        rotatedNum = rotatedNum * 10 + map[digit]
        n = Math.floor(n / 10)
    }
    
    return num !== rotatedNum   
}
```

## 1307. Verbal Arithmetic Puzzle
```javascript
/**
 * @param {string[]} words
 * @param {string} result
 * @return {boolean}
 */
var isSolvable = function(words, result) {
    const _isSolvable = (wordIndex, charIndex, wordsSum, resultSum, num) => {
        if (wordIndex >= words.length) {
            return wordsSum === resultSum
        }
        
        const wordLen = words[wordIndex].length
        if (charIndex >= wordLen) {
            if (wordIndex === words.length - 1) {
                return _isSolvable(wordIndex + 1, 0, wordsSum, num, 0)
            }
            
            return _isSolvable(wordIndex + 1, 0, wordsSum + num, resultSum, 0)
        }
        
        const char = words[wordIndex][charIndex]
        if (map.get(char) !== undefined) {
            if (map.get(char) === 0 && num === 0 && wordLen > 1) {
                return false
            }
            
            return _isSolvable(wordIndex, 
                               charIndex + 1, 
                               wordsSum, 
                               resultSum, 
                               num * 10 + map.get(char))
        }
        
        for (let digit = 0; digit <= 9; digit++) {
            if (digit === 0 && num === 0 && wordLen > 1) continue
            if (map.get(digit) !== undefined) continue

            map.set(digit, char)
            map.set(char, digit)

            if (_isSolvable(wordIndex, 
                            charIndex + 1, 
                            wordsSum, 
                            resultSum, 
                            num * 10 + digit)) {
                return true
            }
            
            map.set(digit, undefined)
            map.set(char, undefined)
        }
        
        return false
    }
    
    const map = new Map()
    words = [...words, result]
    return _isSolvable(0, 0, 0, 0, 0)
};
```

## 996. Number of Squareful Arrays
```javascript
// Backtracking
/**
 * @param {number[]} A
 * @return {number}
 */
var numSquarefulPerms = function(A) {
    const _numSquarefulPerms = path => {
        if (path.length >= A.length) return 1
        
        let count = 0
        for (const [key, val] of Object.entries(counts)) {
            if (val <= 0) continue
            if (path.length > 0 && !isPerfect(path[path.length - 1], +key)) continue
            
            counts[key]--
            path.push(+key)
            
            count += _numSquarefulPerms(path)
            
            path.pop()
            counts[key]++
        }
        
        return count
    }
    
    const counts = {}
    for (const num of A) {
        counts[num] = 1 + (counts[num] || 0)
    }
    
    return _numSquarefulPerms([])
};

const isPerfect = (num1, num2) => {
    const sum = num1 + num2
    return Math.trunc(Math.sqrt(sum)) === Math.sqrt(sum)
}
```

## 1659. Maximize Grid Happiness
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @param {number} introvertsCount
 * @param {number} extrovertsCount
 * @return {number}
 */
var getMaxGridHappiness = function(m, n, introvertsCount, extrovertsCount) {    
    const dp = (index, iMask, eMask, iCount, eCount) => {
        const key = `${index}-${iMask}-${eMask}-${iCount}-${eCount}`
        if (memo[key]) return memo[key]
        
        const row = index / n
        const col = index % n
        
        if (row >= m) return 0
        
        const nextIMask = (iMask << 1) & ((1 << n) - 1)
        const nextEMask = (eMask << 1) & ((1 << n) - 1)
        
        let max = dp(index + 1, nextIMask, nextEMask, iCount, eCount)
        
        if (iCount > 0) {
            const result = 120 + 
                           cost(row, col, iMask, eMask, -30, n) + 
                           dp(index + 1, nextIMask + 1, nextEMask, iCount - 1, eCount)
            max = Math.max(max, result)
        }
        
        if (eCount > 0) {
            const result = 40 + 
                           cost(row, col, iMask, eMask, 20, n) + 
                           dp(index + 1, nextIMask, nextEMask + 1, iCount, eCount - 1)
            max = Math.max(max, result)
        }
        
        memo[key] = max
        return max
    }
    
    const memo = {}
    return dp(0, 0, 0, introvertsCount, extrovertsCount)
}

const cost = (row, col, iMask, eMask, delta, n) => {
    let result = 0
    const up = (1 << (n - 1))

    if (col > 0 && (iMask & 1)) {
        result += delta
        result += -30
    }

    if (col > 0 && (eMask & 1)) {
        result += delta
        result += 20
    }
    
    if (row > 0 && (iMask & up)) {
        result += delta
        result += -30
    }

    if (row > 0 && (eMask & up)) {
        result += delta
        result += 20
    }

    return result
}
```

## 126. Word Ladder II
```javascript
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
    const words = new Set(wordList)
    
    const graph = {}
    const dist = {}
    dist[beginWord] = 0
    
    const queue = [beginWord]
    while (queue.length) {
        const node = queue.shift()
                
        if (node === endWord) break
        
        if (!graph[node]) {
            graph[node] = []
        }
        
        for (const neighbor of getNeighbors(node, words)) {
            if (dist[neighbor] === undefined) {
                queue.push(neighbor)
                dist[neighbor] = dist[node] + 1
                graph[node].push(neighbor)
            } else if (dist[neighbor] === dist[node] + 1) {
                graph[node].push(neighbor)
            }
        }
    }
    
    return dfs(graph, beginWord, endWord)
};

const dfs = (graph, node, target) => {
    const _dfs = node => {
        if (node === target) {
            result.push(path.slice())
            return
        }
        
        if (graph[node]) {
            for (const neighbor of graph[node]) {
                path.push(neighbor)
                _dfs(neighbor)
                path.pop()
            }
        }
    }
    
    const result = []
    const path = [node]
    _dfs(node)
    return result
}

const getNeighbors = (word, words) => {
    const alphabet = 'abcdefghijklmnopqrstuvwxyz'
    const neighbors = []
    for (let i = 0; i < word.length; i++) {
        for (const letter of alphabet) {
            const str = word.slice(0, i) + letter + word.slice(i + 1)
            if (str === word || !words.has(str)) continue
            neighbors.push(str)
        }
    }
    
    return neighbors
}
```

## 1240. Tiling a Rectangle with the Fewest Squares
```javascript
/**
 * @param {number} n
 * @param {number} m
 * @return {number}
 */
var tilingRectangle = function(n, m) {
    const _tilingRectangle = (heights) => {
        const state = heights.join('')
        let minHeight = Infinity
        let minIndex = Infinity
        
        if (memo[state] !== undefined) {
            return memo[state]
        }
        
        for (let i = 0; i < heights.length; i++) {
            if (heights[i] < minHeight) {
                minHeight = heights[i]
                minIndex = i
            }
        }
        
        if (minHeight === n) {
            return 0
        }
        
        let count = Infinity
        for (let right = minIndex; heights[right] === minHeight && right < m; right++) {
            const size = right - minIndex + 1
            if (size + minHeight > n) {
                break
            }
            
            for (let j = minIndex; j <= right; j++) {
                heights[j] += size
            }
            
            count = Math.min(count, 1 + _tilingRectangle(heights))
            
            for (let j = minIndex; j <= right; j++) {
                heights[j] -= size
            }
        }
        
        memo[state] = count
        return count
    }
    
    const memo = {}
    const heights = Array(m).fill(0)
    return _tilingRectangle(heights)
};
```

## 1434. Number of Ways to Wear Different Hats to Each Other
```javascript
// Top Down DP
/**
 * @param {number[][]} hats
 * @return {number}
 */
var numberWays = function(hats) {
    const _numberWays = (hat, used) => {      
        if (used === (1 << n) - 1) return 1
        if (hat > 40) return 0
        
        if (memo[hat][used] !== undefined) {
            return memo[hat][used]
        }
        
        memo[hat][used] = _numberWays(hat + 1, used)
        for (const person of map[hat]) {
            if (used & 1 << person) continue
            memo[hat][used] += _numberWays(hat + 1, used | 1 << person)
        }
        
        return memo[hat][used]
    }
    
    const MOD = 10 ** 9 + 7
    const n = hats.length
    const map = Array(41).fill().map(a => [])
    for (let person = 0; person < n; person++) {
        for (const hat of hats[person]) {
            map[hat].push(person)
        }
    }
    
    const memo = Array(41).fill().map(a => Array(1 << n))
    return _numberWays(1, 0) % MOD
};
```

## 1655. Distribute Repeating Integers
```javascript
// Time - O(n * 3^n)
// https://cp-algorithms.com/algebra/all-submasks.html
/**
 * @param {number[]} nums
 * @param {number[]} quantity
 * @return {boolean}
 */
var canDistribute = function(nums, quantity) {
    const _canDistribute = (index, mask) => {
        if (mask === 0) return true
        if (index >= n) return false
        
        if (memo[index][mask] !== undefined) 
            return memo[index][mask]
        
        if (_canDistribute(index + 1, mask)) {
            memo[index][mask] = true
            return true
        }
        
        let submask = mask
        while (submask > 0) {
            if (totals[submask] <= counts[index]) {
                if (_canDistribute(index + 1, mask ^ submask)) {
                    memo[index][mask] = true
                    return true
                }
            }

            submask = (submask - 1) & mask
        }
        
        memo[index][mask] = false
        return false
    }
    
    const totals = quantitiesFromSubsets(quantity)
    const counts = getFrequencies(nums)
    
    const n = counts.length
    const m = quantity.length
    
    const memo = new Array(n).fill().map(a => new Array(1 << m))
    
    return _canDistribute(0, (1 << m) - 1)
};

const getFrequencies = nums => {
    const counts = {}
    for (const num of nums) {
        counts[num] = 1 + (counts[num] || 0)
    }
    
    return Object.values(counts)
}

const quantitiesFromSubsets = (quantity) => {
    const m = quantity.length
    const totals = Array(1 << m).fill(0)
    for (let mask = 0; mask < 1 << m; mask++) {
        for (let i = 0; i < m; i++) {
            if (mask & 1 << i) {
                totals[mask] += quantity[i]
            }
        }
    }
    return totals
}
```

## 894. All Possible Full Binary Trees
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number} N
 * @return {TreeNode[]}
 */
var allPossibleFBT = function(N) {
    const _allPossibleFBT = (N) => {
        if (memo[N] !== undefined)
            return memo[N]
        
        const result = []
        for (let i = 1; i < N; i += 2) {
            const leftSubtrees = _allPossibleFBT(i)
            const rightSubtrees = _allPossibleFBT(N - i - 1)

            for (const left of leftSubtrees) {
                for (const right of rightSubtrees) {
                    const root = new TreeNode(0)
                    root.left = left
                    root.right = right

                    result.push(root)
                }
            }
        }
        
        memo[N] = result
        return result
    }
    
    if (N % 2 === 0) return []
    
    const memo = {}
    memo[0] = []
    memo[1] = [new TreeNode(0)]
    
    return _allPossibleFBT(N)
};
```

## 776. Split BST
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} V
 * @return {TreeNode[]}
 */
var splitBST = function(root, V) {
    if (!root) return [null, null]

    if (root.val <= V) {
        const trees = splitBST(root.right, V)
        root.right = trees[0]
        trees[0] = root
        return trees
    } else {
        const trees = splitBST(root.left, V)
        root.left = trees[1]
        trees[1] = root
        return trees
    }
};
```

## 625. Minimum Factorization
```javascript
/**
 * @param {number} a
 * @return {number}
 */
var smallestFactorization = function(a) {
    if (a < 2) return a
    
    const max = ((2 ** 32) / 2) - 1
    let result = 0
    let place = 1
    
    for (let factor = 9; factor >= 2; factor--) {
        while (a % factor === 0) {
            a /= factor
            result = place * factor + result
            place *= 10
        }
    }
    
    return a < 2 && result <= max ? result : 0
};
```

## 241. Different Ways to Add Parentheses
```javascript
/**
 * @param {string} input
 * @return {number[]}
 */
var diffWaysToCompute = function(input) {
    const _diffWaysToCompute = input => {
        if (memo[input] !== undefined) 
            return memo[input]
        
        const result = []
        
        for (let i = 0; i < input.length; i++) {
            const operatorFunction = operatorMap[input[i]]
            if (operatorFunction === undefined) continue

            const left = _diffWaysToCompute(input.slice(0, i))
            const right = _diffWaysToCompute(input.slice(i + 1))
            
            for (const l of left) {
                for (const r of right) {
                    result.push(operatorFunction(l, r))
                }
            }
        }

        memo[input] = result.length ? result : [input]
        return memo[input]
    }
    
    const memo = {}
    return _diffWaysToCompute(input)
};

const operatorMap = {
    '+': ((a, b) => +a + +b),
    '-': ((a, b) => a - b),
    '*': ((a, b) => a * b)
}
```

## 273. Integer to English Words
```javascript
/**
 * @param {number} num
 * @return {string}
 */
var numberToWords = function(num) {
    const groups = ['', 'Thousand', 'Million', 'Billion']
    
    const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 
                  'Sixty', 'Seventy', 'Eighty', 'Ninety']
    
    const underTwenty = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 
                         'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 
                         'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 
                         'Seventeen', 'Eighteen', 'Nineteen']
    
    const _numberToWords = num => {
        if (num < 20) return [underTwenty[num]]
        if (num < 100) {
            const quotient = Math.floor(num / 10)
            const remainder = num % 10
            return [tens[quotient], underTwenty[remainder]]
        }
        if (num < 1000) {
            const quotient = Math.trunc(num / 100)
            const remainder = num % 100
            return [underTwenty[quotient], 'Hundred', ..._numberToWords(remainder)]
        }
        
        for (let power = 1; power < groups.length; power++) {
            if (num >= 1000 ** (power + 1)) continue
            const quotient = Math.trunc(num / 1000 ** power)
            const remainder = num % 1000 ** power
            return [..._numberToWords(quotient), groups[power], ..._numberToWords(remainder)]
        }
    }
    
    if (num === 0) return 'Zero'
    return _numberToWords(num).filter(s => s !== '').join(' ')
};
```

## 29. Divide Two Integers
```javascript
var divide = function(dividend, divisor) {
    const lowerBound = -(2 ** 31)
    const halfLowerBound = lowerBound >> 1
    const upperBound = (2 ** 31) - 1
    
    if (dividend === 0 || divisor === 0) return 0
    if (dividend === lowerBound && divisor === -1) return upperBound
    
    let negatives = 2
    if (dividend > 0) {
        negatives--
        dividend = -dividend
    }
    
    if (divisor > 0) {
        negatives--
        divisor = -divisor
    }
    
    let highestPowerOfTwo = -1
    let highestDouble = divisor
    while (highestDouble >= halfLowerBound && 
           dividend <= highestDouble + highestDouble) {
        highestPowerOfTwo += highestPowerOfTwo
        highestDouble += highestDouble
    }
    
    let quotient = 0
    while (dividend <= divisor) {
        if (dividend <= highestDouble) {
            quotient += highestPowerOfTwo
            dividend -= highestDouble
        }
        
        highestPowerOfTwo = (highestPowerOfTwo + 1) >> 1
        highestDouble = (highestDouble + 1) >> 1
    }
    
    if (negatives !== 1) {
        quotient = -quotient
    }
    
    return quotient
};
```

## 1662. Check If Two String Arrays are Equivalent
```javascript
/**
 * @param {string[]} word1
 * @param {string[]} word2
 * @return {boolean}
 */
var arrayStringsAreEqual = function(word1, word2) {
    let word1Index = 0
    let word2Index = 0
    
    let section1Index = 0
    let section2Index = 0
    
    while (word1Index < word1.length && word2Index < word2.length) {
        const section1 = word1[word1Index]
        const section2 = word2[word2Index]
        
        while (section1Index < section1.length && section2Index < section2.length) {
            if (section1[section1Index] !== section2[section2Index]) {
                return false
            }
            
            section1Index++
            section2Index++
        }
        
        if (section1Index >= section1.length) {
            section1Index = 0
            word1Index++
        }
        
        if (section2Index >= section2.length) {
            section2Index = 0
            word2Index++
        }
    }
    
    return word1Index >= word1.length && word2Index >= word2.length
};
```

## 59. Spiral Matrix II
```javascript
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
    let top = 0
    let bottom = n - 1
    let left = 0
    let right = n - 1
    
    const result = new Array(n).fill().map(a => new Array(n))
    let num = 1
    
    while (top <= bottom && left <= right) {
        for (let i = left; i <= right; i++) result[top][i] = num++
        top++
        
        for (let i = top; i <= bottom; i++) result[i][right] = num++
        right--
        
        if (top > bottom || left > right) break
        
        for (let i = right; i >= left; i--) result[bottom][i] = num++
        bottom--
        
        for (let i = bottom; i >= top; i--) result[i][left] = num++
        left++
    }
    
    return result
};
```

## 1661. Average Time of Process per Machine
```sql
# Write your MySQL query statement below
SELECT machine_id, 
       ROUND(SUM(IF(activity_type = 'end', timestamp, -timestamp))
             / COUNT(DISTINCT process_id), 3) AS processing_time
FROM Activity
GROUP BY machine_id
```

## 885. Spiral Matrix III
```javascript
/**
 * @param {number} R
 * @param {number} C
 * @param {number} r0
 * @param {number} c0
 * @return {number[][]}
 */
var spiralMatrixIII = function(R, C, r0, c0) {
    const result = []
    const total = R * C
    
    const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]
    let dir = 0
    
    let walkLen = 1
    let steps = 1
    
    while (result.length < total) {
        for (let i = 0; i < walkLen; i++) {
            if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C)
                result.push([r0, c0])
    
            r0 += dirs[dir][0]
            c0 += dirs[dir][1]
        }
        
        dir = (dir + 1) % dirs.length
        if (steps % 2 === 0) walkLen++
        steps++
    }
    
    return result
};
```

## 236. Lowest Common Ancestor of a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (!root) return null
    
    if (root === p || root === q) return root
    
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    
    if (left && right) return root
    return left || right
};
```

## 1320. Minimum Distance to Type a Word Using Two Fingers
```javascript
// Top Down DP
/**
 * @param {string} word
 * @return {number}
 */
var minimumDistance = function(word) {
    const _minimumDistance = (index, f1, f2) => {
        if (index === word.length) 
            return 0
        
        if (memo[index][f1][f2] !== undefined)
            return memo[index][f1][f2]
        
        const next = charToIndex(word[index])
        
        let min = Infinity
        min = Math.min(min, dist(f1, next) + _minimumDistance(index + 1, next, f2))
        min = Math.min(min, dist(f2, next) + _minimumDistance(index + 1, f1, next))
        memo[index][f1][f2] = min
        return min
    }
    
    const n = word.length
    const memo = new Array(n).fill()
                        .map(a => new Array(27).fill()
                        .map(a => new Array(27).fill()))
    
    const start = charToIndex(word[0])
    return _minimumDistance(1, start, 26)
};

const dist = (coordinate1, coordinate2) => {
    if (coordinate1 === 26 || coordinate2 === 26)
        return 0
    
    const [x1, y1] = indexToCoordinate(coordinate1)
    const [x2, y2] = indexToCoordinate(coordinate2)
    return Math.abs(x1 - x2) + Math.abs(y1 - y2)
}

const charToIndex = char => char.charCodeAt(0) - 'A'.charCodeAt(0)

const indexToCoordinate = index => [Math.floor(index / 6), index % 6]
```

## 1043. Partition Array for Maximum Sum
```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var maxSumAfterPartitioning = function(arr, k) {
    const _maxSumAfterPartitioning = (start) => {
        if (start >= arr.length) return 0
        if (memo[start] !== undefined) return memo[start]
        
        let result = 0
        let max = 0
        for (let i = start; i < Math.min(arr.length, start + k); i++) {
            const length = i - start + 1
            max = Math.max(max, arr[i])
            result = Math.max(result, length * max + _maxSumAfterPartitioning(i + 1))
        }
        
        memo[start] = result
        return result
    }
    
    const memo = new Array(arr.length)
    return _maxSumAfterPartitioning(0, 0)
};
```

## 568. Maximum Vacation Days
```javascript
/**
 * @param {number[][]} flights
 * @param {number[][]} days
 * @return {number}
 */
var maxVacationDays = function(flights, days) {
    const _maxVacationDays = (city, week) => {
        if (week >= k) return 0
        
        if (memo[city][week] !== undefined) 
            return memo[city][week]
        
        let max = 0
        for (let neighbor = 0; neighbor < flights.length; neighbor++) {
            if (neighbor !== city && !flights[city][neighbor]) continue
            max = Math.max(max, days[neighbor][week] + _maxVacationDays(neighbor, week + 1))
        }
        
        memo[city][week] = max
        return max
    }
    
    const n = flights.length
    const k = days[0].length
    const memo = new Array(n).fill().map(a => new Array(k))
    return _maxVacationDays(0, 0, 0)
};
```

## 673. Number of Longest Increasing Subsequence
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumberOfLIS = function(nums) {
    const dp = Array(nums.length).fill(1)
    const counts = Array(nums.length).fill(1)
    
    let maxLen = 1
    let count = 0
    for (let i = 0; i < dp.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] <= nums[j]) continue
            if (dp[i] === dp[j] + 1) {
                counts[i] += counts[j]
            } else if (dp[i] < dp[j] + 1) {
                dp[i] = dp[j] + 1
                counts[i] = counts[j]
            }
        }
        
        if (maxLen === dp[i]) {
            count += counts[i]
        } else if (maxLen < dp[i]) {
            maxLen = dp[i]
            count = counts[i]
        }
    }

    return count
};
```

## 647. Palindromic Substrings
```javascript
// DP: Time - O(n^2), Space - O(n^2)
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
    const n = s.length
    const dp = new Array(n).fill().map(a => new Array(n).fill(false))
    
    let count = 0
    for (let len = 1; len <= n; len++) {
        for (let i = 0; i <= n - len; i++) {
            const j = i + len - 1
            
            if (len === 1) {
                dp[i][j] = true
                count++
            } else if (s[i] === s[j] && len === 2) {
                dp[i][j] = true
                count++
            } else if (s[i] === s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true
                count++
            }
        }
    }
    
    return count
};
```

## 1672. Richest Customer Wealth
```javascript
/**
 * @param {number[][]} accounts
 * @return {number}
 */
var maximumWealth = function(accounts) {
    const m = accounts.length
    const n = accounts[0].length
    
    let maxWealth = 0
    for (let customer = 0; customer < m; customer++) {
       let currWealth = 0
       for (let bank = 0; bank < n; bank++) {
           currWealth += accounts[customer][bank]
       }
       maxWealth = Math.max(maxWealth, currWealth)
    }
    return maxWealth
};
```

## 1656. Design an Ordered Stream
```javascript
/** 
 * Your OrderedStream object will be instantiated and called as such:
 * var obj = new OrderedStream(n)
 * var param_1 = obj.insert(id,value)
 */

// Hash Map
/**
 * @param {number} n
 */
var OrderedStream = function(n) {
    this.elements = {}
    this.curr = 1
};

/** 
 * @param {number} id 
 * @param {string} value
 * @return {string[]}
 */
OrderedStream.prototype.insert = function(id, value) {
    this.elements[id] = value
    
    const result = []
    while (this.elements[this.curr]) {
        result.push(this.elements[this.curr])
        this.curr++
    }
    
    return result
};

/** 
 * Your OrderedStream object will be instantiated and called as such:
 * var obj = new OrderedStream(n)
 * var param_1 = obj.insert(id,value)
 */
```

## 1640. Check Array Formation Through Concatenation
```javascript
/**
 * @param {number[]} arr
 * @param {number[][]} pieces
 * @return {boolean}
 */
var canFormArray = function(arr, pieces) {
    const map = new Array(101)
    for (let group = 0; group < pieces.length; group++) {
        const num = pieces[group][0]
        map[num] = pieces[group]
    }
    
    let i = 0
    while (i < arr.length) {
        const num = arr[i]
        if (map[num] === undefined) 
            return false
        
        for (const piece of map[num]) {
            if (piece !== arr[i]) return false
            i++
        }
    }

    return true
};
```

## 1667. Fix Names in a Table
```sql
# Write your MySQL query statement below
SELECT user_id, 
       CONCAT(UPPER(LEFT(name, 1)), LOWER(SUBSTRING(name, 2))) AS name
FROM Users
ORDER BY user_id
```

## 1636. Sort Array by Increasing Frequency
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var frequencySort = function(nums) {
    const freq = new Array(202).fill(0)
    const offset = 100
    for (const num of nums) {
        freq[num + offset]++
    }
    
    const buckets = new Array(101)
    for (let num = freq.length - 1; num >= 0; num--) {
        const count = freq[num]
        while (freq[num]--) {
            if (!buckets[count]) buckets[count] = []
            buckets[count].push(num - offset)
        }
    }
    
    return buckets.flat()
};
```

## 1646. Get Maximum in Generated Array
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var getMaximumGenerated = function(n) {
    if (n === 0) return 0
    if (n <= 2) return 1
    
    const nums = [0, 1]
    let max = 1
    for (let i = 1; i < n / 2; i++) {
        nums[2 * i] = nums[i]
        nums[2 * i + 1] = nums[i] + nums[i + 1]
        max = Math.max(max, nums[2 * i], nums[2 * i + 1])
    } 
    
    return max
};
```

## 188. Best Time to Buy and Sell Stock IV
```javascript
/**
 * @param {number} k
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(k, prices) {
    if (!prices.length) return 0
    
    const m = k + 1
    const n = prices.length
    
    let prev = new Array(n).fill(0)
    for (let t = 1; t < m; t++) {
        const curr = new Array(n).fill(0)
        let maxSoFar = -Infinity
        for (let d = 1; d < n; d++) {
            maxSoFar = Math.max(maxSoFar, prev[d - 1] - prices[d - 1])
            curr[d] = Math.max(curr[d - 1], maxSoFar + prices[d])
        }
        prev = curr
    }
    
    return prev[n - 1]
};
```

## 309. Best Time to Buy and Sell Stock with Cooldown
```javascript
// DP - Time: O(n), Space: O(n)
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    const n = prices.length
    if (n < 2) return 0
    
    const dp = new Array(n).fill().map(a => [0, 0])
    dp[0][1] = -prices[0]
    dp[1][0] = Math.max(0, dp[0][1] + prices[1])
    dp[1][1] = Math.max(dp[0][1], -prices[1])
    
    for (let i = 2; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i])
    }
    
    return dp[n - 1][0]
};

// DP - Time: O(n), Space: O(1)
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    const n = prices.length
    if (n < 2) return 0
    
    let cooldown = 0
    let notHold = 0
    let hold = -Infinity
    
    for (const price of prices) {
        const temp = cooldown
        cooldown = notHold
        notHold = Math.max(notHold, hold + price)
        hold = Math.max(hold, temp - price)
    }
    
    return notHold
};
```

## 714. Best Time to Buy and Sell Stock with Transaction Fee
```javascript
// DP - Time: O(n), Space: O(n)
/**
 * @param {number[]} prices
 * @param {number} fee
 * @return {number}
 */
var maxProfit = function(prices, fee) {
    const n = prices.length
    const dp = new Array(2).fill().map(a => new Array(n).fill(0))
    dp[1][0] = -prices[0]
    
    for (let i = 1; i < n; i++) {
        dp[0][i] = Math.max(dp[0][i - 1], dp[1][i - 1] + prices[i] - fee)
        dp[1][i] = Math.max(dp[1][i - 1], dp[0][i - 1] - prices[i])
    }
    
    return dp[0][n - 1]
};

// DP - Time: O(n), Space: O(1)
/**
 * @param {number[]} prices
 * @param {number} fee
 * @return {number}
 */
var maxProfit = function(prices, fee) {
    if (prices.length < 2) return 0
    
    const n = prices.length
    const dp = new Array(2).fill().map(a => new Array(n).fill(0))
    
    let notHold = 0
    let hold = -prices[0]
    
    for (let i = 1; i < n; i++) {
        notHold = Math.max(notHold, hold + prices[i] - fee)
        hold = Math.max(hold, notHold - prices[i])
    }
    
    return notHold
};
```

## 312. Burst Balloons
```javascript
// Top Down DP
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxCoins = function(nums) {
    const _maxCoins = (start, end, left, right) => {
        if (start > end) return 0
        
        if (memo[start][end] !== undefined) {
            return memo[start][end]
        }
        
        let max = 0
        for (let i = start; i <= end; i++) {
            const result = left * nums[i] * right + 
                           _maxCoins(start, i - 1, left, nums[i]) +
                           _maxCoins(i + 1, end, nums[i], right)
            
            max = Math.max(max, result)
        }
        
        memo[start][end] = max
        return max
    }
    
    const n = nums.length
    const memo = new Array(n).fill().map(a => new Array(n))
    return _maxCoins(0, n - 1, 1, 1)
};
```

## 221. Maximal Square
```javascript
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
    if (!matrix.length) return 0
    
    const m = matrix.length
    const n = matrix[0].length
    
    const dp = new Array(m).fill(0).map(arr => new Array(n).fill(0))
    let max = 0
    
    for (let row = 0; row < m; row++) {
        dp[row][0] = +matrix[row][0]
        max = Math.max(max, dp[row][0])
    }
    
    for (let col = 1; col < n; col++) {
        dp[0][col] = +matrix[0][col]
        max = Math.max(max, dp[0][col])
    }
    
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            if (matrix[row][col] === '0') continue
            dp[row][col] = 1 + Math.min(dp[row - 1][col], dp[row][col - 1], dp[row - 1][col - 1])
            max = Math.max(max, dp[row][col])
        }
    }
    
    return max * max
};
```

## 365. Water and Jug Problem
```javascript
/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {boolean}
 */
var canMeasureWater = function(x, y, z) {
    const queue = [[0, 0]]
    const visited = new Set(['0-0'])
    
    while (queue.length) {
        const [jug1, jug2] = queue.shift()
        
        if (jug1 === z || jug2 === z || jug1 + jug2 === z)
            return true
        
        for (const state of getStates(jug1, jug2, x, y)) {
            const key = state.join('')
            if (visited.has(key)) continue
            visited.add(key)
            
            queue.push(state)
        }
    }
    
    return false
};

const getStates = (jug1, jug2, x, y) => {
    return [
        [x, jug2],
        [jug1, y],
        [0, jug2],
        [jug1, 0],
        [jug1 - Math.min(jug1, y - jug2), jug2 + Math.min(jug1, y - jug2)],
        [jug1 + Math.min(x - jug1, jug2), jug2 - Math.min(x - jug1, jug2)]
    ]
}
```

## 1178. Number of Valid Words for Each Puzzle
```javascript
/**
 * @param {string[]} words
 * @param {string[]} puzzles
 * @return {number[]}
 */
var findNumOfValidWords = function(words, puzzles) {
    const map = {}
    for (const word of words) {
        const mask = getMask(word)
        map[mask] = 1 + (map[mask] || 0)
    }
    
    const result = []
    for (const puzzle of puzzles) {
        let count = 0
        
        const mask = getMask(puzzle)
        let submask = mask
        
        while (submask > 0) {
            if (submask & 1 << index(puzzle[0]))
                count += map[submask] || 0
            
            submask = (submask - 1) & mask 
        }
        
        result.push(count)
    }
    
    return result
};

const getMask = word => {
    let mask = 0
    for (const char of word) {
        mask |= 1 << index(char)
    }
    return mask
}

const index = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
```

## 1001. Grid Illumination
```javascript
/**
 * @param {number} N
 * @param {number[][]} lamps
 * @param {number[][]} queries
 * @return {number[]}
 */
var gridIllumination = function(N, lamps, queries) {
    const dirs = [[1, 0], [0, 1], [1, 1], [-1, -1], [0, -1], 
                  [-1, 0], [-1, 1], [1, -1], [0, 0]]
    
    const rowMap = {}
    const colMap = {}
    const diagonalMap = {}
    const antiDiagonalMap = {}
    const lampsOn = new Set()
    for (const [row, col] of lamps) {
        rowMap[row] = 1 + (rowMap[row] || 0)
        
        colMap[col] = 1 + (colMap[col] || 0)
        
        const diagonal = row - col
        diagonalMap[diagonal] = 1 + (diagonalMap[diagonal] || 0)
        
        const antiDiagonal = row + col
        antiDiagonalMap[antiDiagonal] = 1 + (antiDiagonalMap[antiDiagonal] || 0)
        
        lampsOn.add(`${row}-${col}`)
    }
    
    const result = []
    for (const [row, col] of queries) {
        
        if (rowMap[row] > 0 || colMap[col] > 0 || 
            diagonalMap[row - col] > 0 || antiDiagonalMap[row + col] > 0) {
            result.push(1)
        } else {
            result.push(0)
            continue
        }
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            if (nextRow < 0 || nextRow >= N || nextCol < 0 || nextCol >= N) continue
            
            const key = `${nextRow}-${nextCol}`
            if (!lampsOn.has(key)) continue
            lampsOn.delete(key)
                
            rowMap[nextRow]--
            colMap[nextCol]--
            diagonalMap[nextRow - nextCol]--
            antiDiagonalMap[nextRow + nextCol]--
        }
    }
    
    return result
};
```

## 1233. Remove Sub-Folders from the Filesystem
```javascript
// HashMap: Time - O(n*m^2)
/**
 * @param {string[]} folder
 * @return {string[]}
 */
var removeSubfolders = function(folder) {
    const result = []
    const seen = new Set(folder)
    
    outer : for (const f of folder) {
        const prefix = []
        for (const s of f.split('/')) {
            if (s === '') continue
            if (seen.has(prefix.join(''))) {
                continue outer
            }
            prefix.push('/', s)
        }
        
        result.push(f)
    }
    
    return result
};

// Trie: Time - O(n*m)
/**
 * @param {string[]} folder
 * @return {string[]}
 */
var removeSubfolders = function(folder) {
    const result = []
    
    const trie = new Trie()
    for (const path of folder) {
        trie.insert(path)
    }
    
    outer : for (const path of folder) {
        let curr = trie.root
        
        for (const char of path.split('/')) { 
            if (char === '') continue
            
            if (curr.isEnd) {
                continue outer
            }
            curr = curr.children[char]
        }
        result.push(path)
    }
    
    return result
};

class Trie {
    constructor() {
        this.root = new TrieNode('')
    }
    
    insert(word) {
        let curr = this.root
        for (const char of word.split('/')) {
            if (char === '') continue
            if (!curr.children[char]) {
                curr.children[char] = new TrieNode(char)
            }
            curr = curr.children[char]
        }
        curr.isEnd = true
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.isEnd = false
    }
}
```

## 609. Find Duplicate File in System
```javascript
/**
 * @param {string[]} paths
 * @return {string[][]}
 */
var findDuplicate = function(paths) {
    const map = {}
    
    for (const path of paths) {
        const [dir, ...files] = path.split(' ')
        
        for (const file of files) {
            let filename = []
            let contents = []
            
            let readContents = false
            for (const char of file) {
                if (char === '(' || char === ')') {
                    readContents = true
                    continue
                }
                
                readContents ? contents.push(char) : filename.push(char)
            }
            
            filename = dir + '/' + filename.join('')
            contents = contents.join('')
            
            if (!map[contents]) map[contents] = []
            map[contents].push(filename)
        }
    }
    
    const result = []
    for (const group of Object.values(map)) {
        if (group.length > 1) {
            result.push(group)
        }
    }
    return result
};
```

## 1301. Number of Paths with Max Score
```javascript
/**
 * @param {string[]} board
 * @return {number[]}
 */
var pathsWithMaxScore = function(board) {
    const _pathsWithMaxScore = (row, col) => {
        if (row < 0 || row >= n || col < 0 || col >= n || 
            board[row][col] === 'X') return [-Infinity, 0]
        if (board[row][col] === 'E') return [0, 1]
        if (memo[row][col] !== undefined) return memo[row][col]
        
        let maxScore = -Infinity
        let maxPath = 0
        
        const results = [
            _pathsWithMaxScore(row - 1, col - 1),
            _pathsWithMaxScore(row - 1, col),
            _pathsWithMaxScore(row, col - 1)
        ]
        
        for (const [currScore, currPath] of results) {
            if (currScore === -Infinity) continue
            
            if (maxScore < currScore) {
                maxScore = currScore
                maxPath = currPath
            } else if (maxScore === currScore) {
                maxPath += currPath
            }
        }
        
        if (board[row][col] != 'S') {
            maxScore = maxScore + +board[row][col]
        }
        
        memo[row][col] = [maxScore, maxPath % MOD]
        return memo[row][col]
    }
    
    const MOD = 10 ** 9 + 7
    const n = board.length
    const memo = new Array(n).fill().map(a => new Array(n))
    
    const [max, path] = _pathsWithMaxScore(n - 1, n - 1)
    if (max === -Infinity) return [0, 0]
    return [max, path]
};
```

## 174. Dungeon Game
```javascript
/**
 * @param {number[][]} dungeon
 * @return {number}
 */
var calculateMinimumHP = function(dungeon) {
    const _calculateMinimumHP = (row, col) => {
        if (row < 0 || row >= m || col < 0 || col >= n) return Infinity
        if (memo[row][col] !== undefined) return memo[row][col]
        if (row === m - 1 && col === n - 1) {
            return Math.max(-1 * dungeon[row][col] + 1, 1)
        }
        
        const down = _calculateMinimumHP(row + 1, col)
        const right = _calculateMinimumHP(row, col + 1)
        memo[row][col] = Math.max(1, Math.min(down, right) - dungeon[row][col])
        return memo[row][col]
    }
    
    const m = dungeon.length
    const n = dungeon[0].length
    const memo = new Array(m).fill().map(a => new Array(n))
    return _calculateMinimumHP(0, 0)
};
```

## 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number[]} arr
 * @return {boolean}
 */
var isValidSequence = function(root, arr) {
    const dfs = (root, i) => {
        if (!root || arr[i] !== root.val) return false
        
        if (i === arr.length - 1 && !root.left && !root.right) {
            return true
        }
        
        return dfs(root.left, i + 1) || dfs(root.right, i + 1)
    }
    
    return dfs(root, 0)
};
```

## 1463. Cherry Pickup II
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var cherryPickup = function(grid) {
    const _cherryPickup = (row, col1, col2) => {
        if (row === rows) return 0
        
        if (memo[row][col1][col2] !== undefined) {
            return memo[row][col1][col2]
        }
        
        let max = 0
        for (let i = -1; i <= 1; i++) {
            const nextCol1 = i + col1
            if (nextCol1 < 0 || nextCol1 >= cols) continue
            
            for (let j = -1; j <= 1; j++) {
                const nextCol2 = j + col2
                if (nextCol2 < 0 || nextCol2 >= cols) continue
                
                max = Math.max(max, _cherryPickup(row + 1, nextCol1, nextCol2))
            }
        }
        
        max += grid[row][col1]
        if (col1 !== col2) max += grid[row][col2]
        
        memo[row][col2][col1] = max
        memo[row][col1][col2] = max
        return max
    }
    
    const rows = grid.length
    const cols = grid[0].length
    const memo = new Array(rows).fill()
                    .map(a => new Array(cols).fill()
                    .map(a => new Array(cols)))
    
    return _cherryPickup(0, 0, cols - 1)
};
```

## 741. Cherry Pickup
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var cherryPickup = function(grid) {
    const _cherryPickup = (row1, col1, col2) => {
        if (row1 === n - 1 && col1 === n - 1) {
            return grid[row1][col1]
        }
        
        if (memo[row1][col1][col2] !== undefined) {
            return memo[row1][col1][col2]
        }
        
        const row2 = row1 + col1 - col2
        let max = -Infinity
        for (const [deltaRow1, deltaCol1] of [[1, 0], [0, 1]]) {
            const nextRow1 = row1 + deltaRow1
            const nextCol1 = col1 + deltaCol1
            if (nextRow1 >= n || nextCol1 >= n || grid[nextRow1][nextCol1] === -1) continue
            
            for (const [deltaRow2, deltaCol2] of [[1, 0], [0, 1]]) {
                const nextRow2 = row2 + deltaRow2
                const nextCol2 = col2 + deltaCol2
                if (nextRow2 >= n || nextCol2 >= n || grid[nextRow2][nextCol2] === -1) continue
                
                max = Math.max(max, _cherryPickup(nextRow1, nextCol1, nextCol2))
            }
        }
        
        if (row1 === row2 && col1 === col2) {
            max += grid[row1][col1]
        } else {
            max += grid[row1][col1] + grid[row2][col2]
        }
        
        memo[row1][col1][col2] = max
        return max
    }
    
    const n = grid.length
    const memo = new Array(n).fill()
                    .map(a => new Array(n).fill()
                    .map(a => new Array(n).fill()))
    const result = _cherryPickup(0, 0, 0)
    return result === -Infinity ? 0 : result
};
```

## 718. Maximum Length of Repeated Subarray
```javascript
// DP: Time - O(n^2) / Space - O(n)
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
    const m = A.length
    const n = B.length
    
    let max = 0
    let prev = new Array(m + 1).fill(0)
    for (let i = 1; i <= m; i++) {
        const curr = new Array(m + 1).fill(0)
        for (let j = 1; j <= n; j++) {
            if (A[i - 1] === B[j - 1]) {
                curr[j] = 1 + prev[j - 1]
                max = Math.max(max, curr[j])
            }
        }
        prev = curr
    }
    
    return max
};
```

## 1248. Count Number of Nice Subarrays
```javascript
// Prefix Sums: Time - O(n) / Space - O(n)
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numberOfSubarrays = function(nums, k) {
    const map = { 0: 1 }
    let oddCount = 0
    let count = 0
    
    for (let i = 0; i < nums.length; i++) {
        oddCount += nums[i] & 1
        count += (map[oddCount - k] || 0)
        map[oddCount] = 1 + (map[oddCount] || 0)
    }
    
    return count
};

// Sliding Window: Time - O(n) / Space - O(1)

```

## 1679. Max Number of K-Sum Pairs
```javascript
// Sort + Two Pointers: Time - O(n log n) / Space - O(1)
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxOperations = function(nums, k) {
    nums.sort((a, b) => a - b)
    
    let count = 0
    let i = 0
    let j = nums.length - 1
    
    while (i < j) {
        const sum = nums[i] + nums[j]
        
        if (sum === k) {
            count++
            i++
            j--
        } else if (sum < k) {
            i++
        } else {
            j--
        }
    }
    
    return count
};

// HashMap: Time - O(n) / Space - O(n)
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxOperations = function(nums, k) {
    const map = {}
    let count = 0
    for (const num of nums) {
        const compliment = k - num
        
        if (map[compliment]) {
            map[compliment]--
            count++
            continue
        }
        
        map[num] = 1 + (map[num] || 0)
    }
    
    return count
};
```

## 1677. Product's Worth Over Invoices
```sql
# Write your MySQL query statement below
SELECT name, 
       SUM(rest) AS rest, 
       SUM(paid) AS paid, 
       SUM(canceled) AS canceled, 
       SUM(refunded) AS refunded
FROM Product
JOIN Invoice
USING(product_id)
GROUP BY name
ORDER BY name
```

## 1678. Goal Parser Interpretation
```javascript
/**
 * @param {string} command
 * @return {string}
 */
var interpret = function(command) {
    const result = []
    
    for (let i = 0; i < command.length; i++) {
        if (command[i] === 'G') {
            result.push('G')
            continue
        }
        
        if (command[i + 1] === ')') {
            result.push('o')
            i++
            continue
        }
        
        result.push('al')
        i += 3
    }
    
    return result.join('')
};
```

## 1676. Lowest Common Ancestor of a Binary Tree IV
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode[]} nodes
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, nodes) {
    const _lowestCommonAncestor = (root) => {
        if (!root) return null
        
        if (uniqueNodes.has(root)) return root
        
        const left = _lowestCommonAncestor(root.left)
        const right = _lowestCommonAncestor(root.right)
        if (left && right) return root    
        return left || right
    }
    
    const uniqueNodes = new Set(nodes)    
    return _lowestCommonAncestor(root)
};
```

## 1396. Design Underground System
```javascript
// Note:
// In code, the largest space taken is the checkInMap, the space complexity of checkInMap is O(# of all subway users), in a large city like NY, this could be >10m. If we remove the entry when the user checkout, the space complexity become O(# of all concurrent riding subway users), it will be much smaller. maybe around 100K. It might be possible to reduce the space complexity of checkoutMap, but since the space complexity of checkoutMap is O(# of station * # of station), # of station may be is a couple hundreds at most, so the saving might not be significant.

var UndergroundSystem = function() {
    this.startMap = new Map()
    this.timeMap = new Map()
};

/** 
 * @param {number} id 
 * @param {string} stationName 
 * @param {number} t
 * @return {void}
 */
UndergroundSystem.prototype.checkIn = function(id, stationName, t) {
    this.startMap.set(id, [stationName, t])
};

/** 
 * @param {number} id 
 * @param {string} stationName 
 * @param {number} t
 * @return {void}
 */
UndergroundSystem.prototype.checkOut = function(id, stationName, t) {
    const [startStation, startTime] = this.startMap.get(id)
    const totalTime = t - startTime
    
    const key = `${startStation}-${stationName}`
    if (this.timeMap.get(key) === undefined) {
        this.timeMap.set(key, [0, 0])
    }
    
    const [sum, count] = this.timeMap.get(key)
    this.timeMap.set(key, [sum + totalTime, count + 1])
    this.startMap.delete(id)
};

/** 
 * @param {string} startStation 
 * @param {string} endStation
 * @return {number}
 */
UndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {
    const key = `${startStation}-${endStation}`
    if (this.timeMap.get(key) === undefined)
        return 0
    
    const [sum, count] = this.timeMap.get(key)
    return sum / count
};

/** 
 * Your UndergroundSystem object will be instantiated and called as such:
 * var obj = new UndergroundSystem()
 * obj.checkIn(id,stationName,t)
 * obj.checkOut(id,stationName,t)
 * var param_3 = obj.getAverageTime(startStation,endStation)
 */
```

## 1136. Parallel Courses
```javascript
// Kahn's Algo
/**
 * @param {number} N
 * @param {number[][]} relations
 * @return {number}
 */
var minimumSemesters = function(N, relations) {
    const graph = new Array(N + 1).fill().map(a => [])
    const indegrees = new Array(N + 1).fill(0)
    for ([u, v] of relations) {
        graph[u].push(v)
        indegrees[v]++
    }
    
    const queue = []
    for (let vertex = 1; vertex <= N; vertex++) {
        if (indegrees[vertex] === 0) {
            queue.push(vertex)
        }
    }
    
    let level = 1
    let seen = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const vertex = queue.shift()
            seen++
            
            for (const neighbor of graph[vertex]) {
                if (--indegrees[neighbor] === 0) {
                    queue.push(neighbor)
                }
            }
        }
        level++
    }
    
    return seen === N ? level - 1 : -1
};
```

## 635. Design Log Storage System
```javascript
// Insert: O(1)
// Retrieve: O(n)

var LogSystem = function() {
    this.logs = {}
};

/** 
 * @param {number} id 
 * @param {string} timestamp
 * @return {void}
 */
LogSystem.prototype.put = function(id, timestamp) {
    this.logs[timestamp] = id
};

/** 
 * @param {string} start 
 * @param {string} end 
 * @param {string} granularity
 * @return {number[]}
 */
LogSystem.prototype.retrieve = function(start, end, granularity) {
    const trimTimestamp = (timestamp, granularity) => {
        let endIndex = timestamp.length
        switch (granularity) {
            case "Year":
                endIndex = 4
                break
            case "Month":
                endIndex = 7
                break
            case "Day":
                endIndex = 10
                break
            case "Hour":
                endIndex = 13
                break
            case "Minute":
                endIndex = 16
                break
            case "Second":
                endIndex = 19
                break
        }
        
        return timestamp.slice(0, endIndex)
    }
    
    const result = []
    const startTime = trimTimestamp(start, granularity)
    const endTime = trimTimestamp(end, granularity)
    for (const [timestamp, id] of Object.entries(this.logs)) {
        const currTime = trimTimestamp(timestamp, granularity)
        if (currTime >= startTime && currTime <= endTime) {
            result.push(id)
        }
    }
    
    return result
};

/** 
 * Your LogSystem object will be instantiated and called as such:
 * var obj = new LogSystem()
 * obj.put(id,timestamp)
 * var param_2 = obj.retrieve(start,end,granularity)
 */
```

## 12. Integer to Roman
```javascript
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
    const numerals = [[1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], 
                      [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], 
                      [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'],[1, 'I']]
    
    const result = []
    for (const [val, numeral] of numerals) {
        const numeralCount = Math.trunc(num / val)
        result.push(numeral.repeat(numeralCount))
        num = num % val
    }
    
    return result.join('')
};
```

## 831. Masking Personal Information
```javascript
/**
 * @param {string} S
 * @return {string}
 */
var maskPII = function(S) {
    return isEmail(S) ? maskEmail(S) : maskPhoneNumber(S)
};

const maskEmail = str => {
    const [name, website] = str.toLowerCase().split('@')
    const result = [name[0], '*****', name[name.length - 1], '@', website]
    return result.join('')
}

const maskPhoneNumber = str => {
    const digits = str.split('').filter(char => isDigit(char))
    
    const countryMask = ['', '+*-', '+**-', '+***-']
    const countryCode = digits.slice(0, digits.length - 10)
    
    const localNumber = digits.slice(-10)
    const lastFourDigits = localNumber.slice(-4).join('')
    
    return `${countryMask[countryCode.length]}***-***-${lastFourDigits}`
}

const isEmail = str => {
    return str.split('@').length > 1
}

const isDigit = num => {
    return '0' <= num && num <= '9'
}
```

## 433. Minimum Genetic Mutation
```javascript
// Bidirectional BFS
/**
 * @param {string} start
 * @param {string} end
 * @param {string[]} bank
 * @return {number}
 */
var minMutation = function(start, end, bank) {
    if (start === end) return 0
    if (!bank.length) return -1
    
    const bankSet = new Set(bank)
    if (!bankSet.has(end)) return -1
    
    const queueStart = [start]
    const visitedStart = new Set([start])
    
    const queueEnd = [end]
    const visitedEnd = new Set([end])
    
    let level = 0
    while (queueStart.length && queueEnd.length) {
        if (bfs(queueStart, visitedStart, visitedEnd, bankSet))
            return level
            
        level++
        
        if (bfs(queueEnd, visitedEnd, visitedStart, bankSet))
            return level
            
        level++
    }
    
    return -1
};

const bfs = (queue, visited1, visited2, bankSet) => {
    const size = queue.length
    for (let i = 0; i < size; i++) {
        const vertex = queue.shift()
        if (visited2.has(vertex)) return true
        
        for (let i = 0; i < vertex.length; i++) {
            for (const choice of 'ACGT') {
                const neighbor = vertex.slice(0, i) + choice + vertex.slice(i + 1)
                if (vertex === neighbor || !bankSet.has(neighbor) || visited1.has(neighbor)) 
                    continue

                visited1.add(neighbor)
                queue.push(neighbor)
            }
        }
    }
    
    return false  
}
```

## 57. Insert Interval
```javascript
/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function(intervals, newInterval) {
    if (!intervals.length) return [newInterval]
    
    const result = []
    let inserted = false
    let mergeStart = newInterval[0]
    let mergeEnd = newInterval[1]
    
    for (let i = 0; i < intervals.length; i++) {
        const [currStart, currEnd] = intervals[i]
        
        if (currEnd < mergeStart) {
            result.push(intervals[i])
            continue
        }
        
        if (currStart > mergeEnd) {
            if (!inserted) {
                inserted = true
                result.push([mergeStart, mergeEnd])
            }
            
            result.push(intervals[i])
            continue
        }
        
        mergeStart = Math.min(mergeStart, currStart)
        mergeEnd = Math.max(mergeEnd, currEnd)
    }
    
    if (!inserted) {
        result.push([mergeStart, mergeEnd])
    }
    
    return result
};
```

## 468. Validate IP Address
```javascript
/**
 * @param {string} IP
 * @return {string}
 */
var validIPAddress = function(IP) {
    if (validIPv4(IP)) return 'IPv4'
    if (validIPv6(IP)) return 'IPv6'
    return 'Neither'
};

const validIPv4 = IP => {
    const groups = IP.split('.')
    if (groups.length !== 4) return false
    
    for (const group of groups) {
        if (!group.length || group.length > 1 && group[0] === '0') 
            return false
        
        let val = 0
        for (const char of group) {
            if (!isDigit(char)) return false
            val *= 10
            val += +char
        }
        
        if (val >= 256) return false
    }
    
    return true
}

const validIPv6 = IP => {
    const groups = IP.split(':')
    if (groups.length !== 8) return false
    
    for (const group of groups) {
        if (!group.length || group.length > 4) return false
        
        for (const char of group) {
            if (!isDigit(char) && !isValidLetter(char)) {
                return false
            }
        }
    }
    return true
}

const isDigit = char => {
    return '0' <= char && char <= '9'
}

const isValidLetter = char => {
    return 'a' <= char.toLowerCase() && char.toLowerCase() <= 'f'
}
```

## 1540. Can Convert String in K Moves
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @param {number} k
 * @return {boolean}
 */
var canConvertString = function(s, t, k) {
    if (s.length !== t.length) return false
    
    const diffMap = new Array(26).fill(0) // max diff is 0 -> 25 = 26
    for (let i = 0; i < s.length; i++) {
        if (s[i] === t[i]) continue
        
        const dist = getDist(s[i], t[i])
        if (dist > k) return false
        diffMap[dist]++
        
        if (dist + 26 * (diffMap[dist] - 1) > k) 
            return false
    }
    
    return true
};

const getDist = (charFrom, charTo) => {
    if (charFrom === charTo) return 0
    
    const indexFrom = charFrom.charCodeAt(0) - 'a'.charCodeAt(0) 
    const indexTo = charTo.charCodeAt(0) - 'a'.charCodeAt(0)
    
    if (indexFrom > indexTo) {
        return 26 - indexFrom + indexTo
    } else {
        return indexTo - indexFrom
    }
}
```

## 1642. Furthest Building You Can Reach
```javascript
// Heap
/**
 * @param {number[]} heights
 * @param {number} bricks
 * @param {number} ladders
 * @return {number}
 */
var furthestBuilding = function(heights, bricks, ladders) {
    const minHeap = new Heap()
    
    for (let i = 1; i < heights.length; i++) {
        const diff = heights[i] - heights[i - 1]
        if (diff <= 0) continue
        
        minHeap.insert(diff)
        if (minHeap.size() > ladders) {
            const minDist = minHeap.remove()
            bricks -= minDist
            
            if (bricks < 0) return i - 1
        }
    }
    
    return heights.length - 1
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    size() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}

// Binary Search
/**
 * @param {number[]} heights
 * @param {number} bricks
 * @param {number} ladders
 * @return {number}
 */
var furthestBuilding = function(heights, bricks, ladders) {
    const sortedDists = []
    for (let i = 1; i < heights.length; i++) {
        const dist = heights[i] - heights[i - 1]
        if (dist <= 0) continue
        sortedDists.push([dist, i])
    }
    
    sortedDists.sort((a, b) => a[0] - b[0])
    
    let low = 0
    let high = heights.length - 1
    while (low < high) {
        const mid = Math.floor((high - low + 1) / 2) + low
        
        if (canReach(sortedDists, mid, bricks, ladders)) {
            low = mid
        } else {
            high = mid - 1
        }
    }
    
    return low
};

const canReach = (dists, endIndex, bricks, ladders) => {
    for (const [dist, index] of dists) {
        if (index > endIndex) continue
        
        if (dist <= bricks) {
            bricks -= dist
        } else if (ladders > 0) {
            ladders--
        } else {
            return false
        }    
    }
    
    return true
}
```

## 656. Coin Path
```javascript
/**
 * @param {number[]} A
 * @param {number} B
 * @return {number[]}
 */
var cheapestJump = function(A, B) {
    const _cheapestJump = (start) => {
        if (A[start] === -1) {
            return Infinity
        }
        
        if (memo[start] !== undefined) {
            return memo[start]
        }
        
        if (start === A.length - 1) {
            return 0
        }
        
        let minCost = Infinity
        let minIndex = -1
        for (let i = start + 1; i <= Math.min(A.length - 1, start + B); i++) {
            const result = _cheapestJump(i)
            if (minCost > result) {
                minCost = result
                minIndex = i
            }
        }
        
        next[start] = minIndex
        memo[start] = A[start] + minCost
        return memo[start]
    }
    
    const next = new Array(A.length).fill(-1)
    const memo = new Array(A.length)
    const result = _cheapestJump(0)
    if (result === Infinity) {
        return []
    }
    
    const path = [1]
    for (let i = 0; i < A.length && next[i] >= 0; i = next[i]) {
        path.push(next[i] + 1) // result is 1 indexed
    }
    return path
};
```

## 1377. Frog Position After T Seconds
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} t
 * @param {number} target
 * @return {number}
 */
var frogPosition = function(n, edges, t, target) {    
    const dfs = (vertex, t, prob) => {
        if (t === 0) return vertex === target ? prob : 0
        
        const validNeighbors = graph[vertex].filter(neighbor => !visited[neighbor])
        if (validNeighbors.length === 0) {
            return dfs(vertex, 0, prob)
        }
        
        for (const neighbor of validNeighbors) {
            visited[neighbor] = true

            const currProb = 1 / validNeighbors.length
            const result = dfs(neighbor, t - 1, prob * currProb)
            if (result !== 0) return result
        }
        
        return 0
    }
    
    const graph = new Array(n + 1).fill().map(a => [])
    for (const [u, v] of edges) {
        graph[u].push(v)
        graph[v].push(u)
    }
    
    const visited = new Array(n)
    visited[1] = true
    return dfs(1, t, 1)
};
```

## 1673. Find the Most Competitive Subsequence
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var mostCompetitive = function(nums, k) {
    const stack = []
    
    for (let i = 0; i < nums.length; i++) {
        if (!stack.length) {
            stack.push(nums[i])
            continue
        }
        
        while (stack.length && 
               stack[stack.length - 1] > nums[i] && 
               nums.length - i - 1 >= k - stack.length) {
            stack.pop()
        }
        
        if (stack.length < k) {
            stack.push(nums[i])
        }
    }
    
    return stack
};
```

## 1683. Invalid Tweets
```sql
# Write your MySQL query statement below
SELECT tweet_id
FROM Tweets
WHERE CHAR_LENGTH(content) > 15
```

## 316. Remove Duplicate Letters
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicateLetters = function(s) {
    const map = {}
    for (let i = 0; i < s.length; i++) {
        map[s[i]] = i
    }
    
    const stack = []
    let used = 0
    for (let i = 0; i < s.length; i++) {
        if (used & maskForChar(s[i])) continue
        
        while (stack.length && 
               stack[stack.length - 1] > s[i] && 
               map[stack[stack.length - 1]] > i) {
            
            used ^= maskForChar(stack[stack.length - 1])
            stack.pop()
        }
        
        used |= maskForChar(s[i])
        stack.push(s[i])
    }
    
    return stack.join('')
};

const maskForChar = char => 1 << (char.charCodeAt(0) - 'a'.charCodeAt(0))
```

## 1081. Smallest Subsequence of Distinct Characters
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var smallestSubsequence = function(s) {
    const map = {}
    for (let i = 0; i < s.length; i++) {
        map[s[i]] = i
    }
    
    const stack = []
    let used = 0
    for (let i = 0; i < s.length; i++) {
        if (used & maskForChar(s[i])) continue
        
        while (stack.length && 
               stack[stack.length - 1] > s[i] && 
               map[stack[stack.length - 1]] > i && 
               !(used & maskForChar(s[i]))) {
            
            used ^= maskForChar(stack[stack.length - 1])
            stack.pop()
        }
        
        used |= maskForChar(s[i])
        stack.push(s[i])
    }
    
    return stack.join('')
};

const maskForChar = char => 1 << (char.charCodeAt(0) - 'a'.charCodeAt(0))
```

## 856. Score of Parentheses
```javascript
/**
 * @param {string} S
 * @return {number}
 */
var scoreOfParentheses = function(S) {
    const stack = []
    let score = 0
    for (const char of S) {
        if (char === '(') {
            stack.push(char)
            continue
        }
        
        if (stack[stack.length - 1] === '(') {
            stack.pop()
            stack.push(1)
            continue
        }
        
        let sum = 0
        while (stack[stack.length - 1] !== '(') {
            sum += stack.pop()
        }

        stack.pop()
        stack.push(2 * sum)
    }
    
    let sum = 0
    while (stack.length) {
        sum += stack.pop()
    }
    return sum
};
```

## 901. Online Stock Span
```javascript

var StockSpanner = function() {
    this.stack = []
    this.day = 0
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function(price) {
    while (this.stack.length && price >= this.stack[this.stack.length - 1][0]) {
        this.stack.pop()
    }
    
    if (!this.stack.length) {
        this.stack.push([price, this.day++])
        return this.day
    }
    
    const [topVal, topDay] = this.stack[this.stack.length - 1]
    this.stack.push([price, this.day])
    
    const span = this.day++ - topDay
    return span
};

/** 
 * Your StockSpanner object will be instantiated and called as such:
 * var obj = new StockSpanner()
 * var param_1 = obj.next(price)
 */
```

## 1669. Merge In Between Linked Lists
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {number} a
 * @param {number} b
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeInBetween = function(list1, a, b, list2) {
    let curr = list1
    let i = 1
    while (i < a && curr) {
        curr = curr.next
        i++
    }
    
    let prevA = curr
    while (i <= b + 1 && curr) {
        curr = curr.next
        i++
    }
    
    let nextB = curr
    prevA.next = list2
    curr = prevA
    while (curr && curr.next) {
        curr = curr.next
    }
    
    curr.next = nextB
    return list1
};
```

## 1634. Add Two Polynomials Represented as Linked Lists
```javascript
/**
 * Definition for polynomial singly-linked list.
 * function PolyNode(x=0, y=0, next=null) {
 *     this.coefficient = x;
 *     this.power = y;
 *     this.next = next;
 * }
 */

/**
 * @param {PolyNode} poly1
 * @param {PolyNode} poly2
 * @return {PolyNode}
 */
var addPoly = function(poly1, poly2) {
    const dummy = new PolyNode(NaN, NaN)
    let curr = dummy
    
    while (poly1 && poly2) {
        if (poly1.power < poly2.power) {
            curr.next = poly2
            curr = curr.next
            poly2 = poly2.next
        } else if (poly1.power > poly2.power) {
            curr.next = poly1
            curr = curr.next
            poly1 = poly1.next
        } else {
            if (poly1.coefficient + poly2.coefficient !== 0) {
                const sum = poly1.coefficient + poly2.coefficient
                curr.next = new PolyNode(sum, poly1.power)
                curr = curr.next
            }
            
            poly1 = poly1.next
            poly2 = poly2.next
        }
    }
    
    curr.next = null
  
    if (poly1) curr.next = poly1
    if (poly2) curr.next = poly2
    
    return dummy.next
};
```

## 1684. Count the Number of Consistent Strings
```javascript
/**
 * @param {string} allowed
 * @param {string[]} words
 * @return {number}
 */
var countConsistentStrings = function(allowed, words) {
    const allowedMask = maskForStr(allowed)
    
    let count = 0
    for (const word of words) {
        const wordMask = maskForStr(word)
        if ((allowedMask | wordMask) === allowedMask) {
            count++
        }
    }
    
    return count
};

const maskForStr = str => {
    let mask = 0
    for (const char of str) {
        const index = indexForChar(char)
        mask |= 1 << index
    }
    return mask
}

const indexForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
```

## 957. Prison Cells After N Days
```javascript
/**
 * @param {number[]} cells
 * @param {number} N
 * @return {number[]}
 */
var prisonAfterNDays = function(cells, N) {
    const size = cells.length
    const memo = []
    
    let state = arrToBin(cells, size)
    while (N--) { // Day 0 can't be part of cycle
        state = getNextState(state)
        
        if (memo[0] === state) { // Has reached beginning of cycle
            const cycleSize = memo.length
            const finalState = memo[N % cycleSize]
            return binToArr(finalState, size)
        }
        
        memo.push(state)
    }
    
    return binToArr(state, size)
};

/*
Bit Operation Explanation:
https://leetcode.com/problems/prison-cells-after-n-days/discuss/718530/C%2B%2B-bitwise-operations-%2B-cycle-detection-or-explanation-on-bit-operations
*/

const getNextState = state => {
    return ~((state << 1) ^ (state >> 1)) & 0b01111110
}

const binToArr = (bin, size) => {
    const arr = new Array(size)
    for (let i = 0; i < size; i++) {
        arr[i] = bin & 1 << (size - i - 1) ? 1 : 0
    }
    return arr
}

const arrToBin = (arr, size) => {
    let bin = 0
    for (let i = 0; i < arr.length; i++) {
        bin |= arr[i] << (size - i - 1)
    }
    return bin
}
```

## 895. Maximum Frequency Stack
```javascript

var FreqStack = function() {
    this.eleToFreqMap = {}
    this.freqToEleMap = {}
    this.maxFreq = 0
};

/** 
 * @param {number} x
 * @return {void}
 */
FreqStack.prototype.push = function(x) {
    this.eleToFreqMap[x] = 1 + (this.eleToFreqMap[x] || 0)
    
    const currFreq = this.eleToFreqMap[x]
    if (currFreq > this.maxFreq) {
        this.maxFreq = currFreq
    }
    
    if (this.freqToEleMap[currFreq] === undefined) {
        this.freqToEleMap[currFreq] = []
    }
    
    this.freqToEleMap[currFreq].push(x)
};

/**
 * @return {number}
 */
FreqStack.prototype.pop = function() {
    const ele = this.freqToEleMap[this.maxFreq].pop()
    this.eleToFreqMap[ele]--
    
    if (this.freqToEleMap[this.maxFreq].length === 0) {
        this.freqToEleMap[this.maxFreq]
        this.maxFreq--
    }
    
    return ele
};

/** 
 * Your FreqStack object will be instantiated and called as such:
 * var obj = new FreqStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 */
```

## 1268. Search Suggestions System
```javascript
/**
 * @param {string[]} products
 * @param {string} searchWord
 * @return {string[][]}
 */
var suggestedProducts = function(products, searchWord) {
    const k = 3
    const trie = new Trie(products)
    
    const result = []
    let prefix = []
    for (const char of searchWord) {
        prefix.push(char)
        result.push(trie.getKWords(prefix, k))
    }
    
    return result
};

class Trie {
    constructor(words) {
        this.root = new TrieNode('')
        
        if (words.length) {
            for (const word of words) {
                this.insert(word)
            }
        }
    }
    
    insert(word) {
        let curr = this.root
        for (const char of word) {
            const index = indexForChar(char)
            if (curr.children[index] === undefined) {
                curr.children[index] = new TrieNode(char)
            }
            curr = curr.children[index]
        }
        
        curr.word = word
    }
    
    getKWords(prefix, k) {
        let curr = this.root
        for (const char of prefix) {
            const index = indexForChar(char)
            if (curr.children[index] === undefined) {
                return []
            }
            curr = curr.children[index]
        }
        
        const result = []
        this._dfs(curr, result, k)
        return result
    }
    
    _dfs(trieNode, result, k) {
        if (result.length === k) return
        
        if (trieNode.word !== '') {
            result.push(trieNode.word)
        }
        
        for (const child of trieNode.children) {
            if (child === undefined) continue
            this._dfs(child, result, k)
        }       
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = new Array(26)
        this.word = ''
    }
}

const indexForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
```

## 1578. Minimum Deletion Cost to Avoid Repeating Letters
```javascript
/**
 * @param {string} s
 * @param {number[]} cost
 * @return {number}
 */
var minCost = function(s, cost) {
    let min = 0
    let currChar = ''
    let currCharMaxCost = 0
    for (let i = 0; i <= s.length; i++) {
        min += (cost[i] || 0)
        
        if (s[i] !== currChar) {
            min -= currCharMaxCost    
            currChar = s[i]
            currCharMaxCost = cost[i]
        } else {
            currCharMaxCost = Math.max(currCharMaxCost, cost[i])
        }
    }
    
    return min
};
```

## 495. Teemo Attacking
```javascript
/**
 * @param {number[]} timeSeries
 * @param {number} duration
 * @return {number}
 */
var findPoisonedDuration = function(timeSeries, duration) {
    if (!timeSeries.length) return 0
    
    let totalTime = 0
    let prevStart = timeSeries[0]
    let prevEnd = prevStart + duration - 1
    
    for (let i = 1; i < timeSeries.length; i++) {
        const currStart = timeSeries[i]
        const currEnd = timeSeries[i] + duration - 1
        
        if (currStart > prevEnd) {
            totalTime += prevEnd - prevStart + 1
            prevStart = currStart
        }
        
        prevEnd = currEnd
    }
    
    totalTime += prevEnd - prevStart + 1
    return totalTime
};
```

## 117. Populating Next Right Pointers in Each Node II
```javascript
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    let leftmost = root
    let curr = leftmost
    let prev = null
    
    while (leftmost) {
        prev = null
        curr = leftmost
        leftmost = null
        
        while (curr) {
            if (curr.left) {
                if (prev) {
                    prev.next = curr.left
                } else {
                    leftmost = curr.left
                }

                prev = curr.left
            }
            
            if (curr.right) {
                if (prev) {
                    prev.next = curr.right
                } else {
                    leftmost = curr.right
                }

                prev = curr.right
            }
            
            curr = curr.next
        }
    }
    
    return root
};
```

## 1688. Count of Matches in Tournament
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numberOfMatches = function(n) {
    let matches = 0
    
    while (n > 1) {
        matches += Math.trunc(n / 2)
        
        if (n % 2 === 0) {
            n /= 2
        } else {
            n = Math.trunc(n / 2) + 1
        }
    }
    
    return matches
};
```

## 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
```javascript
/**
 * @param {string} n
 * @return {number}
 */
var minPartitions = function(n) {
    return Math.max(...n)
};
```

## 974. Subarray Sums Divisible by K
```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var subarraysDivByK = function(A, K) {
    const remainders = new Array(K).fill(0)
    remainders[0] = 1
    
    let count = 0
    let sum = 0
    for (const num of A) {
        sum += num
        
        let rem = sum % K
        if (rem < 0) rem += K
        
        count += remainders[rem]
        remainders[rem]++
    }
    
    return count
};
```

## 1034. Coloring A Border
```javascript
/**
 * @param {number[][]} grid
 * @param {number} r0
 * @param {number} c0
 * @param {number} color
 * @return {number[][]}
 */
var colorBorder = function(grid, r0, c0, color) {
    const dfs = (row, col) => {
        let onBorder = false
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = row + deltaRow
            const nextCol = col + deltaCol
            
            if (nextRow < 0 || nextCol < 0 || 
                nextRow >= m || nextCol >= n || 
                grid[nextRow][nextCol] !== grid[row][col]) {
                onBorder = true
                continue
            }
            
            if (visited[nextRow][nextCol]) continue
            visited[nextRow][nextCol] = 1
            dfs(nextRow, nextCol)
        }
        
        if (onBorder) borderCoordinates.push([row, col])
    }
    
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    const m = grid.length
    const n = grid[0].length
    
    const visited = new Array(m).fill().map(a => new Array(n).fill(0))
    visited[r0][c0] = 1
    
    const borderCoordinates = []
    dfs(r0, c0)
    
    for (const [row, col] of borderCoordinates) {
        grid[row][col] = color
    }
    
    return grid
};
```

## 473. Matchsticks to Square
```javascript
// Backtracking - O(4^n)
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var makesquare = function(nums) {
    const _makesquare = (i) => {
        // if first 3 all equal target then last has to as well
        // because sum % 4 === 0 check already happened
        if (sums[0] === targetSum && 
            sums[1] === targetSum && 
            sums[2] === targetSum) return true 
        
        if (i >= nums.length) {
            return sums[0] === sums[1] && 
                   sums[1] === sums[2] && 
                   sums[2] === sums[3]
        }
        
        for (let k = 0; k < sums.length; k++) {
            if (sums[k] + nums[i] > targetSum) continue
            sums[k] += nums[i]
            if (_makesquare(i + 1)) return true    
            sums[k] -= nums[i]
        }
        
        return false
    }
    
    if (!nums.length) return []
    
    let totalSum = 0
    for (const num of nums) {
        totalSum += num
    }
    
    if (totalSum % 4 !== 0) 
        return false
    
    const targetSum = totalSum / 4
    for (const num of nums) {
        if (num > targetSum) return false
    }
    
    nums.sort((a, b) => b - a)
    const sums = new Array(4).fill(0)
    return _makesquare(0)
};
```

## 1666. Change the Root of a Binary Tree
```javascript
/**
 * // Definition for a Node.
 * function Node(val) {
 *    this.val = val;
 *    this.left = null;
 *    this.right = null;
 *    this.parent = null;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var flipBinaryTree = function(root, leaf) {
    const process = (node, newParent) => {
        const oldParent = node.parent
        node.parent = newParent
        
        if (node.left === newParent) node.left = null
        if (node.right === newParent) node.right = null
        
        if (node === root) return node
        
        if (node.left != null) node.right = node.left
        node.left = process(oldParent, node)

        return node
    }
    
    return process(leaf, null)
};
```

## 1339. Maximum Product of Splitted Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxProduct = function(root) {
    const MOD = 10 ** 9 + 7
    const totalSum = getSum(root)
    return getMax(root, totalSum) % MOD
};

const getSum = node => {
    if (!node) return 0
    return node.val + getSum(node.left) + getSum(node.right)
}

const getMax = (root, totalSum) => {
    const dfs = node => {
        if (!node) return 0
        
        const sum = node.val + dfs(node.left) + dfs(node.right)
        const split1 = totalSum - sum
        const split2 = sum
        const product = split1 * split2
        
        max = Math.max(max, product)
        return sum
    }
    
    let max = 0
    dfs(root)
    return max
}
```

## 514. Freedom Trail
```javascript
// Top Down DP = O(K * R^2)
/**
 * @param {string} ring
 * @param {string} key
 * @return {number}
 */
var findRotateSteps = function(ring, key) {
    const _findRotateSteps = (i, j) => {
        if (j >= key.length) return 0
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }
        
        let min = Infinity
        
        const charIndex = indexForChar(key[j])
        for (const position of positions[charIndex]) {
            const leftDist = Math.abs(position - i)
            const rightDist = ring.length - leftDist
            const minDist = Math.min(leftDist, rightDist)
            min = Math.min(min, 1 + minDist + _findRotateSteps(position, j + 1))
        }
        
        memo[i][j] = min
        return min
    }
    
    const m = ring.length
    const n = key.length
    const memo = new Array(m).fill().map(a => new Array(n).fill())
    
    const positions = new Array(26).fill().map(a => [])
    for (let i = 0; i < ring.length; i++) {
        const charIndex = indexForChar(ring[i])
        positions[charIndex].push(i)
    }
    
    return _findRotateSteps(0, 0)
};

const indexForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
```

## 1559. Detect Cycles in 2D Grid
```javascript
/**
 * @param {character[][]} grid
 * @return {boolean}
 */
var containsCycle = function(grid) {
    const m = grid.length
    const n = grid[0].length
    const visited = new Array(m).fill().map(a => new Array(n).fill(false))
    
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (!visited[row][col] && isCyclic(row, col, grid, visited)) {
                return true
            }
        }
    }
    
    return false
};

const isCyclic = (row, col, grid, visited) => {
    const dfs = (row, col, prevRow, prevCol) => {
        visited[row][col] = true
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = row + deltaRow
            const nextCol = col + deltaCol
            
            if (nextRow < 0 || nextCol < 0 || nextRow >= m || nextCol >= n)
                continue
            
            if (grid[nextRow][nextCol] !== color)
                continue
            
            if (nextRow === prevRow && nextCol === prevCol)
                continue
            
            if (visited[nextRow][nextCol]) 
                return true
            
            if (dfs(nextRow, nextCol, row, col))
                return true
        }
        
        return false
    }
    
    const m = grid.length
    const n = grid[0].length
    const color = grid[row][col]
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    return dfs(row, col, -1, -1)
}
```

## 968. Binary Tree Cameras
```javascript
// Top Down DP
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minCameraCover = function(root) {
    const dfs = (node, nodeSet, parentSet) => {
        if (!node) return nodeSet ? Infinity : 0
        
        if (!node.left && !node.right) {
            if (nodeSet) return 1
            if (parentSet) return 0
            return Infinity
        }
        
        if (ids.get(node) === undefined) {
            ids.set(node, id++)
        }
        
        const nodeID = ids.get(node)
        if (memo[nodeID][nodeSet][parentSet] !== undefined) {
            return memo[nodeID][nodeSet][parentSet]
        }
        
        if (nodeSet) {
            const leftMin = Math.min(dfs(node.left, 1, 1), dfs(node.left, 0, 1))
            const rightMin = Math.min(dfs(node.right, 1, 1), dfs(node.right, 0, 1))
            memo[nodeID][nodeSet][parentSet] = 1 + leftMin + rightMin
            return memo[nodeID][nodeSet][parentSet]
        }
        
        if (parentSet) {
            const leftMin = Math.min(dfs(node.left, 1, 0), dfs(node.left, 0, 0))
            const rightMin = Math.min(dfs(node.right, 1, 0), dfs(node.right, 0, 0))
            memo[nodeID][nodeSet][parentSet] = leftMin + rightMin
            return memo[nodeID][nodeSet][parentSet]
        }
        
        const op1 = dfs(node.left, 1, 0) + Math.min(dfs(node.right, 0, 0), dfs(node.right, 1, 0))
        const op2 = dfs(node.right, 1, 0) + Math.min(dfs(node.left, 0, 0), dfs(node.left, 1, 0))
        memo[nodeID][nodeSet][parentSet] = Math.min(op1, op2)
        return memo[nodeID][nodeSet][parentSet]
    }
    
    const ids = new WeakMap()
    let id = 0
    
    const memo = new Array(1001).fill()
                        .map(a => new Array(2).fill()
                        .map(a => new Array(2)))
    return Math.min(dfs(root, 1, 0), dfs(root, 0, 0))
};
```

## 679. 24 Game
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var judgePoint24 = function(nums) {
    const _judgePoint24 = (nums) => {
        if (nums.length === 1) 
            // To deal with floating point rounding errors we need to check within range of 0.001
            // For example: 8 / 3 = 2.666666 repeating but in floating point is 2.6666666666666665
            return Math.abs(nums[0] - 24) < 0.001 
        }
        
        for (let i = 0; i < nums.length; i++) {
            for (let j = i + 1; j < nums.length; j++) {
                const operations = [nums[i] + nums[j], 
                                    nums[i] - nums[j], 
                                    nums[j] - nums[i], 
                                    nums[i] * nums[j]]
                
                if (nums[j] !== 0) operations.push(nums[i] / nums[j])
                if (nums[i] !== 0) operations.push(nums[j] / nums[i])
                
                const result = []
                for (let k = 0; k < nums.length; k++) {
                    if (k === i || k === j) continue
                    result.push(nums[k])
                }
                
                for (const operation of operations) {
                    result.push(operation)
                    
                    if (_judgePoint24(result)) {
                        return true
                    }
                    
                    result.pop()
                }
            }
        }
        
        return false
    }
    
    return _judgePoint24(nums)
};
```

## 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree
```javascript
// Time: O(E^2)
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[][]}
 */
var findCriticalAndPseudoCriticalEdges = function(n, edges) {
    const sortedEdges = bucketSort(edges)
    const mstCost = kruskals(n, sortedEdges, null, null)
    
    const critical = []
    const pseudoCritical = []
    for (let i = 0; i < edges.length; i++) {
        const edge = edges[i]
        const excludeCost = kruskals(n, sortedEdges, null, edge)
        if (excludeCost !== mstCost) {
            critical.push(i)
            continue
        }
        
        const includeCost = kruskals(n, sortedEdges, edge, null)
        if (includeCost > mstCost) {
            continue
        }
        
        pseudoCritical.push(i)
    }
    
    return [critical, pseudoCritical]
};

const kruskals = (n, edges, includedEdge, excludedEdge) => {
    let cost = 0
    const unionFind = new UnionFind(n)
    
    if (includedEdge) {
        const [u, v, weight] = includedEdge
        unionFind.union(u, v)
        cost += weight
    }
    
    for (const edge of edges) {
        if (edge === excludedEdge) continue
        
        const [u, v, weight] = edge
        if (unionFind.connected(u, v)) continue
        cost += weight
        unionFind.union(u, v)
    }
    
    return cost
}

class UnionFind {
    constructor(size) {
        this.sizes = new Array(size).fill(1)
        this.parents = new Array(size)
        for (let i = 0; i < size; i++) {
            this.parents[i] = i
        }
    }
    
    union(u, v) {
        const uRoot = this.find(u)
        const vRoot = this.find(v)
        
        if (uRoot === vRoot) return
        
        if (this.sizes[uRoot] < this.sizes[vRoot]) {
            this.sizes[vRoot] += this.sizes[uRoot]
            this.parents[uRoot] = vRoot
        } else {
            this.sizes[uRoot] += this.sizes[vRoot]
            this.parents[vRoot] = uRoot
        }
    }
    
    find(u) {
        let root = u
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (u !== root) {
            const next = this.parents[u]
            this.parents[u] = root
            u = next
        }
        
        return root
    }
    
    connected(u, v) {
        return this.find(u) === this.find(v)
    }
}

const bucketSort = edges => {
    const buckets = new Array(1001)
    for (const edge of edges) {
        const weight = edge[2]
        
        if (!buckets[weight]) {
            buckets[weight] = []
        }
        
        buckets[weight].push(edge)
    }
    
    const result = []
    for (let i = 0; i < buckets.length; i++) {
        if (!buckets[i]) continue
        
        for (const edge of buckets[i]) {
            result.push(edge)
        }
    }
    
    return result
} 
```

## 1028. Recover a Tree From Preorder Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {string} S
 * @return {TreeNode}
 */
var recoverFromPreorder = function(S) {
    const _recoverFromPreorder = () => {
        const [currVal, currLevel] = nodeLevels[i++]
        const node = new TreeNode(currVal)
        
        // Left
        if (i >= nodeLevels.length) return node
        const [nextLeftVal, nextLeftLevel] = nodeLevels[i]
        if (nextLeftLevel <= currLevel) return node
        node.left = _recoverFromPreorder()
        
        // Right
        if (i >= nodeLevels.length) return node
        const [nextRightVal, nextRightLevel] = nodeLevels[i]
        if (nextRightLevel <= currLevel) return node
        node.right = _recoverFromPreorder()
        
        return node
    }
    
    let i = 0
    const nodeLevels = formatNodeLevels(S)
    return _recoverFromPreorder()
};

const formatNodeLevels = s => {
    const nodeLevels = []
    
    let i = 0
    while (i < s.length) {
        let currLevel = 0
        while (s[i] === '-') {
            currLevel++
            i++
        }
        
        let val = 0
        while (s[i] >= '0' && s[i] <= '9') {
            val *= 10
            val += +s[i]
            i++
        }
        
        nodeLevels.push([val, currLevel])
    }
    
    return nodeLevels
}
```

## 1516. Move Sub-Tree of N-Ary Tree
```javascript
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val === undefined ? 0 : val;
 *    this.children = children === undefined ? [] : children;
 * };
 */

/**
 * @param {Node} root
 * @param {Node} p
 * @param {Node} q
 * @return {Node}
 */
var moveSubTree = function(root, p, q) {
    const parentMap = getParents(root)
    if (parentMap.get(p) === q) return root
    
    q.children.push(p)
    
    if (isDescendent(q, p, parentMap)) {
        const qParent = parentMap.get(q)
        qParent.children = qParent.children.filter(child => child !== q)
        
        const pParent = parentMap.get(p)
        if (!pParent) return q
        
        for (let i = 0; i < pParent.children.length; i++) {
            if (pParent.children[i] === p) {
                pParent.children[i] = q
                break
            }
        }
        
        return root
    }
    
    const pParent = parentMap.get(p)
    pParent.children = pParent.children.filter(child => child !== p)
    return root
};

const isDescendent = (node1, node2, parentMap) => {
    while (node1) {
        node1 = parentMap.get(node1)
        if (node1 === node2) return true
    }
    return false
}

const getParents = root => {
    const _getParents = (node, parent) => {
        if (!node) return
        
        parentMap.set(node, parent)
        
        for (const child of node.children) {
            _getParents(child, node)
        }
    }
    
    const parentMap = new Map()
    _getParents(root, null)
    return parentMap
}
```

## 998. Maximum Binary Tree II
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var insertIntoMaxTree = function(root, val) {
    if (!root) return new TreeNode(val)
    
    if (root.val < val) {
        const node = new TreeNode(val)
        node.left = root
        return node
    }
    
    root.right = insertIntoMaxTree(root.right, val)
    return root
};
```

## 554. Brick Wall
```javascript
/**
 * @param {number[][]} wall
 * @return {number}
 */
var leastBricks = function(wall) {
    const edges = {}
    let max = 0
    for (let i = 0; i < wall.length; i++) {
        let sumWidth = 0
        for (let j = 0; j < wall[i].length - 1; j++) {
            sumWidth += wall[i][j]
            edges[sumWidth] = 1 + (edges[sumWidth] || 0)
            max = Math.max(max, edges[sumWidth])
        }
    }
    
    return wall.length - max
};
```

## 939. Minimum Area Rectangle
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var minAreaRect = function(points) {
    const seen = new Set()
    for (const point of points) {
        const [x, y] = point
        seen.add(`${x}-${y}`)
    }
    
    let minArea = Infinity
    for (let i = 0; i < points.length; i++) {
        for (let j = i + 1; j < points.length; j++) {
            const [x1, y1] = points[i]
            const [x2, y2] = points[j]
            
            if (x1 === x2 || y1 === y2) continue
            
            if (seen.has(`${x1}-${y2}`) && seen.has(`${x2}-${y1}`)) {
                const height = Math.abs(y2 - y1)
                const width = Math.abs(x2 - x1)
                minArea = Math.min(minArea, height * width)
            }
        }
    }
    
    return minArea === Infinity ? 0 : minArea
};
```

## 954. Array of Doubled Pairs
```javascript
/**
 * @param {number[]} A
 * @return {boolean}
 */
var canReorderDoubled = function(A) {
    A.sort((a, b) => {
        if (Math.abs(a) === Math.abs(b)) {
            return a - b
        }
        
        return Math.abs(a) - Math.abs(b)
    })
    
    let j = 0
    for (let i = 0; i < A.length; i++) {
        if (A[i] === null) continue
        
        while (j < A.length && A[j] !== 2 * A[i]) {
            j++
        }
        
        if (j >= A.length) {
            return false
        }
        
        A[j] = null
    }
    
    return true
};
```

## 1418. Display Table of Food Orders in a Restaurant
```javascript
/**
 * @param {string[][]} orders
 * @return {string[][]}
 */
var displayTable = function(orders) {
    const foods = new Set()
    for (const [name, table, food] of orders) {
        foods.add(food)
    }
    
    const sortedFoods = Array.from(foods).sort()
    
    const foodMap = {}
    for (let i = 0; i < sortedFoods.length; i++) {
        foodMap[sortedFoods[i]] = i
    }
    
    const header = ['Table', ...sortedFoods]
    const tableMap = {}
    for (const [name, table, food] of orders) {
        if (tableMap[table] === undefined) {
            tableMap[table] = [table, ...new Array(sortedFoods.length).fill("0")]
        }
        
        tableMap[table][foodMap[food] + 1] = `${1 + +tableMap[table][foodMap[food] + 1]}`
    }
    
    return [header, ...Object.values(tableMap)]
};
```

## 525. Contiguous Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxLength = function(nums) {
    const map = { 0: -1 }
    let max = 0
    let prefix = 0
    for (let i = 0; i < nums.length; i++) {
        prefix += nums[i] ? 1 : -1
        
        if (map[prefix] !== undefined) {
            max = Math.max(max, i - map[prefix])
        } else {
            map[prefix] = i
        }
    }
    
    return max
};
```

## 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var numTriplets = function(nums1, nums2) {
    let count = 0
    let memo = {}
    for (const num of nums1) {
        const target = num ** 2
        if (memo[target] === undefined) {
            memo[target] = twoProduct(num ** 2, nums2)
        }
        
        count += memo[target]
    }
    
    memo = {}
    for (const num of nums2) {
        const target = num ** 2
        if (memo[target] === undefined) {
            memo[target] = twoProduct(num ** 2, nums1)
        }
        
        count += memo[target]
    }
    
    return count
};

const twoProduct = (target, nums) => {
    let count = 0
    const seen = {}
    for (const num of nums) {
        const compliment = target / num
        if (seen[compliment] !== undefined) {
            count += seen[compliment]
        }
        
        if (seen[num] === undefined) {
            seen[num] = 0
        }
        
        seen[num]++
    }
    
    return count
}
```

## 1476. Subrectangle Queries
```javascript
/**
 * @param {number[][]} rectangle
 */
var SubrectangleQueries = function(rectangle) {
    this.rectangle = rectangle
    this.history = []
};

/** 
 * @param {number} row1 
 * @param {number} col1 
 * @param {number} row2 
 * @param {number} col2 
 * @param {number} newValue
 * @return {void}
 */
SubrectangleQueries.prototype.updateSubrectangle = function(row1, col1, row2, col2, newValue) {
    this.history.push([row1, col1, row2, col2, newValue])
};

/** 
 * @param {number} row 
 * @param {number} col
 * @return {number}
 */
SubrectangleQueries.prototype.getValue = function(row, col) {
    for (let i = this.history.length - 1; i >= 0; i--) {
        const [row1, col1, row2, col2, newValue] = this.history[i]
        
        if (row1 <= row && row <= row2 && col1 <= col && col <= col2) {
            return newValue
        }
    }
    
    return this.rectangle[row][col]
};

/** 
 * Your SubrectangleQueries object will be instantiated and called as such:
 * var obj = new SubrectangleQueries(rectangle)
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue)
 * var param_2 = obj.getValue(row,col)
 */
```

## 781. Rabbits in Forest
```javascript
/**
 * @param {number[]} answers
 * @return {number}
 */
var numRabbits = function(answers) {
    const map = new Array(1000).fill(0)
    for (const answer of answers) {
        map[answer]++
    }
    
    let count = 0
    for (let i = 0; i < map.length; i++) {
        if (map[i] === 0) continue
        const size = i + 1
        const numberOfSize = Math.ceil(map[i] / size)
        count += numberOfSize * size
    }
    
    return count
}
```

## 966. Vowel Spellchecker
```javascript
/**
 * @param {string[]} wordlist
 * @param {string[]} queries
 * @return {string[]}
 */
var spellchecker = function(wordlist, queries) {
    const perfectMatch = new Set()
    const capitalMatch = {}
    const vowelMatch = {}
    
    for (const word of wordlist) {
        perfectMatch.add(word)
        
        const lowercase = word.toLowerCase()
        if (capitalMatch[lowercase] === undefined) {
            capitalMatch[lowercase] = word
        }
        
        const withoutVowels = removeVowels(lowercase)
        if (vowelMatch[withoutVowels] === undefined) {
            vowelMatch[withoutVowels] = word
        }
    }
    
    const result = []
    for (const query of queries) {
        if (perfectMatch.has(query)) {
            result.push(query)
            continue
        }
        
        const lowercase = query.toLowerCase()
        if (capitalMatch[lowercase]) {
            result.push(capitalMatch[lowercase])
            continue
        }
        
        const withoutVowels = removeVowels(lowercase)
        if (vowelMatch[withoutVowels]) {
            result.push(vowelMatch[withoutVowels])
            continue
        }
        
        result.push('')
    }
    
    return result
};

const removeVowels = str => {
    return str.split('').map(char => isVowel(char) ?  '*' : char).join('')
}

const isVowel = char => {
    return 'aeiou'.includes(char)
}
```

## 1166. Design File System
```javascript

var FileSystem = function() {
    this.trie = new Trie()
};

/** 
 * @param {string} path 
 * @param {number} value
 * @return {boolean}
 */
FileSystem.prototype.createPath = function(path, value) {
    const dirs = path.split('/')
    return this.trie.insert(dirs, value)
};

/** 
 * @param {string} path
 * @return {number}
 */
FileSystem.prototype.get = function(path) {
    const dirs = path.split('/')
    return this.trie.find(dirs)
};

/** 
 * Your FileSystem object will be instantiated and called as such:
 * var obj = new FileSystem()
 * var param_1 = obj.createPath(path,value)
 * var param_2 = obj.get(path)
 */

class Trie {
    constructor() {
        this.root = new TrieNode()
    }
    
    insert(dirs, value) {
        let curr = this.root
        for (let i = 0; i < dirs.length; i++) {
            if (dirs[i] === '') continue
            
            if (curr.children[dirs[i]] === undefined) {
                if (i !== dirs.length - 1) return false
                curr.children[dirs[i]] = new TrieNode(dirs[i])
            }
            
            curr = curr.children[dirs[i]]
        }
        
        if (curr.value === -1) {
            curr.value = value
            return true
        }
        
        return false
    }
    
    find(dirs) {
        let curr = this.root
        for (let i = 0; i < dirs.length; i++) {
            if (dirs[i] === '') continue
            
            if (curr.children[dirs[i]] === undefined) {
                return -1
            }
            
            curr = curr.children[dirs[i]]
        }
        
        return curr.value
    }
}

class TrieNode {
    constructor(key) {
        this.key = key
        this.children = {}
        this.value = -1
    }
}
```

## 1693. Daily Leads and Partners
```sql
# Write your MySQL query statement below
SELECT date_id, 
       make_name, 
       COUNT(DISTINCT lead_id) AS unique_leads, 
       COUNT(DISTINCT partner_id) AS unique_partners
FROM DailySales
GROUP BY date_id, make_name
```

## 318. Maximum Product of Word Lengths
```javascript
/**
 * @param {string[]} words
 * @return {number}
 */
var maxProduct = function(words) {
    const map = {}
    for (const word of words) {
        const mask = getMask(word)
        if (map[mask] === undefined) {
            map[mask] = word.length
        } else if (map[mask] < word.length) {
            map[mask] = word.length
        }
    }
    
    let max = 0
    const list = Object.entries(map)
    for (let i = 0; i < list.length; i++) {
        for (let j = i + 1; j < list.length; j++) {
            const [maskI, lenI] = list[i]
            const [maskJ, lenJ] = list[j]
            if (maskI & maskJ) continue
            max = Math.max(max, lenI * lenJ)
        }
    }
    
    return max
};

const getMask = word => {
    let mask = 0
    for (const char of word) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        mask |= 1 << index
    }
    return mask
}
```

## 795. Number of Subarrays with Bounded Maximum
```javascript
/**
 * @param {number[]} A
 * @param {number} L
 * @param {number} R
 * @return {number}
 */
var numSubarrayBoundedMax = function(A, L, R) {
    let totalCount = 0
    let prevCount = 0
    let start = -1
    for (let i = 0; i < A.length; i++) {
        let currCount = prevCount
        if (L <= A[i] && A[i] <= R) {
            currCount = i - start
        } else if (A[i] > R) {
            start = i
            currCount = 0
        }
        
        totalCount += currCount
        prevCount = currCount
    }
    
    return totalCount
};
```

## 1400. Construct K Palindrome Strings
```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {boolean}
 */
var canConstruct = function(s, k) {
    if (s.length < k) return false
    
    let odds = 0
    let oddCounts = 0
    for (const char of s) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        oddCounts ^= 1 << index
        oddCounts & 1 << index ? odds++ : odds--
    }
    
    return odds <= k
};
```

## 1616. Split Two Strings to Make Palindrome
```javascript
/**
 * @param {string} a
 * @param {string} b
 * @return {boolean}
 */
var checkPalindromeFormation = function(a, b) {
    const _checkPalindrome = (a, b) => {
        let i = 0
        let j = b.length - 1

        while (i < j && a[i] === b[j]) {
            i++
            j--
        }

        return i > j || isPalindrome(a, i, j) || isPalindrome(b, i, j)
    }
    
    return _checkPalindrome(a, b) || _checkPalindrome(b, a)
};

const isPalindrome = (str, i, j) => {
    while (i < j && str[i] === str[j]) {
        i++
        j--
    }
    
    return i >= j
}
```

## 727. Minimum Window Subsequence
```javascript
/**
 * @param {string} S
 * @param {string} T
 * @return {string}
 */
var minWindow = function(S, T) {
    const _minWindow = (i, j) => {
        if (j >= T.length) return 0
        if (i >= S.length) return Infinity
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }
        
        let result = Infinity
        if (S[i] === T[j]) {
            result = Math.min(result, 1 + _minWindow(i + 1, j + 1))
        }
        
        result = Math.min(result, 1 + _minWindow(i + 1, j))
        memo[i][j] = result
        return result
    }
    
    const memo = new Array(S.length).fill().map(a => new Array(T.length))
    _minWindow(0, 0)
    
    let minLength = Infinity
    let startIndex = -1
    for (let i = 0; i < memo.length; i++) {
        if (minLength > memo[i][0]) {
            minLength = memo[i][0]
            startIndex = i
        }
    }
    
    if (minLength === Infinity) return ''
    return S.slice(startIndex, startIndex + minLength)
};
```

## 115. Distinct Subsequences
```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = function(s, t) {
    const _numDistinct = (i, j) => {
        if (j >= t.length) return 1
        if (i >= s.length) return 0
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }
        
        let count = 0
        if (s[i] === t[j]) {
            // take
            count += _numDistinct(i + 1, j + 1)
        }        
        // don't take
        count += _numDistinct(i + 1, j)
        
        memo[i][j] = count
        return count
    }
    
    const memo = new Array(s.length).fill().map(a => new Array(t.length))
    return _numDistinct(0, 0)
};
```

## 1044. Longest Duplicate Substring
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    let left = 1
    let right = s.length
    
    let result = ''
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        const curr = hasDup(s, mid)
        if (curr !== '') {
            result = curr
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return result
};

const hasDup = (str, size) => {
    const MOD = 2 ** 32
    const base = 26
    
    let baseToMaxPow = 1
    for (let i = 1; i < size; i++) {
        baseToMaxPow *= base
        baseToMaxPow %= MOD
    }
    
    let rollingHash = 0
    for (let i = 0; i < size; i++) {
        rollingHash *= base
        rollingHash %= MOD
        rollingHash += str[i].charCodeAt(0)
        rollingHash %= MOD
    }
    
    const seen = {}
    seen[rollingHash] = [0]
    
    for (let endIndex = size; endIndex < str.length; endIndex++) {
        const startIndex = endIndex - size
        
        rollingHash -= ((str[startIndex].charCodeAt(0) * baseToMaxPow) % MOD)
        rollingHash *= base
        rollingHash %= MOD
        rollingHash += str[endIndex].charCodeAt(0)
        rollingHash %= MOD
        
        if (seen[rollingHash]) {
            for (const prevStartIndex of seen[rollingHash]) {
                const prev = str.slice(prevStartIndex, prevStartIndex + size)
                const candidate = str.slice(startIndex + 1, endIndex + 1)
                if (prev === candidate) {
                    return str.slice(startIndex + 1, endIndex + 1)
                }
            }
            
            seen[rollingHash].push(startIndex + 1)
        } else {
            seen[rollingHash] = [startIndex + 1]
        }
    }
    
    return ''
}
```

## 1316. Distinct Echo Substrings
```javascript
/**
 * @param {string} text
 * @return {number}
 */
var distinctEchoSubstrings = function(text) {
    const unique = new Set()
    const BASE = 26
    const MOD = 101
    
    for (let len = 1; len <= text.length / 2; len++) {
        let i = 0
        let j = i + len
        
        let baseToMaxPow = 1
        for (let k = 1; k < len; k++) {
            baseToMaxPow = (baseToMaxPow * BASE) % MOD
        }
        
        let hashI = 0
        let hashJ = 0
        for (let k = 0; k < len; k++) {
            hashI *= BASE
            hashI %= MOD
            hashI += text[i++].charCodeAt(0)
            hashI %= MOD
            
            hashJ *= BASE
            hashJ %= MOD
            hashJ += text[j++].charCodeAt(0)
            hashJ %= MOD
        }
        
        for (let start = 0; start + j <= text.length; start++) {
            const startI = start
            const endI = start + i
            const startJ = start + i
            const endJ = start + j
            
            if (hashI === hashJ) {
                const strI = text.slice(startI, endI)
                const strJ = text.slice(startJ, endJ)
                
                if (strI === strJ) {
                    unique.add(strI)
                }
            }
            
            if (endJ >= text.length) break
            
            hashI -= (text[startI].charCodeAt(0) * baseToMaxPow % MOD)
            hashI *= BASE
            hashI %= MOD
            hashI += text[endI].charCodeAt(0)
            hashI %= MOD

            hashJ -= (text[startJ].charCodeAt(0) * baseToMaxPow % MOD)
            hashJ *= BASE
            hashJ %= MOD
            hashJ += text[endJ].charCodeAt(0)
            hashJ %= MOD
        }
    }
    
    return unique.size
};
```

## 1458. Max Dot Product of Two Subsequences
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var maxDotProduct = function(nums1, nums2) {
    const _maxDotProduct = (i, j) => {
        if (i >= nums1.length) return -Infinity
        if (j >= nums2.length) return -Infinity
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }
        
        let result = nums1[i] * nums2[j] + Math.max(_maxDotProduct(i + 1, j + 1), 0) 
        result = Math.max(result, _maxDotProduct(i + 1, j))
        result = Math.max(result, _maxDotProduct(i, j + 1))
        
        memo[i][j] = result
        return result
    }
    
    const memo = new Array(nums1.length).fill().map(a => new Array(nums2.length))
    return _maxDotProduct(0, 0)
};
```

## 1498. Number of Subsequences That Satisfy the Given Sum Condition
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var numSubseq = function(nums, target) {
    const MOD = (10 ** 9) + 7
    const pows = new Array(nums.length).fill(1)
    for (let i = 1; i < nums.length; i++) {
        pows[i] = (pows[i - 1] * 2) % MOD
    }
    
    nums.sort((a, b) => a - b)
    
    let count = 0
    let left = 0
    let right = nums.length - 1
    while (left <= right) {
        if (nums[left] + nums[right] > target) {
            right--
        } else {
            count += pows[right - left]
            count %= MOD   
            left++
        }
    }
    
    return count
};
```

## 792. Number of Matching Subsequences
```javascript
// Binary Search
/**
 * @param {string} S
 * @param {string[]} words
 * @return {number}
 */
var numMatchingSubseq = function(S, words) {
    const map = {}
    for (let i = 0; i < S.length; i++) {
        if (!map[S[i]]) map[S[i]] = []
        map[S[i]].push(i)
    }
    
    let count = 0
    outer : for (const word of words) {
        let prevIndex = -1
        for (const char of word) {
            const currIndex = binarySearch(map[char], prevIndex)
            if (currIndex === -1) continue outer
            prevIndex = currIndex
        }
        count++
    }
    
    return count
};

const binarySearch = (arr, target) => {
    if (!arr || !arr.length) return -1
    
    let left = 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid] <= target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    if (left >= arr.length) return -1
    return arr[left]
}

// Linear Scan
/**
 * @param {string} S
 * @param {string[]} words
 * @return {number}
 */
var numMatchingSubseq = function(S, words) {
    const waiting = new Array(26).fill().map(a => [])
    for (const word of words) {
        const index = word[0].charCodeAt(0) - 'a'.charCodeAt(0)
        waiting[index].push([word, 0])
    }
    
    let count = 0
    for (const char of S) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        const size = waiting[index].length
        for (let i = 0; i < size; i++) {
            const [word, charIndex] = waiting[index].shift()
            if (charIndex + 1 >= word.length) {
                count++
                continue
            }
            
            const nextIndex = word[charIndex + 1].charCodeAt(0) - 'a'.charCodeAt(0)
            waiting[nextIndex].push([word, charIndex + 1])
        }
    }
    
    return count
};
```

## 368. Largest Divisible Subset
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var largestDivisibleSubset = function(nums) {
    nums.sort((a, b) => a - b)
    
    const dp = new Array(nums.length).fill(1)
    let max = 1
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] % nums[j] === 0) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
        max = Math.max(max, dp[i])
    }
    
    const result = []
    let prev = -1
    for (let i = dp.length - 1; i >= 0; i--) {
        if (dp[i] === max && (prev % nums[i] === 0 || prev === -1)) {
            result.push(nums[i])
            max--
            prev = nums[i]
        }
    }
    
    return result
};
```

## 1312. Minimum Insertion Steps to Make a String Palindrome
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minInsertions = function(s) {
    const _minInsertions = (i, j) => {
        if (i >= j) return 0
        if (memo[i][j] !== undefined) return memo[i][j]
        
        let result = 0
        if (s[i] === s[j]) {
            result = _minInsertions(i + 1, j - 1)
        } else {
            result = 1 + Math.min(_minInsertions(i + 1, j),
                                  _minInsertions(i, j - 1))
        }
        
        memo[i][j] = result
        return memo[i][j]
    }
    
    const memo = new Array(s.length).fill().map(a => new Array(s.length))
    return _minInsertions(0, s.length - 1)
};
```

## 1246. Palindrome Removal
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var minimumMoves = function(arr) {
    const _minimumMoves = (i, j) => {
        if (i >= j) return 1
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }

        let result = Infinity
        if (arr[i] === arr[j]) {
            result = _minimumMoves(i + 1, j - 1)
        }
        
        for (let k = i; k < j; k++) {
            result = Math.min(result, _minimumMoves(i, k) + _minimumMoves(k + 1, j))
        }
        
        memo[i][j] = result
        return result
    }

    const memo = new Array(arr.length).fill().map(a => new Array(arr.length))
    return _minimumMoves(0, arr.length - 1)
};
```

## 664. Strange Printer
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var strangePrinter = function(s) {
    const _strangePrinter = (i, j) => {
        if (i > j) return 0
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }

        let result = 1 + _strangePrinter(i + 1, j)
        
        for (let k = i + 1; k <= j; k++) {
            if (compressedS[i] === compressedS[k])
                result = Math.min(result, 
                                  _strangePrinter(i, k - 1) + 
                                  _strangePrinter(k + 1, j))
        }
        
        memo[i][j] = result
        return result
    }
    
    const memo = new Array(s.length).fill().map(a => new Array(s.length))
    const compressedS = compress(s)
    return _strangePrinter(0, compressedS.length - 1)
};

const compress = s => {
    const result = []
    for (let i = 0; i < s.length; i++) {
        if (s[i] === s[i + 1]) {
            continue
        }
        result.push(s[i])
    }
    return result.join('')
}
```

## 1371. Find the Longest Substring Containing Vowels in Even Counts
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var findTheLongestSubstring = function(s) {
    const vowels = new Set('aeiou')
    const map = { 0: -1 }
    let max = 0
    let mask = 0
    for (let i = 0; i < s.length; i++) {
        if (vowels.has(s[i])) {
            const index = s[i].charCodeAt(0) - 'a'.charCodeAt(0)
            mask ^= 1 << index
        }
        
        if (map[mask] === undefined) {
            map[mask] = i
        } else {
            max = Math.max(max, i - map[mask])
        }
    }
    
    return max
};
```

## 1177. Can Make Palindrome from Substring
```javascript
/**
 * @param {string} s
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var canMakePaliQueries = function(s, queries) {
    const prefix = new Array(s.length).fill(0)
    for (let i = 0; i < s.length; i++) {
        const index = s[i].charCodeAt(0) - 'a'.charCodeAt(0)
        prefix[i] = prefix[i - 1] ^ 1 << index
    }
    
    const result = []
    for (const [left, right, k] of queries) {
        const range = prefix[right] ^ prefix[left - 1]
        const oddCount = countOnes(range)
        result.push(Math.floor(oddCount / 2) <= k)
    }
    
    return result
};

const countOnes = bin => {
    let count = 0
    while (bin) {
        bin &= bin - 1
        count++
    }
    return count
}
```

## 1682. Longest Palindromic Subsequence II
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function(s) {
    const lPS = (i, j, prevCharCode) => {
        if (i >= j) return 0
        
        if (memo[i][j][prevCharCode]) {
            return memo[i][j][prevCharCode]
        }
        
        const currCharCode = getCharCode(s[i])
        if (s[i] === s[j] && currCharCode !== prevCharCode) {
            memo[i][j][prevCharCode] = 2 + lPS(i + 1, j - 1, currCharCode)
        } else {
            memo[i][j][prevCharCode] = Math.max(lPS(i + 1, j, prevCharCode), 
                                                lPS(i, j - 1, prevCharCode))
        }
        
        return memo[i][j][prevCharCode]
    }
    
    const memo = new Array(s.length).fill()
                    .map(a => new Array(s.length).fill()
                    .map(a => new Array(27)))
                         
    return lPS(0, s.length - 1, 26)
};

const getCharCode = char => {
    return char.charCodeAt(0) - 'a'.charCodeAt(0)
}
```

## 132. Palindrome Partitioning II
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minCut = function(s) {
    const n = s.length
    
    const isPalindromeDP = new Array(n).fill().map(a => new Array(n).fill(false))
    for (let len = 1; len <= n; len++) {
        for (let start = 0; start < n - len + 1; start++) {
            const end = start + len - 1
            if (start === end) {
                isPalindromeDP[start][end] = true
            } else if (start === end - 1 && s[start] === s[end]) {
                isPalindromeDP[start][end] = true
            } else if (s[start] === s[end] && isPalindromeDP[start + 1][end - 1]) {
                isPalindromeDP[start][end] = true
            }
        }
    }
    
    const minCutDP = new Array(n)
    for (let end = 0; end < n; end++) {
        if (isPalindromeDP[0][end]) {
            minCutDP[end] = 0
            continue
        }
        
        let min = Infinity
        for (let j = 0; j < end; j++) {
            if (isPalindromeDP[j + 1][end]) {
                min = Math.min(min, minCutDP[j] + 1)
            }
        }
        
        minCutDP[end] = min
    }
    
    return minCutDP[n - 1]
};
```

## 1278. Palindrome Partitioning III
```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var palindromePartition = function(s, k) {    
    const _palindromePartition = (i, k) => {
        if (i >= s.length) return k === 0 ? 0 : Infinity
        if (k <= 0) return Infinity
        
        if (memo[i][k] !== undefined) {
            return memo[i][k]
        }
        
        let result = Infinity
        for (let j = i; j < s.length; j++) {
            result = Math.min(result, minCharsDP[i][j] + _palindromePartition(j + 1, k - 1))
        }
        
        memo[i][k] = result
        return result
    }
    
    const n = s.length
    const minCharsDP = new Array(n).fill().map(a => new Array(n).fill(0))
    for (let len = 1; len <= n; len++) {
        for (let start = 0; start < n - len + 1; start++) {
            const end = start + len - 1
            
            if (start === end) continue
            minCharsDP[start][end] = (s[start] !== s[end]) + minCharsDP[start + 1][end - 1]
        }
    }
    
    const memo = new Array(n).fill().map(a => new Array(k + 1))
    return _palindromePartition(0, k)
};
```

## 1548. The Most Similar Path in a Graph
```javascript
/**
 * @param {number} n
 * @param {number[][]} roads
 * @param {string[]} names
 * @param {string[]} targetPath
 * @return {number[]}
 */
var mostSimilar = function(n, roads, names, targetPath) {
    const _mostSimilar = (vertex, i) => {
        if (i >= targetPath.length) {
            return 0
        }
        
        if (memoMin[vertex][i] !== undefined) {
            return memoMin[vertex][i]
        }
        
        let currDist = Infinity
        if (graph[vertex]) {
            for (const neighbor of graph[vertex]) {
                const neighborDist = _mostSimilar(neighbor, i + 1)
                
                if (currDist > neighborDist) {
                    currDist = neighborDist
                    memoNeighbor[vertex][i] = neighbor
                }
            }
        }
        
        currDist += (names[vertex] !== targetPath[i])
        memoMin[vertex][i] = currDist
        return currDist
    }
    
    const graph = buildGraph(n, roads)
    const memoMin = new Array(n + 1).fill().map(a => new Array(targetPath.length))
    const memoNeighbor = new Array(n + 1).fill().map(a => new Array(targetPath.length))
    
    let editDistance = Infinity
    let startVertex = 0
    for (let vertex = 0; vertex <= n; vertex++) {
        const result = _mostSimilar(vertex, 0)
        if (result < editDistance) {
            editDistance = result
            startVertex = vertex
        }
    }
    
    const path = [startVertex]
    let vertex = startVertex
    for (let i = 0; i < targetPath.length - 1; i++) {
        path.push(memoNeighbor[vertex][i])
        vertex = memoNeighbor[vertex][i]
    }
    return path
};

const buildGraph = (n, edges) => {
    const graph = {}
    for (const [u, v] of edges) {
        if (!graph[u]) graph[u] = []
        if (!graph[v]) graph[v] = []
        graph[u].push(v)
        graph[v].push(u)
    }
    
    return graph
}
```

## 1494. Parallel Courses II
```javascript
/**
 * @param {number} n
 * @param {number[][]} dependencies
 * @param {number} k
 * @return {number}
 */
var minNumberOfSemesters = function(n, dependencies, k) {
    const _minNumberOfSemesters = mask => {
        if (mask === (1 << n) - 1) return 0
        
        if (memo[mask] !== undefined) {
            return memo[mask]
        }
        
        // Get indegrees
        const indegrees = new Array(n).fill(0)
        for (let vertex = 0; vertex < n; vertex++) {
            if (mask & 1 << vertex) continue
            
            for (const neighbor of graph[vertex]) {
                indegrees[neighbor]++
            }
        }
        
        // Select courses with indegrees of 0 (Kahn's Algo)
        let courses = 0
        for (let vertex = 0; vertex < n; vertex++) {
            if (mask & 1 << vertex || indegrees[vertex] !== 0) continue
            courses |= 1 << vertex
        }
        
        // If courses less than or equal to K greedily take all
        if (countOnes(courses) <= k) {
            memo[mask] = 1 + _minNumberOfSemesters(mask | courses)
            return memo[mask]
        }
        
        // else generate all submasks of size K
        let result = Infinity
        let submask = courses
        while (submask) {
            submask = (submask - 1) & courses
            if (countOnes(submask) !== k) continue
            result = Math.min(result, 1 + _minNumberOfSemesters(mask | submask))
        }
        
        memo[mask] = result
        return result
    }
    
    const graph = buildGraph(n, dependencies)
    const memo = new Array(1 << n)
    return _minNumberOfSemesters(0)
};

const countOnes = bin => {
    let count = 0
    while (bin) {
        bin &= bin - 1
        count++
    }
    return count
}

const buildGraph = (n, edges) => {
    const graph = new Array(n).fill().map(a => [])
    
    for (const [u, v] of edges) {
        graph[u - 1].push(v - 1)
    }
    
    return graph
}
```

## 1699. Number of Calls Between Two Persons
```sql
-- If statement
# Write your MySQL query statement below
SELECT IF(from_id < to_id, from_id, to_id) AS person1,
       IF(from_id > to_id, from_id, to_id) AS person2,
       COUNT(*) AS call_count,
       SUM(duration) AS total_duration
FROM Calls
GROUP BY person1, person2

-- Least, Greatest
# Write your MySQL query statement below
SELECT LEAST(from_id, to_id) AS person1,
       GREATEST(from_id, to_id) AS person2,
       COUNT(*) AS call_count,
       SUM(duration) AS total_duration
FROM Calls
GROUP BY person1, person2
```

## 685. Redundant Connection II
```javascript
/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantDirectedConnection = function(edges) {
    const parent = new Array(edges.length + 1)
    const unionFind = new UnionFind(edges.length + 1)
    
    let candidate1 = null
    let candidate2 = null
    for (let i = 0; i < edges.length; i++) {
        const [u, v] = edges[i]
        if (parent[v] !== undefined) {
            candidate1 = parent[v]
            candidate2 = i
        }
        
        parent[v] = i
    }
    
    let cycleEdge = null
    for (let i = 0; i < edges.length; i++) {
        const [u, v] = edges[i]
        if (candidate2 === i) continue
        
        if (unionFind.connected(u, v)) {
            cycleEdge = i
            break
        }
        
        unionFind.union(u, v)
    }
    
    if (candidate1 === null && candidate2 === null) {
        return edges[cycleEdge]
    }
    
    if (cycleEdge !== null) {
        return edges[candidate1]
    }
    
    return edges[candidate2]
};

class UnionFind {
    constructor(n) {
        this.size = new Array(n).fill(1)
        this.parent = new Array(n)
        for (let i = 0; i < n; i++) {
            this.parent[i] = i
        }
    }
    
    find(u) {
        let root = this.parent[u]
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (u !== root) {
            const next = this.parent[u]
            this.parent[u] = root
            u = next
        }
        
        return root
    }

    union(u, v) {
        const parentU = this.find(u)
        const parentV = this.find(v)
        
        if (parentU === parentV) return
        
        if (this.size[parentU] < this.size[parentV]) {
            this.parent[parentU] = parentV
            this.size[parentV] += this.size[parentU]
        } else {
            this.parent[parentV] = parentU
            this.size[parentU] += this.size[parentV]
        }
    }
    
    connected(u, v) {
        return this.find(u) === this.find(v)
    }
}
```

## 1697. Checking Existence of Edge Length Limited Paths
```javascript
/**
 * @param {number} n
 * @param {number[][]} edgeList
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var distanceLimitedPathsExist = function(n, edgeList, queries) {
    for (let i = 0; i < queries.length; i++) {
        queries[i].push(i)
    }
    
    queries.sort((a, b) => a[2] - b[2])
    edgeList.sort((a, b) => a[2] - b[2])
    
    const result = new Array(queries.length)
    const unionFind = new UnionFind(n)
    
    let j = 0
    for (let i = 0; i < queries.length; i++) {
        while (j < edgeList.length && edgeList[j][2] < queries[i][2]) {
            unionFind.union(edgeList[j][0], edgeList[j][1])
            j++
        }
        
        result[queries[i][3]] = unionFind.connected(queries[i][0], queries[i][1])
    }
    
    return result
};

class UnionFind {
    constructor(n) {
        this.size = new Array(n).fill(1)
        this.parent = new Array(n)
        for (let i = 0; i < n; i++) {
            this.parent[i] = i
        }
    }
    
    find(a) {
        let root = this.parent[a]
        while (root !== this.parent[root]) {
            root = this.parent[root]
        }
        
        while (a !== root) {
            const next = this.parent[a]
            this.parent[a] = root
            a = next
        }
        
        return root
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) return
        
        if (this.size[parentA] < this.size[parentB]) {
            this.parent[parentA] = parentB
            this.size[parentB] += this.size[parentA]
        } else {
            this.parent[parentB] = parentA
            this.size[parentA] += this.size[parentB]
        }
    }
    
    connected(a, b) {
        return this.find(a) === this.find(b)
    }
}
```

## 1700. Number of Students Unable to Eat Lunch
```javascript
/**
 * @param {number[]} students
 * @param {number[]} sandwiches
 * @return {number}
 */
var countStudents = function(students, sandwiches) {
    let zeros = 0
    let ones = 0
    
    for (const student of students) {
        student === 0 ? zeros++ : ones++
    }
    
    let count = 0
    for (let i = 0; i < sandwiches.length; i++) {
        if (sandwiches[i] === 0 && zeros) {
            count++
            zeros--
        } else if (sandwiches[i] === 1 && ones) {
            count++
            ones--
        } else {
            break
        }
    }
    
    return zeros + ones
};
```

## 1627. Graph Connectivity With Threshold
```javascript
/**
 * @param {number} n
 * @param {number} threshold
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var areConnected = function(n, threshold, queries) {
    const unionFind = new UnionFind(n + 1)    
    for (let i = 1; i <= n; i++) {
        for (let j = 2 * i; j <= n; j += i) {
            if (i > threshold) {
                unionFind.union(i, j)
            }
        }
    }
    
    const result = []
    for (const [u, v] of queries) {
        result.push(unionFind.connected(u, v))
    }
    return result
};

class UnionFind {
    constructor(n) {
        this.size = new Array(n).fill(1)
        this.parent = new Array(n)
        for (let i = 0; i < n; i++) {
            this.parent[i] = i
        }
    }
    
    find(u) {
        let root = this.parent[u]
        while (root != this.parent[root]) {
            root = this.parent[root]
        }
        
        while (root !== u) {
            const next = this.parent[u]
            this.parent[u] = root
            u = next
        }
        
        return root
    }
    
    union(u, v) {
        const parentU = this.find(u)
        const parentV = this.find(v)
        
        if (parentU === parentV) return
        
        if (this.size[parentU] < this.size[parentV]) {
            this.parent[parentU] = parentV
            this.size[parentV] += this.size[parentU]
        } else {
            this.parent[parentV] = parentU
            this.size[parentU] += this.size[parentV]
        }
    }
    
    connected(u, v) {
        return this.find(u) === this.find(v)
    }
}
```

## 1657. Determine if Two Strings Are Close
```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {boolean}
 */
var closeStrings = function(word1, word2) {
    if (word1.length !== word2.length) return false
    if (!sameChars(word1, word2)) return false
    
    const counts1 = getCharCounts(word1)
    const counts2 = getCharCounts(word2)
    const map = {}
    
    for (let i = 0; i < counts1.length; i++) {
        if (counts1[i] !== 0) {
            if (!map[counts1[i]]) map[counts1[i]] = 0
            map[counts1[i]]++
        }
        
        if (counts2[i] !== 0) {
            if (!map[counts2[i]]) map[counts2[i]] = 0
            map[counts2[i]]--
        }
    }
    
    for (const count of Object.values(map)) {
        if (count !== 0) return false
    }
    
    return true
};

const getCharCounts = str => {
    const charCounts = new Array(26).fill(0)
    for (const char of str) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        charCounts[index]++
    }
    
    return charCounts
}

const sameChars = (str1, str2) => {
    let mask = 0
    for (const char of str1) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        mask |= 1 << index
    }
    
    for (const char of str2) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        if (mask & 1 << index) continue
        return false
    }
    
    return true
}
```

## 759. Employee Free Time
```javascript
// N log N
/**
 * // Definition for an Interval.
 * function Interval(start, end) {
 *    this.start = start;
 *    this.end = end;
 * };
 */

/**
 * @param {Interval[][]} schedule
 * @return {Interval[]}
 */
var employeeFreeTime = function(schedule) {
    const sorted = schedule.flat().sort((a, b) => a.start - b.start)
    if (!sorted.length) return []
    
    const result = []
    let end = sorted[0].end
    for (let i = 1; i < sorted.length; i++) {
        const next = sorted[i]
        if (next.start <= end) {
            end = Math.max(next.end, end)
            continue
        }
        
        result.push(new Interval(end, next.start))
        end = next.end
    }
    
    return result
};

// N Log K
/**
 * // Definition for an Interval.
 * function Interval(start, end) {
 *    this.start = start;
 *    this.end = end;
 * };
 */

/**
 * @param {Interval[][]} schedule
 * @return {Interval[]}
 */
var employeeFreeTime = function(schedule) {
    const indices = []
    for (let i = 0; i < schedule.length; i++) {
        indices.push([i, 0])
    }
    
    const heap = new Heap(indices, ([aRow, aCol], [bRow, bCol]) => {
        const intervalA = schedule[aRow][aCol]
        const intervalB = schedule[bRow][bCol]
        return intervalA.start < intervalB.start
    })
    
    const freeTimes = []
    let end = -Infinity
    while (heap.length()) {
        const [topRow, topCol] = heap.remove()
        const interval = schedule[topRow][topCol]
        
        if (topCol < schedule[topRow].length - 1) {
            heap.insert([topRow, topCol + 1])
        }
        
        if (end !== -Infinity && end < interval.start) {
            freeTimes.push(new Interval(end, interval.start))
        }
        
        end = Math.max(interval.end, end)
    }
    
    return freeTimes
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    length() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 502. IPO
```javascript
/**
 * @param {number} k
 * @param {number} W
 * @param {number[]} Profits
 * @param {number[]} Capital
 * @return {number}
 */
var findMaximizedCapital = function(k, W, Profits, Capital) {
    const projects = []
    for (let i = 0; i < Profits.length; i++) {
        projects.push([Profits[i], Capital[i]])
    }
    const remainingProjects = new Heap(projects, (a, b) => a[1] < b[1])
    const availableProjects = new Heap([], (a, b) => a > b)
    
    while (k--) {
        while (remainingProjects.size() && remainingProjects.peek()[1] <= W) {
            const profit = remainingProjects.remove()[0]
            availableProjects.insert(profit)
        }
        
        if (availableProjects.size() === 0) {
            return W
        }
        
        W += availableProjects.remove()
    }
    
    return W
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    size() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 632. Smallest Range Covering Elements from K Lists
```javascript
/**
 * @param {number[][]} nums
 * @return {number[]}
 */
var smallestRange = function(nums) {
    let min = Infinity
    let max = -Infinity
    const start = []
    for (let i = 0; i < nums.length; i++) {
        start.push([i, 0])
        min = Math.min(min, nums[i][0])
        max = Math.max(max, nums[i][0])
    }
    
    const heap = new Heap(start, (a, b) => {
        const [aList, aIndex] = a
        const [bList, bIndex] = b
        return nums[aList][aIndex] < nums[bList][bIndex]
    })
    
    let result = [min, max]
    while (true) {
        const [currList, currIndex] = heap.remove()
        if (currIndex >= nums[currList].length - 1) {
            break
        }
        
        heap.insert([currList, currIndex + 1])
        max = Math.max(max, nums[currList][currIndex + 1])
        
        const [minList, minIndex] = heap.peek()
        min = nums[minList][minIndex]
        
        if (result[1] - result[0] > max - min) {
            result = [min, max]
        }
    }
    
    return result
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    size() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 1529. Bulb Switcher IV
```javascript
/**
 * @param {string} target
 * @return {number}
 */
var minFlips = function(target) {
    let flips = 0
    for (let i = 0; i < target.length; i++) {
        if (target[i] === '1' && flips % 2 === 0) {
            flips++
        } else if (target[i] === '0' && flips % 2 !== 0) {
            flips++
        }
    }
    
    return flips
};
```

## 1704. Determine if String Halves Are Alike
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var halvesAreAlike = function(s) {
    const vowels = new Set('aeiouAEIOU')
    
    let vowelCount1 = 0
    let vowelCount2 = 0
    
    let i = 0
    let j = s.length / 2
    while (j < s.length) {
        vowelCount1 += vowels.has(s[i++])
        vowelCount2 += vowels.has(s[j++])
    }
    
    return vowelCount1 === vowelCount2
};
```

## 1262. Greatest Sum Divisible by Three
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSumDivThree = function(nums) {
    const _maxSumDivThree = (i, rem) => {
        if (i >= nums.length) {
            return rem ? -Infinity : 0;
        } 
        
        if (memo[i][rem] !== undefined) {
            return memo[i][rem]
        }
        
        let result = -Infinity
        result = Math.max(result, nums[i] + _maxSumDivThree(i + 1, (rem + nums[i]) % 3))
        result = Math.max(result, _maxSumDivThree(i + 1, rem))
        
        memo[i][rem] = result
        return result
    }
    
    const memo = new Array(nums.length).fill().map(a => new Array(3))
    return _maxSumDivThree(0, 0)
};
```

## 1573. Number of Ways to Split a String
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numWays = function(s) {
    const MOD = 10 ** 9 + 7
    
    let onesTotal = 0
    for (const num of s) {
        onesTotal += +num
    }
    
    const n = s.length - 2
    if (onesTotal === 0) {
        return (n * (n + 1) / 2) % MOD
    }
    
    if (onesTotal % 3 !== 0) {
        return 0
    }
    
    const onesInEachSplit = onesTotal / 3
    let group1Count = 1
    let group2Count = 1
    let currOnes = 0
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '1') {
            currOnes++
            continue
        }
        
        group1Count += currOnes === onesInEachSplit
        group2Count += currOnes === (onesInEachSplit * 2)
    }
    
    return group1Count * group2Count % MOD
};
```

## 1647. Minimum Deletions to Make Character Frequencies Unique
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minDeletions = function(s) {
    const charCounts = new Array(26).fill(0)
    for (const char of s) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0)
        charCounts[index]++
    }
    
    const sorted = []
    for (const counts of charCounts) {
        if (counts === 0) continue
        sorted.push(counts)
    }
    sorted.sort((a, b) => b - a)
    
    let result = 0
    let min = Infinity
    for (let i = 0; i < sorted.length; i++) {
        if (sorted[i] < min) {
            min = sorted[i]
            continue
        }
        
        result += min ? sorted[i] - min + 1 : sorted[i]
        min = Math.max(0, min - 1)
    }
    
    return result
};
```

## 1155. Number of Dice Rolls With Target Sum
```javascript
/**
 * @param {number} d
 * @param {number} f
 * @param {number} target
 * @return {number}
 */
var numRollsToTarget = function(d, f, target) {
    const _numRollsToTarget = (i, sum) => {
        if (i >= d) return sum === target
        
        if (memo[i][sum] !== undefined) {
            return memo[i][sum]
        }
        
        let result = 0
        for (let face = 1; face <= f; face++) {
            result += _numRollsToTarget(i + 1, sum + face)
            result %= MOD
        }
        
        memo[i][sum] = result
        return result
    }
    
    const MOD = 10 ** 9 + 7
    const memo = new Array(d).fill().map(a => new Array(f))
    return _numRollsToTarget(0, 0) % MOD
};
```

## 1419. Minimum Number of Frogs Croaking
```javascript
/**
 * @param {string} croakOfFrogs
 * @return {number}
 */
var minNumberOfFrogs = function(croakOfFrogs) {
    const phrase = 'croak'
    
    const indexMap = {}
    for (let i = 0; i < phrase.length; i++) {
        indexMap[phrase[i]] = i
    }
    
    const countMap = new Array(phrase.length).fill(0)
    let min = 0
    let open = 0
    for (const char of croakOfFrogs) {
        const charIndex = indexMap[char]
        
        countMap[charIndex]++
        
        if (charIndex === 0) {
            min = Math.max(min, ++open)
        } else if (charIndex === phrase.length - 1) {
            open--
        } else if (--countMap[charIndex - 1] < 0) {
            return -1           
        }
    }
    
    return open ? -1 : min
};
```

## 1229. Meeting Scheduler
```javascript
/**
 * @param {number[][]} slots1
 * @param {number[][]} slots2
 * @param {number} duration
 * @return {number[]}
 */
var minAvailableDuration = function(slots1, slots2, duration) {
    slots1.sort((a, b) => a[0] - b[0])
    slots2.sort((a, b) => a[0] - b[0])
    
    let i = 0
    let j = 0
    while (i < slots1.length && j < slots2.length) {
        const [start1, end1] = slots1[i]
        const [start2, end2] = slots2[j]
        
        const mergeStart = Math.max(start1, start2)
        const mergeEnd = Math.min(end1, end2)
        const interval = mergeEnd - mergeStart
        
        if (interval >= duration) {
            return [mergeStart, mergeStart + duration]
        }
        
        start1 < start2 ? i++ : j++
    }
    
    return []
};
```

## 223. Rectangle Area
```javascript
/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
    const rect1Width = Math.abs(A - C)
    const rect1Height = Math.abs(B - D)
    const rect1Area = rect1Width * rect1Height
    
    const rect2Width = Math.abs(E - G)
    const rect2Height = Math.abs(F - H)
    const rect2Area = rect2Width * rect2Height
    
    let overlapArea = 0
    const top = Math.min(D, H)
    const bottom = Math.max(F, B)
    const left = Math.max(A, E)
    const right = Math.min(G, C)
    if (right > left && top > bottom) {
        const overlapWidth = right - left
        const overlapHeight = top - bottom
        overlapArea = overlapWidth * overlapHeight
    }
    
    return rect1Area + rect2Area - overlapArea
};
```

## 1272. Remove Interval
```javascript
/**
 * @param {number[][]} intervals
 * @param {number[]} toBeRemoved
 * @return {number[][]}
 */
var removeInterval = function(intervals, toBeRemoved) {
    const [removedStart, removedEnd] = toBeRemoved
    const result = []
    for (let i = 0; i < intervals.length; i++) {
        const [start, end] = intervals[i]
        
        if (start > removedEnd || end < removedStart) {
            result.push(intervals[i])
            continue
        }
        
        if (start < removedStart) {
            result.push([start, removedStart])
        }
        
        if (end > removedEnd) {
            result.push([removedEnd, end])
        }
    }
    
    return result
};
```

## 1353. Maximum Number of Events That Can Be Attended
```javascript
/**
 * @param {number[][]} events
 * @return {number}
 */
var maxEvents = function(events) {
    events.sort((a, b) => a[0] - b[0])
    const heap = new Heap()
    
    let attended = 0
    let index = 0
    let day = 0
    
    while (heap.size() || index < events.length) {
        if (!heap.size()) {
            day = events[index][0]
        }
        
        while (index < events.length && events[index][0] <= day) {
            heap.insert(events[index][1])
            index++
        }
        
        while (heap.size() && heap.peek() < day) {
            heap.remove()
        }
        
        if (heap.size()) {
            heap.remove()
            attended++
        }
        
        day++
    }
    
    return attended
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    size() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 1708. Largest Subarray Length K
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var largestSubarray = function(nums, k) {
    let maxStart = 0
    for (let i = 0; i < nums.length - k + 1; i++) {
        if (nums[i] > nums[maxStart]) {
            maxStart = i
        }
    }
    
    return nums.slice(maxStart, maxStart + k)
};
```

## 1711. Count Good Meals
```javascript
/**
 * @param {number[]} deliciousness
 * @return {number}
 */
var countPairs = function(deliciousness) {
    const MOD = 10 ** 9 + 7
    const frequencyMap = {}
    let count = 0
    
    for (const d of deliciousness) {
        let powOf2 = 1
        for (let i = 0; i <= 21; i++) {
            const compliment = powOf2 - d
            
            if (frequencyMap[compliment] !== undefined) {
                count += frequencyMap[compliment]
            }
            
            powOf2 <<= 1
        }
        
        if (frequencyMap[d] === undefined) {
            frequencyMap[d] = 0
        }
        
        frequencyMap[d]++
    }
    
    return count % MOD
};
```

## 1710. Maximum Units on a Truck
```javascript
/**
 * @param {number[][]} boxTypes
 * @param {number} truckSize
 * @return {number}
 */
var maximumUnits = function(boxTypes, truckSize) {
    const buckets = new Array(1001)
    for (const [numOfBoxes, numOfUnits] of boxTypes) {
        if (buckets[numOfUnits] === undefined) {
            buckets[numOfUnits] = []
        }
        buckets[numOfUnits].push([numOfBoxes, numOfUnits])
    }
    
    const sortedBoxTypes = []
    for (let numOfUnits = buckets.length - 1; numOfUnits >= 0; numOfUnits--) {
        if (!buckets[numOfUnits]) continue
        for (let i = 0; i < buckets[numOfUnits].length; i++) {
            sortedBoxTypes.push(buckets[numOfUnits][i])
        }
    }
    
    let count = 0
    for (const [numOfBoxes, numOfUnits] of sortedBoxTypes) {
        const boxCount = Math.min(numOfBoxes, truckSize)
        count += boxCount * numOfUnits
        truckSize -= boxCount
        
        if (truckSize === 0) break
    }
    
    return count
};
```

## 1709. Biggest Window Between Visits
```sql
# Write your MySQL query statement below
SELECT user_id, MAX(biggest_window) AS biggest_window
FROM (SELECT u1.user_id, 
               u1.visit_date,
               CASE WHEN d1.diff IS NULL
               THEN DATEDIFF('2021-1-1', u1.visit_date)
               ELSE d1.diff
               END AS biggest_window
        FROM UserVisits AS u1
        LEFT JOIN (
            SELECT u1.user_id, 
                   u1.visit_date, 
                   MIN(DATEDIFF(u2.visit_date, u1.visit_date)) AS diff
            FROM UserVisits AS u1
            JOIN UserVisits AS u2
            ON u1.user_id = u2.user_id AND u1.visit_date < u2.visit_date
            GROUP BY u1.user_id, u1.visit_date
        ) AS d1
        ON d1.user_id = u1.user_id AND d1.visit_date = u1.visit_date
      ) as d2
GROUP BY user_id
ORDER BY user_id
```

## 423. Reconstruct Original Digits from English
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var originalDigits = function(s) {
    const count = {}
    for (const char of s) {
        if (count[char] === undefined) {
            count[char] = 0
        }
        count[char]++
    }
    
    const digitCount = new Array(10).fill(0)
    // Get even numbers by unique char
    digitCount[0] = (count['z'] || 0)
    digitCount[2] = (count['w'] || 0)
    digitCount[4] = (count['u'] || 0)
    digitCount[6] = (count['x'] || 0)
    digitCount[8] = (count['g'] || 0)
    
    // Get odd numbers by even counts
    digitCount[3] = (count['h'] || 0) - digitCount[8]
    digitCount[5] = (count['f'] || 0) - digitCount[4]
    digitCount[7] = (count['s'] || 0) - digitCount[6]
    digitCount[9] = (count['i'] || 0) - digitCount[5] - digitCount[6] - digitCount[8]
    digitCount[1] = (count['n'] || 0) - digitCount[7] - 2 * digitCount[9]
    
    const result = []
    for (let i = 0; i < digitCount.length; i++) {
        result.push(`${i}`.repeat(digitCount[i]))
    }
    return result.join('')
};
```

## 325. Maximum Size Subarray Sum Equals k
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxSubArrayLen = function(nums, k) {
    const map = { 0: -1 }
    let max = 0
    let acc = 0
    for (let i = 0; i < nums.length; i++) {
        acc += nums[i]
        
        const compliment = acc - k
        if (map[compliment] !== undefined) {
            max = Math.max(max, i - map[compliment])
        }
        
        if (map[acc] === undefined) {
            map[acc] = i
        }
    }
    
    return max
};
```

## 1658. Minimum Operations to Reduce X to Zero
```javascript
/**
 * @param {number[]} nums
 * @param {number} x
 * @return {number}
 */
var minOperations = function(nums, x) {
    let sum = 0
    for (const num of nums) {
        sum += num
    }
    
    const k = sum - x
    if (k === 0) return nums.length
    
    const map = { 0: -1 }
    let max = 0
    let acc = 0
    for (let i = 0; i < nums.length; i++) {
        acc += nums[i]
        
        const compliment = acc - k
        if (map[compliment] !== undefined) {
            max = Math.max(max, i - map[compliment])
        }
        
        if (map[acc] === undefined) {
            map[acc] = i
        }
    }
    
    return max === 0 ? -1 : nums.length - max
};
```

## 1423. Maximum Points You Can Obtain from Cards
```javascript
/**
 * @param {number[]} cardPoints
 * @param {number} k
 * @return {number}
 */
var maxScore = function(cardPoints, k) {
    let sum = 0
    for (const cardPoint of cardPoints) {
        sum += cardPoint
    }
    
    if (k === cardPoints.length) return sum
    
    const size = cardPoints.length - k
    let minAcc = Infinity
    let currAcc = 0
    
    let i = 0
    let j = 0
    while (j < cardPoints.length) {
        currAcc += cardPoints[j]
        
        if (j - i + 1 === size) {
            minAcc = Math.min(minAcc, currAcc)
            currAcc -= cardPoints[i]
            i++
        }
        
        j++
    }
    
    return sum - minAcc
};
```

## 918. Maximum Sum Circular Subarray
```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var maxSubarraySumCircular = function(A) {
    let totalSum = 0
    
    let totalMaxSum = -Infinity
    let currMaxSum = -Infinity
    
    let totalMinSum = Infinity
    let currMinSum = Infinity
    
    for (const a of A) {
        totalSum += a
        
        currMaxSum = Math.max(currMaxSum + a, a)
        totalMaxSum = Math.max(totalMaxSum, currMaxSum)
        
        currMinSum = Math.min(currMinSum + a, a)
        totalMinSum = Math.min(totalMinSum, currMinSum)
    }
    
    if (totalSum === totalMinSum) {
        return totalMaxSum
    }
    
    return Math.max(totalMaxSum, totalSum - totalMinSum)
};
```

## 984. String Without AAA or BBB
```javascript
/**
 * @param {number} a
 * @param {number} b
 * @return {string}
 */
var strWithout3a3b = function(a, b) {
    const largeChar = a < b ? 'b' : 'a'
    const smallChar = a < b ? 'a' : 'b'
    let largeCount = a < b ? b : a
    let smallCount = a < b ? a : b
    
    const result = []
    while (largeCount > 0) {
        result.push(largeChar)
        largeCount--
        
        if (largeCount > smallCount) {    
            result.push(largeChar)
            largeCount--
        }
        
        if (smallCount > 0) {
            result.push(smallChar)
            smallCount--
        }
    }
    
    return result.join('')
};
```

## 649. Dota2 Senate
```javascript
/**
 * @param {string} senate
 * @return {string}
 */
var predictPartyVictory = function(senate) {
    let radiantCount = 0
    let direCount = 0
    for (const senator of senate) {
        if (senator === 'R') {
            radiantCount++
        } else {
            direCount++
        }
    }
    
    let radiantBansAllowed = 0
    let direBansAllowed = 0
    const banned = new Set()
    while (true) {
        for (let i = 0; i < senate.length; i++) {
            if (banned.has(i)) continue
            
            if (senate[i] === 'R') {
                if (direBansAllowed > 0) {
                    direBansAllowed--
                    radiantCount--
                    banned.add(i)
                } else {
                    radiantBansAllowed++
                }
            } else {
                if (radiantBansAllowed > 0) {
                    radiantBansAllowed--
                    direCount--
                    banned.add(i)
                } else {
                    direBansAllowed++
                }
            }
            
            if (direCount && !radiantCount) {
                return 'Dire'
            }

            if (!direCount && radiantCount) {
                return 'Radiant'
            }
        }
    }
};
```

## 1227. Airplane Seat Assignment Probability
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var nthPersonGetsNthSeat = function(n) {
    return n > 1 ? 0.5 : 1
};
```

## 777. Swap Adjacent in LR String
```javascript
/**
 * @param {string} start
 * @param {string} end
 * @return {boolean}
 */
var canTransform = function(start, end) {
    if (start.length !== end.length) {
        return false
    }
    
    const n = start.length
    let i = 0
    let j = 0
    while (true) {
        while (i < n && start[i] === 'X') i++
        while (j < n && end[j] === 'X') j++
        
        if (i === n || j === n) {
            return i === n && j === n
        }
        
        if (start[i] !== end[j]) {
            return false
        }
        
        if (start[i] === 'L' && i < j) {
            return false
        }
        
        if (start[i] === 'R' && i > j) {
            return false
        }
        
        i++
        j++
    }
};
```

## 1695. Maximum Erasure Value
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumUniqueSubarray = function(nums) {
    let maxSum = 0
    let currSum = 0
    const seen = new Set()
    let i = 0
    for (let j = 0; j < nums.length; j++) {
        while (seen.has(nums[j])) {
            seen.delete(nums[i])
            currSum -= nums[i]
            i++
        }
        
        currSum += nums[j]
        seen.add(nums[j])
        maxSum = Math.max(maxSum, currSum)
    }
    
    return maxSum
};
```

## 978. Longest Turbulent Subarray
```javascript
// Kadane's Algorithm
/**
 * @param {number[]} arr
 * @return {number}
 */
var maxTurbulenceSize = function(arr) {
    let maxLen = 0
    let currLen = 0
    
    for (let i = 0; i < arr.length; i++) {
        if (i >= 2 && (arr[i - 2] > arr[i - 1] && arr[i - 1] < arr[i] || 
                       arr[i - 2] < arr[i - 1] && arr[i - 1] > arr[i])) {
            currLen++
        } else if (i >= 1 && arr[i - 1] !== arr[i]) {
            currLen = 2
        } else {
            currLen = 1
        }
        
        maxLen = Math.max(maxLen, currLen)
    }
    
    return maxLen
};

// DP - O(n) Space
/**
 * @param {number[]} arr
 * @return {number}
 */
var maxTurbulenceSize = function(arr) {
    if (!arr.length) return 0
    
    const dp = new Array(arr.length).fill().map(a => new Array(2).fill(1))
    let maxLen = 1
    
    for (let i = 1; i < arr.length; i++) {
        if (arr[i - 1] < arr[i]) {
            dp[i][0] = dp[i - 1][1] + 1
        } else if (arr[i - 1] > arr[i]) {
            dp[i][1] = dp[i - 1][0] + 1
        }
        
        maxLen = Math.max(maxLen, dp[i][0], dp[i][1])
    }
    
    return maxLen
};

// DP - O(1) Space
/**
 * @param {number[]} arr
 * @return {number}
 */
var maxTurbulenceSize = function(arr) {
    if (!arr.length) return 0
    
    let maxLen = 1
    let inc = 1 // inc: The length of current valid sequence which ends with two increasing numbers
    let dec = 1 // dec: The length of current valid sequence which ends with two decreasing numbers
    for (let i = 1; i < arr.length; i++) {
        if (arr[i - 1] > arr[i]) {
            dec = inc + 1
            inc = 1
        } else if (arr[i - 1] < arr[i]) {
            inc = dec + 1
            dec = 1
        } else {
            inc = 1
            dec = 1
        }
        
        maxLen = Math.max(maxLen, inc, dec)
    }
    
    return maxLen
};
```

## 376. Wiggle Subsequence
```javascript
// DP - O(n^2)
/**
 * @param {number[]} nums
 * @return {number}
 */
var wiggleMaxLength = function(nums) {
    if (!nums.length) return 0
    
    const dp = new Array(nums.length).fill(1).map(a => new Array(2).fill(1))
    let maxLen = 1
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] < nums[j]) {
                dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1)
            } else if (nums[i] > nums[j]) {
                dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1)
            }
        }
        
        maxLen = Math.max(maxLen, dp[i][0], dp[i][1])
    }
    
    return maxLen
};
```

## 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
```javascript
/**
 * @param {number[]} nums
 * @param {number} limit
 * @return {number}
 */
var longestSubarray = function(nums, limit) {
    let max = 0
    const maxDeque = []
    const minDeque = []
    
    let i = 0
    for (let j = 0; j < nums.length; j++) {
        while (maxDeque.length && maxDeque[maxDeque.length - 1] < nums[j]) {
            maxDeque.pop()
        }
        maxDeque.push(nums[j])
        
        while (minDeque.length && minDeque[minDeque.length - 1] > nums[j]) {
            minDeque.pop()
        }
        minDeque.push(nums[j])
        
        while (maxDeque[0] - minDeque[0] > limit) {
            if (maxDeque[0] === nums[i]) maxDeque.shift()
            if (minDeque[0] === nums[i]) minDeque.shift()
            i++
        }
        
        max = Math.max(max, j - i + 1)
    }
    
    return max
};
```

## 1074. Number of Submatrices That Sum to Target
```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {number}
 */
var numSubmatrixSumTarget = function(matrix, target) {
    const m = matrix.length
    const n = matrix[0].length
    
    for (let row = 0; row < m; row++) {
        for (let col = 1; col < n; col++) {        
            matrix[row][col] += matrix[row][col - 1]
        }
    }
    
    let result = 0
    for (let leftCol = 0; leftCol < n; leftCol++) {
        for (let rightCol = leftCol; rightCol < n; rightCol++) {
            const freqCounter = { 0: 1 }
            let sum = 0
            for (let row = 0; row < m; row++) {
                sum += matrix[row][rightCol] - (matrix[row][leftCol - 1] || 0)
                result += (freqCounter[sum - target] || 0)
                freqCounter[sum] = 1 + (freqCounter[sum] || 0)
            }
        }
    }
    
    return result    
};
```

## 363. Max Sum of Rectangle No Larger Than K
```javascript
// O(min(m,n)^2*max(m,n)*log(max(m,n)))
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var maxSumSubmatrix = function(matrix, k) {
    const m = matrix.length
    const n = matrix[0].length
    
    for (let row = 0; row < m; row++) {
        for (let col = 1; col < n; col++) {        
            matrix[row][col] += matrix[row][col - 1]
        }
    }
    
    let max = -Infinity
    for (let leftCol = 0; leftCol < n; leftCol++) {
        for (let rightCol = leftCol; rightCol < n; rightCol++) {
            let totalMax = -Infinity
            let currMax = -Infinity
            for (let row = 0; row < m; row++) {
                const curr = matrix[row][rightCol] - (matrix[row][leftCol - 1] || 0)
                currMax = Math.max(currMax + curr, curr)
                totalMax = Math.max(totalMax, currMax)
            }
            
            if (totalMax <= k) {
                max = Math.max(max, totalMax)
                continue
            }
            
            const sortedList = [0]
            let sum = 0
            for (let row = 0; row < m; row++) {
                sum += matrix[row][rightCol] - (matrix[row][leftCol - 1] || 0)
                
                // lowest value greater than sum - k
                const lowest = lowerBound(sortedList, sum - k)
                if (lowest !== undefined) {
                    max = Math.max(max, sum - lowest)
                }
                
                // should use a Balanced BST to get this down to O(log n). currently O(n).
                insert(sortedList, sum)
            }
            
            if (max === k) {
                return max
            }
        }
    }
    
    return max  
};

const lowerBound = (arr, target) => {
    return arr[binarySearch(arr, target)]
}

const binarySearch = (arr, target) => {
    let left = 0
    let right = arr.length - 1
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        if (arr[mid] == target) {
            return mid
        } else if (arr[mid] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return left
};

const insert = (arr, target) => {
    const index = binarySearch(arr, target)
    if (arr[index] != target) {
        arr.splice(index, 0, target)
    }
};
```

## 862. Shortest Subarray with Sum at Least K
```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var shortestSubarray = function(A, K) {
    let min = Infinity
    
    const preSum = [0]
    for (let i = 0; i < A.length; i++) {
        preSum.push(A[i] + preSum[preSum.length - 1])
    }
    
    const dequeue = []
    for (let i = 0; i < preSum.length; i++){
        while (dequeue.length > 0 && preSum[i] - preSum[dequeue[0]] >= K) {
            min = Math.min(min, i - dequeue[0])
            dequeue.shift()
        }
        
        while (dequeue.length > 0 && preSum[i] <= preSum[dequeue[dequeue.length - 1]]) {
            dequeue.pop()
        }
        
        dequeue.push(i)
    }
    
    return min === Infinity ? -1 : min
};
```

## 1570. Dot Product of Two Sparse Vectors
```javascript
/**
 * @param {number[]} nums
 * @return {SparseVector}
 */
var SparseVector = function(nums) {
    this.values = new Map()
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 0) continue
        this.values.set(i, nums[i])
    }
};

// Return the dotProduct of two sparse vectors
/**
 * @param {SparseVector} vec
 * @return {number}
 */
SparseVector.prototype.dotProduct = function(vec) {
    const vectorShort = this.values.size < vec.values.size ? this.values : vec.values
    const vectorLong = this.values.size < vec.values.size ? vec.values : this.values
    
    let sum = 0
    for (const [index, val] of vectorShort.entries()) {
        sum += val * (vectorLong.get(index) || 0)
    }
    
    return sum    
};

// Your SparseVector object will be instantiated and called as such:
// let v1 = new SparseVector(nums1);
// let v2 = new SparseVector(nums2);
// let ans = v1.dotProduct(v2);
```

## 790. Domino and Tromino Tiling
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var numTilings = function(N) {
    /** 
    Col States:
    0 = top and bottom free
    1 = bottom free
    2 = top free
    **/
    
    const _numTilings = (i, colState) => {
        if (i > N) return 0
        if (i === N) return colState === 0
        
        if (memo[i][colState] !== undefined) {
            return memo[i][colState]
        }
        
        if (colState === 0) {
            memo[i][colState] = _numTilings(i + 1, 0) + _numTilings(i + 2, 0) + 
                                _numTilings(i + 1, 1) + _numTilings(i + 1, 2)
        } else if (colState === 1) {
            memo[i][colState] = _numTilings(i + 2, 0) + _numTilings(i + 1, 2)
        } else if (colState === 2) {
            memo[i][colState] = _numTilings(i + 2, 0) + _numTilings(i + 1, 1)
        }
        
        memo[i][colState] %= MOD
        return memo[i][colState]
    }
    
    const MOD = 10 ** 9 + 7
    const memo = new Array(N).fill().map(a => new Array(3))
    return _numTilings(0, 0)
};
```

## 1406. Stone Game III
```javascript
// Minimax
/**
 * @param {number[]} stoneValue
 * @return {string}
 */
var stoneGameIII = function(stoneValue) {
    const _stoneGameIII = (i, maximizingPlayer) => {
        if (i >= stoneValue.length) return 0
        
        if (memo[i][maximizingPlayer] !== undefined) {
            return memo[i][maximizingPlayer]
        }
        
        let result = maximizingPlayer ? -Infinity : Infinity
        let score = 0
        for (let j = i; j < Math.min(i + 3, stoneValue.length); j++) {
            if (maximizingPlayer) {
                score += stoneValue[j]
                result = Math.max(result, score + _stoneGameIII(j + 1, maximizingPlayer ^ 1))
            } else {
                score -= stoneValue[j]
                result = Math.min(result, score + _stoneGameIII(j + 1, maximizingPlayer ^ 1))
            }    
        }
        
        memo[i][maximizingPlayer] = result
        return result
    }
    
    const memo = new Array(stoneValue.length).fill().map(a => new Array(2))
    const result = _stoneGameIII(0, 1)
    if (result > 0) return 'Alice'
    if (result < 0) return 'Bob'
    return 'Tie'
};

// Negamax
/**
 * @param {number[]} stoneValue
 * @return {string}
 */
var stoneGameIII = function(stoneValue) {
    const _stoneGameIII = i => {
        if (i >= stoneValue.length) return 0
        
        if (memo[i] !== undefined) {
            return memo[i]
        }
        
        let result = -Infinity
        let score = 0
        for (let j = i; j < Math.min(i + 3, stoneValue.length); j++) {
            score += stoneValue[j]
            result = Math.max(result, score - _stoneGameIII(j + 1))
        }
        
        memo[i] = result
        return result
    }
    
    const memo = new Array(stoneValue.length)
    const result = _stoneGameIII(0)
    if (result > 0) return 'Alice'
    if (result < 0) return 'Bob'
    return 'Tie'
};
```

## 1664. Ways to Make a Fair Array
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var waysToMakeFair = function(nums) {
    const prefixSumEven = [0]
    const prefixSumOdd = [0]
    
    for (let i = 0; i < nums.length; i++) {
        if (i % 2 === 0) {
            prefixSumEven.push(nums[i] + prefixSumEven[prefixSumEven.length - 1])
            prefixSumOdd.push(prefixSumOdd[prefixSumOdd.length - 1])
        } else {
            prefixSumOdd.push(nums[i] + prefixSumOdd[prefixSumOdd.length - 1])
            prefixSumEven.push(prefixSumEven[prefixSumEven.length - 1])
        }
    }
    
    let count = 0
    for (let i = 0; i < nums.length; i++) {
        const evenLeftSum = prefixSumEven[i]
        const oddLeftSum = prefixSumOdd[i]
        
        const oddRightSum = prefixSumEven[prefixSumEven.length - 1] - prefixSumEven[i + 1]
        const evenRightSum = prefixSumOdd[prefixSumOdd.length - 1] - prefixSumOdd[i + 1]
        
        const evenSum = evenLeftSum + evenRightSum
        const oddSum = oddLeftSum + oddRightSum
        
        count += evenSum === oddSum
    }
    
    return count
};
```

## 1706. Where Will the Ball Fall
```javascript
/**
 * @param {number[][]} grid
 * @return {number[]}
 */
var findBall = function(grid) {
    const _findBall = (row, col) => {
        if (row >= m) return col
        if (col >= n || col < 0) return -1
        
        if (memo[row][col] !== undefined) {
            return memo[row][col]
        }
        
        if (grid[row][col] === 1) {
            if (col + 1 >= n || grid[row][col + 1] === -1) {
                memo[row][col] = -1
            } else {
                memo[row][col] = _findBall(row + 1, col + 1)
            }
        } else {
            if (col - 1 < 0 || grid[row][col - 1] === 1) {
                memo[row][col] = -1
            } else {
                memo[row][col] = _findBall(row + 1, col - 1)
            }
        }
        
        return memo[row][col]
    }
    
    const m = grid.length
    const n = grid[0].length
    const memo = new Array(m).fill().map(a => new Array(n))
    
    const result = []
    for (let col = 0; col < n; col++) {
        result.push(_findBall(0, col))
    }
    return result
};
```

## 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var maxNonOverlapping = function(nums, target) {
    const map = { 0: -1 }
    let accSum = 0
    let count = 0
    let rightBound = -1
    
    for (let i = 0; i < nums.length; i++) {
        accSum += nums[i]
        const compliment = accSum - target
        
        if (map[compliment] !== undefined && map[compliment] >= rightBound) {
            count++
            rightBound = i
        }
        
        map[accSum] = i
    }
    
    return count
};
```

## 1690. Stone Game VII
```javascript
/**
 * @param {number[]} stones
 * @return {number}
 */
var stoneGameVII = function(stones) {
    const _stoneGameVII = (left, right) => {
        if (left >= right) return 0
        
        if (memo[left][right] !== undefined) {
            return memo[left][right]
        }
        
        const sumWithoutLeft = prefixSum[right] - prefixSum[left]
        const sumWithoutRight = prefixSum[right - 1] - (prefixSum[left - 1] || 0)
        const op1 = sumWithoutLeft - _stoneGameVII(left + 1, right)
        const op2 = sumWithoutRight - _stoneGameVII(left, right - 1)
        memo[left][right] = Math.max(op1, op2)
        return memo[left][right]
    }
    
    const prefixSum = []
    for (const stone of stones) {
        prefixSum.push(stone + (prefixSum[prefixSum.length - 1] || 0))
    }
    
    const n = stones.length
    const memo = Array(n).fill().map(a => Array(n))
    return _stoneGameVII(0, stones.length - 1)
};
```

## 808. Soup Servings
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var soupServings = function(N) {
    const _soupServings = (A, B) => {
        if (A > 0 && B <= 0) return 0
        if (A <= 0 && B > 0) return 1
        if (A <= 0 && B <= 0) return 0.5
        
        if (memo[A][B] !== undefined) return memo[A][B]
        
        const prob = 0.25 * (_soupServings(A - 100, B) + 
                            _soupServings(A - 75, B - 25) +
                            _soupServings(A - 50, B - 50) +
                            _soupServings(A - 25, B - 75))
        memo[A][B] = prob
        return memo[A][B]
    }
    
    if (N > 4800) return 1
    const memo = new Array(N + 1).fill().map(a => new Array(N + 1))
    return _soupServings(N, N)
};
```

## 1186. Maximum Subarray Sum with One Deletion
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var maximumSum = function(arr) {    
    let max = -Infinity
    
    const prefix = new Array(arr.length)
    let localMax = -Infinity
    for (let i = 0; i < arr.length; i++) {
        localMax = Math.max(localMax + arr[i], arr[i])
        max = Math.max(localMax, max)
        prefix[i] = localMax
    }
    
    const suffix = new Array(arr.length)
    localMax = -Infinity
    for (let i = arr.length - 1; i >= 0; i--) {
        localMax = Math.max(localMax + arr[i], arr[i])
        max = Math.max(localMax, max)
        suffix[i] = localMax
    }
    
    for (let i = 1; i < arr.length - 1; i++) {
        max = Math.max(max, prefix[i - 1] + suffix[i + 1])
    }
    
    return max
};
```

## 1409. Queries on a Permutation With Key
```javascript
/**
 * @param {number[]} queries
 * @param {number} m
 * @return {number[]}
 */
var processQueries = function(queries, m) {
    // Ideally a LinkedList or Deque for O(1) insertions to front
    const arr = []
    for (let i = 1; i <= m; i++) {
        arr.push(i)
    }
    
    const result = []
    for (const query of queries) {
        const index = arr.indexOf(query)
        const val = arr[index]
        result.push(index)
        arr.splice(index, 1)
        arr.unshift(val)
    }
    
    return result
};
```

## 1725. Number Of Rectangles That Can Form The Largest Square
```javascript
/**
 * @param {number[][]} rectangles
 * @return {number}
 */
var countGoodRectangles = function(rectangles) {
    let maxLength = 0
    let maxCount = 0
    
    for (const [length, width] of rectangles) {
        const sideLength = Math.min(length, width)
        
        if (maxLength === sideLength) {
            maxCount++
        } else if (maxLength < sideLength) {
            maxCount = 1
            maxLength = sideLength
        }
    }
    
    return maxCount
};
```

## 1726. Tuple with Same Product
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var tupleSameProduct = function(nums) {
    const map = {}
    let count = 0
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            const product = nums[i] * nums[j]
            const combo = map[product] || 0
            count += 8 * combo
            map[product] = 1 + (map[product] || 0) 
        }
    }
    return count
};
```

## 1727. Largest Submatrix With Rearrangements
```javascript
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var largestSubmatrix = function(matrix) {
    const m = matrix.length
    const n = matrix[0].length
    
    for (let col = 0; col < n; col++) {
        for (let row = m - 1; row >= 0; row--) {
            if (matrix[row][col]) {
                if (row < m - 1) {
                    matrix[row][col] += matrix[row + 1][col]
                }
            }
        }
    }
    
    let max = 0
    for (let row = 0; row < m; row++) {
        const sortedArr = matrix[row].slice().sort((a, b) => b - a)
        for (let col = 0; col < n; col++) {
            max = Math.max(max, sortedArr[col] * (col + 1))
        }
    }
    
    return max
};
```

## 85. Maximal Rectangle
```javascript
// DP
// https://www.youtube.com/watch?v=PrNAjqoo83k
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
    if (!matrix.length || !matrix[0].length) return 0
    
    const m = matrix.length
    const n = matrix[0].length
    
    const height = new Array(n).fill(0)
    const left = new Array(n).fill(0)
    const right = new Array(n).fill(n - 1)
    
    let maxArea = 0
    for (let row = 0; row < m; row++) {
        let leftMostCol = 0
        let rightMostCol = n - 1
        for (let col = 0; col < n; col++) {
            if (matrix[row][col] == 1) {
                height[col] += 1
                
                left[col] = Math.max(left[col], leftMostCol)
            } else {
                height[col] = 0
                
                left[col] = 0
                leftMostCol = col + 1
            }
            
            const oppCol = n - col - 1
            if (matrix[row][oppCol] == 1) {
                right[oppCol] = Math.min(right[oppCol], rightMostCol)
            } else {
                right[oppCol] = n - 1
                rightMostCol = oppCol - 1
            }
        }
        
        for (let col = 0; col < n; col++) {
            maxArea = Math.max(maxArea, height[col] * (right[col] - left[col] + 1))
        }
    }
    
    return maxArea
};

// Largest Histogram
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
    if (!matrix.length || !matrix[0].length) return 0
    
    const m = matrix.length
    const n = matrix[0].length
    
    const histogram = new Array(n).fill(0)
    
    let max = 0
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (matrix[row][col] === '0') { 
                histogram[col] = 0
            } else {
                histogram[col]++
            }
        }
        
        max = Math.max(max, largestRectangleArea(histogram))
    }
    
    return max
};

const largestRectangleArea = histogram => {
    const stack = [-1]
    let max = 0
    for (let i = 0; i < histogram.length; i++) {
        while (stack.length > 1 && histogram[stack[stack.length - 1]] > histogram[i]) {
            const height = histogram[stack.pop()]
            const width = i - stack[stack.length - 1] - 1
            max = Math.max(max, width * height)
        }
        
        stack.push(i)
    }
    
    while (stack.length > 1) {
        const height = histogram[stack.pop()]
        const width = histogram.length - stack[stack.length - 1] - 1
        max = Math.max(max, width * height)
    }
    
    return max
}
```

## 1729. Find Followers Count
```sql
# Write your MySQL query statement below
SELECT user_id, COUNT(*) AS followers_count
FROM Followers
GROUP BY user_id
ORDER BY user_id
```

## 4. Median of Two Sorted Arrays
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    const sArr = nums1.length < nums2.length ? nums1 : nums2
    const lArr = nums1.length < nums2.length ? nums2 : nums1
    
    let left = 0
    let right = sArr.length
    while (left <= right) {
        const pivot = Math.floor((right - left) / 2) + left
        
        const [sLeft, sRight, lLeft, lRight] = getIndices(pivot, sArr, lArr)
        const direction = getDirection(sLeft, sRight, lLeft, lRight, sArr, lArr)
        if (direction === 0) {
            return getResult(sLeft, sRight, lLeft, lRight, sArr, lArr)
        } else if (direction < 0) {
            right = pivot - 1
        } else {
            left = pivot + 1
        }
    }
};

const getResult = (sLeft, sRight, lLeft, lRight, sArr, lArr) => {
    const len = sArr.length + lArr.length
    if (len % 2 === 0) {
        return (Math.max(getValue(sLeft, sArr), getValue(lLeft, lArr)) + 
                Math.min(getValue(sRight, sArr), getValue(lRight, lArr))) / 2
    } else {
        return Math.min(getValue(sRight, sArr), getValue(lRight, lArr))
    }
}

const getValue = (i, arr) => {
    if (i <= -1) return -Infinity
    if (i >= arr.length) return Infinity
    return arr[i]
}

const getDirection = (sLeft, sRight, lLeft, lRight, sArr, lArr) => {
    if (getValue(sLeft, sArr) > getValue(lRight, lArr)) return -1
    if (getValue(lLeft, lArr) > getValue(sRight, sArr)) return 1
    return 0
}

const getIndices = (pivot, sArr, lArr) => {
    const mid = Math.floor((lArr.length - sArr.length) / 2) + sArr.length
    const sLeft = pivot - 1
    const sRight = pivot
    const lRight = mid - sRight
    const lLeft = lRight - 1
    return [sLeft, sRight, lLeft, lRight]
}
```

## 386. Lexicographical Numbers
```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var lexicalOrder = function(n) {
    const _lexicalOrder = (num) => {
        if (num > n) return
        result.push(num)
        
        for (let digit = 0; digit <= 9; digit++) {
            const nextNum = num * 10 + digit
            if (nextNum > n) return
            _lexicalOrder(nextNum)
        }
    }
    
    const result = []
    for (let digit = 1; digit <= 9; digit++) {
        _lexicalOrder(digit)
    }
    return result
};
```

## 81. Search in Rotated Sorted Array II
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {boolean}
 */
var search = function(nums, target) {
    let left = 0
    let right = nums.length - 1
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (nums[mid] === target) return true
        
        while (left < mid && nums[left] === nums[mid]) {
            left++
        }
        
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if (nums[right] >= target && target > nums[mid]) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    
    return false
};
```

## 723. Candy Crush
```javascript
/**
 * @param {number[][]} board
 * @return {number[][]}
 */
var candyCrush = function(board) {
    const m = board.length
    const n = board[0].length
    
    let done = false
    while (!done) {
        done = true
        
        // Tag Rows
        for (let row = 0; row < m; row++) {
            for (let col = 0; col < n - 2; col++) {
                const num1 = Math.abs(board[row][col])
                const num2 = Math.abs(board[row][col + 1])
                const num3 = Math.abs(board[row][col + 2])
                
                if (num1 === num2 && num2 === num3 && num1 !== 0) {
                    board[row][col] = -num1
                    board[row][col + 1] = -num2
                    board[row][col + 2] = -num3
                    done = false
                }
            }
        }
        
        // Tag Cols
        for (let col = 0; col < n; col++) {
            for (let row = 0; row < m - 2; row++) {
                const num1 = Math.abs(board[row][col])
                const num2 = Math.abs(board[row + 1][col])
                const num3 = Math.abs(board[row + 2][col])
                
                if (num1 === num2 && num2 === num3 && num1 !== 0) {
                    board[row][col] = -num1
                    board[row + 1][col] = -num2
                    board[row + 2][col] = -num3
                    done = false
                }
            }
        }
        
        if (done) break
        
        // Crush
        for (let col = 0; col < n; col++) {
            let endIndex = m - 1
            for (let row = m - 1; row >= 0; row--) {
                if (board[row][col] > 0) {
                    board[endIndex][col] = board[row][col]
                    endIndex--
                }
            }
            
            for (let row = endIndex; row >= 0; row--) {
                board[row][col] = 0
            }
        }
    }
    
    return board
};
```

## 565. Array Nesting
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayNesting = function(nums) {
    let max = 0
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === Infinity) continue
        
        let count = 0
        let index = i
        while (nums[index] !== Infinity) {
            const temp = index
            index = nums[index]
            count++
            nums[temp] = Infinity
        }
        
        if (count >= nums.length / 2) return count
        max = Math.max(max, count)
    }
    
    return max
};
```

## 229. Majority Element II
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
    let candidate1 = NaN
    let candidate2 = NaN
    let count1 = 0
    let count2 = 0
    
    for (const num of nums) {
        if (candidate1 === num) {
            count1++
        } else if (candidate2 === num) {
            count2++
        } else if (count1 === 0) {
            candidate1 = num
            count1 = 1
        } else if (count2 === 0) {
            candidate2 = num
            count2 = 1
        } else {
            count1--
            count2--
        }
    }
    
    count1 = 0
    count2 = 0
    
    for (const num of nums) {
        if (candidate1 === num) {
            count1++
        } else if (candidate2 === num) {
            count2++
        }
    }
    
    const result = []
    if (count1 > nums.length / 3) {
        result.push(candidate1)
    }
    
    if (count2 > nums.length / 3) {
        result.push(candidate2)
    }
    
    return result
};
```

## 1250. Check If It Is a Good Array
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var isGoodArray = function(nums) {
    let gcd = nums[0]
    for (let i = 1; i < nums.length; i++) {
        gcd = getGCD(nums[i], gcd)
    }
    return gcd === 1
};

const getGCD = (a, b) => {
    while (b !== 0) {
        const temp = b
        b = a % b
        a = temp
    }
    
    return a
}
```

## 1730. Shortest Path to Get Food
```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var getFood = function(grid) {
    const m = grid.length
    const n = grid[0].length
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    
    const queue = []
    for (let row = 0; row < m; row++) {
        for (let col = 0; col < n; col++) {
            if (grid[row][col] === '*') {
                queue.push([row, col])
            }
        }
    }
    
    const visited = new Array(m).fill().map(a => new Array(n).fill(false))
    let depth = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [row, col] = queue.shift()
            
            for (const [deltaRow, deltaCol] of dirs) {
                const nextRow = deltaRow + row
                const nextCol = deltaCol + col
                
                if (nextRow < 0 || nextRow >= m || 
                    nextCol < 0 || nextCol >= n ||
                    grid[nextRow][nextCol] === 'X' ||
                    visited[nextRow][nextCol]) {
                    continue
                }
                
                if (grid[nextRow][nextCol] === '#') {
                    return depth + 1
                }
                
                visited[nextRow][nextCol] = true
                queue.push([nextRow, nextCol])
            }
        }
        depth++
    }
    
    return -1
};
```

## 1335. Minimum Difficulty of a Job Schedule
```javascript
/**
 * @param {number[]} jobDifficulty
 * @param {number} d
 * @return {number}
 */
var minDifficulty = function(jobDifficulty, d) {
    const _minDifficulty = (i, d) => {
        if (d == 0 && i == n) return 0
        if (d == 0 || i == n) return Infinity
        
        if (memo[i][d] !== undefined) {
            return memo[i][d]
        }
        
        let result = Infinity
        let max = 0
        for (let cutIndex = i; cutIndex < n - d + 1; cutIndex++) {
            max = Math.max(max, jobDifficulty[cutIndex])
            result = Math.min(result, max + _minDifficulty(cutIndex + 1, d - 1))
        }
        
        memo[i][d] = result
        return memo[i][d]
    }
    
    const n = jobDifficulty.length
    if (n < d) return -1
    
    const memo = new Array(n).fill().map(a => new Array(d))
    return _minDifficulty(0, d)
};
```

## 472. Concatenated Words
```javascript
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    const availableWords = new Set(words)
    const result = []
    
    for (const word of words) {
        availableWords.delete(word)
        
        if (canBreak(word, availableWords)) {
            result.push(word)
        }
        
        availableWords.add(word)
    }
    
    return result
};

const canBreak = (word, set) => {
    const n = word.length
    if (set.size <= 0 || n === 0) return false
    
    const dp = new Array(n).fill(false)
    dp[0] = true
    
    for (let i = 1; i <= word.length; i++) {
        for (let j = 0; j < i; j++) {       
            if (dp[j] && set.has(word.slice(j, i))) {
                dp[i] = true
                break
            }
        }
    }
    
    return dp[word.length]
}
```

## 1238. Circular Permutation in Binary Representation
```javascript
/**
 * @param {number} n
 * @param {number} start
 * @return {number[]}
 */
var circularPermutation = function(n, start) {
    const result = [0]
    let startIndex = 0
    for (let bit = 0; bit < n; bit++) {
        const size = result.length
        for (let j = size - 1; j >= 0; j--) {
            const grayCode = result[j] | 1 << bit
            if (grayCode === start) {
                startIndex = result.length
            }
            result.push(grayCode)
        }
    }
    
    return leftRotate(result, startIndex)
};

const leftRotate = (arr, k) => {
    reverse(arr, 0, arr.length - 1)
    reverse(arr, 0, arr.length - k - 1)
    reverse(arr, arr.length - k, arr.length - 1)
    return arr
}

const reverse = (arr, i, j) => {
    while (i < j) {
        const temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
        
        i++
        j--
    }
}
```

## 1274. Number of Ships in a Rectangle
```javascript
/**
 * // This is Sea's API interface.
 * // You should not implement it, or speculate about its implementation
 * function Sea() {
 *     @param {integer[]} topRight
 *     @param {integer[]} bottomLeft
 *     @return {boolean}
 *     this.hasShips = function(topRight, bottomLeft) {
 *         ...
 *     };
 * };
 */

/**
 * @param {Sea} sea
 * @param {integer[]} topRight
 * @param {integer[]} bottomLeft
 * @return {integer}
 */
var countShips = function(sea, topRight, bottomLeft) {
    const _countShips = (top, right, bottom, left) => {
        if (top < bottom || left > right) {
            return 0
        }
        
        if (!sea.hasShips([top, right], [bottom, left])) {
            return 0
        }
        
        if (top === bottom && left === right) {
            return 1
        }
        
        let ships = 0
        
        const midX = Math.trunc((right - left) / 2) + left
        const midY = Math.trunc((bottom - top) / 2) + top
        
        // top left
        ships += _countShips(top, midX, midY, left)
        // top right
        ships += _countShips(top, right, midY, midX + 1)
        // bottom left
        ships += _countShips(midY - 1, midX, bottom, left)
        // bottom right
        ships += _countShips(midY - 1, right, bottom, midX + 1)
        
        return ships
    }
    
    return _countShips(topRight[0], topRight[1], bottomLeft[0], bottomLeft[1])
};
```

## 30. Substring with Concatenation of All Words
```javascript
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
    const result = []
    
    const wordsFreq = {}
    for (const word of words) {
        wordsFreq[word] = 1 + (wordsFreq[word] || 0)
    }
    
    const sLen = s.length
    const wordLen = words[0].length
    const targetLen = wordLen * words.length
    
    outer : for (let targetStartIndex = 0; targetStartIndex < sLen - targetLen + 1; targetStartIndex++) {
        const map = {}
        let wordStartIndex = targetStartIndex
        for (let i = 0; i < words.length; i++) {
            const word = s.slice(wordStartIndex, wordStartIndex + wordLen)
            if (wordsFreq[word] === undefined) continue outer
            
            map[word] = 1 + (map[word] || 0)
            if (wordsFreq[word] < map[word]) continue outer
            
            wordStartIndex += wordLen
        }
        
        result.push(targetStartIndex)
    }
    
    return result
};
```

## 829. Consecutive Numbers Sum
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var consecutiveNumbersSum = function(N) {
    let count = 0
    let i = 1
    while (N > 0) {
        N -= i
        count += N % i === 0
        i++
    }
    
    return count
};
```

## 1652. Defuse the Bomb
```javascript
/**
 * @param {number[]} code
 * @param {number} k
 * @return {number[]}
 */
var decrypt = function(code, k) {
    if (k === 0) {
        return new Array(code.length).fill(0)
    }
    
    const result = new Array(code.length)
    for (let i = 0; i < code.length; i++) {
        let sum = 0
        let index = i
        for (let j = 0; j < Math.abs(k); j++) {
            if (k > 0) {
                index = goNext(index, code)
            } else {
                index = goPrev(index, code)
            }
            sum += code[index]
        }
        result[i] = sum
    }
    
    return result
};

const goNext = (index, code) => {
    if (index === code.length - 1) {
        return 0
    }
    
    return index + 1
}

const goPrev = (index, code) => {
    if (index === 0) {
        return code.length - 1
    }
    
    return index - 1
}
```

## 1720. Decode XORed Array
```javascript
/**
 * @param {number[]} encoded
 * @param {number} first
 * @return {number[]}
 */
var decode = function(encoded, first) {
    const result = [first]
    for (const code of encoded) {
        result.push(result[result.length - 1] ^ code)
    }
    
    return result
};
```

## 1716. Calculate Money in Leetcode Bank
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var totalMoney = function(n) {
    let amount = 0
    let day = 1
    
    const weeks = Math.floor(n / 7)
    for (let week = 0; week < weeks; week++) {
        amount += 28 + (week * 7) 
        day += 7
    }
    
    let start = 1 + weeks
    while (day <= n) {
        amount += start++
        day++
    }
    
    return amount
};
```

## 1095. Find in Mountain Array
```javascript
/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * function MountainArray() {
 *     @param {number} index
 *     @return {number}
 *     this.get = function(index) {
 *         ...
 *     };
 *
 *     @return {number}
 *     this.length = function() {
 *         ...
 *     };
 * };
 */

/**
 * @param {number} target
 * @param {MountainArray} mountainArr
 * @return {number}
 */
var findInMountainArray = function(target, mountainArr) {
    const length = mountainArr.length()
    
    // find peak
    let left = 0
    let right = length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (mountainArr.get(mid) > mountainArr.get(mid + 1)) {
            right = mid
        } else {
            left = mid + 1
        }
    }
    
    const peak = left
    
    // search left
    const leftIndex = binarySearch(mountainArr, target, 0, peak, false)
    if (leftIndex !== -1) return leftIndex
    
    // search right
    const rightIndex = binarySearch(mountainArr, target, peak + 1, length - 1, true)
    if (rightIndex !== -1) return rightIndex
    
    return -1
};

const binarySearch = (arr, target, left, right, searchReversed) => {
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        
        const midVal = arr.get(mid)
        if (midVal === target) {
            return mid
        } else if (midVal < target) {
            if (searchReversed) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if (searchReversed) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    
    return -1
}
```

## 134. Gas Station
```javascript
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
    let start = 0
    let currGas = 0
    let totalGas = 0
    
    for (let i = 0; i < gas.length; i++) {
        totalGas += gas[i] - cost[i]
        currGas += gas[i] - cost[i]
        
        if (currGas < 0) {
            currGas = 0
            start = (i + 1) % gas.length
        }
    }
    
    if (totalGas < 0) return -1
    return start
};
```

## 1731. The Number of Employees Which Report to Each Employee
```sql
# Write your MySQL query statement below
SELECT e1.employee_id, e1.name, COUNT(*) AS reports_count, ROUND(AVG(e2.age)) AS average_age
FROM Employees AS e1
JOIN Employees AS e2
ON e1.employee_id = e2.reports_to
GROUP BY e1.employee_id
ORDER BY e1.employee_id
```

## 260. Single Number III
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function(nums) {
    let xorAll = 0
    for (const num of nums) {
        xorAll ^= num
    }
    
    const firstDifferentBit = xorAll & -xorAll
    const result = [0, 0]
    
    for (const num of nums) {
        if (num & firstDifferentBit) {
            result[0] ^= num
        } else {
            result[1] ^= num
        }
    }
    
    return result
};
```

## 1062. Longest Repeating Substring
```javascript
/**
 * @param {string} S
 * @return {number}
 */
var longestRepeatingSubstring = function(S) {
    let left = 1
    let right = S.length
    
    let result = 0
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        const curr = hasDup(S, mid)
        if (curr !== '') {
            result = Math.max(result, curr.length)
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return result
};

const hasDup = (str, size) => {
    const MOD = 2 ** 32
    const base = 26
    
    let baseToMaxPow = 1
    for (let i = 1; i < size; i++) {
        baseToMaxPow *= base
        baseToMaxPow %= MOD
    }
    
    let rollingHash = 0
    for (let i = 0; i < size; i++) {
        rollingHash *= base
        rollingHash %= MOD
        rollingHash += str[i].charCodeAt(0)
        rollingHash %= MOD
    }
    
    const seen = {}
    seen[rollingHash] = [0]
    
    for (let endIndex = size; endIndex < str.length; endIndex++) {
        const startIndex = endIndex - size
        
        rollingHash -= ((str[startIndex].charCodeAt(0) * baseToMaxPow) % MOD)
        rollingHash *= base
        rollingHash %= MOD
        rollingHash += str[endIndex].charCodeAt(0)
        rollingHash %= MOD
        
        if (seen[rollingHash]) {
            for (const prevStartIndex of seen[rollingHash]) {
                const prev = str.slice(prevStartIndex, prevStartIndex + size)
                const candidate = str.slice(startIndex + 1, endIndex + 1)
                if (prev === candidate) {
                    return str.slice(startIndex + 1, endIndex + 1)
                }
            }
            
            seen[rollingHash].push(startIndex + 1)
        } else {
            seen[rollingHash] = [startIndex + 1]
        }
    }
    
    return ''
}
```

## 1055. Shortest Way to Form String
```javascript
// Binary Search
/**
 * @param {string} source
 * @param {string} target
 * @return {number}
 */
var shortestWay = function(source, target) {
    const map = {}
    for (let i = 0; i < source.length; i++) {
        if (!map[source[i]]) map[source[i]] = []
        map[source[i]].push(i)
    }

    let count = 1
    let index = -1
    for (const char of target) {
        if (map[char] === undefined) {
            return -1
        }
        
        const nextIndex = binarySearch(map[char], index)
        if (nextIndex === -1) {
            count++
            index = map[char][0]
        } else {
            index = nextIndex
        }
    }
    
    return count    
};

const binarySearch = (arr, target) => {
    if (!arr || !arr.length) return -1
    
    let left = 0
    let right = arr.length
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid] <= target) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    if (left >= arr.length) return -1
    return arr[left]
}

// Linear
/**
 * @param {string} source
 * @param {string} target
 * @return {number}
 */
var shortestWay = function(source, target) {
    const nextIndexMap = new Array(26).fill().map(a => new Array(source.length).fill(-1))
    
    for (let charIndex = 0; charIndex < 26; charIndex++) {
        const charArr = nextIndexMap[charIndex]
        let nextIndex = -1
        for (let sourceIndex = charArr.length - 1; sourceIndex >= 0; sourceIndex--) {
            if (source[sourceIndex] === charForPos(charIndex)) {
                nextIndex = sourceIndex
            }
            nextIndexMap[charIndex][sourceIndex] = nextIndex
        }
    }
    
    let count = 1
    let index = 0
    for (const char of target) {
        if (nextIndexMap[posForChar(char)][0] === -1) return -1
        
        if (index >= source.length) {
            index = 0
            count++
        }
        
        const nextIndex = nextIndexMap[posForChar(char)][index]
        if (nextIndex === -1) {
            count++
            index = nextIndexMap[posForChar(char)][0] + 1
        } else {
            index = nextIndex + 1
        }
    }
    
    return count    
};

const posForChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
const charForPos = pos => String.fromCharCode(pos + 'a'.charCodeAt(0))
```

## 889. Construct Binary Tree from Preorder and Postorder Traversal
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} pre
 * @param {number[]} post
 * @return {TreeNode}
 */
var constructFromPrePost = function(pre, post) {
    const _constructFromPrePost = (preStart, preEnd, postStart, postEnd) => {
        if (preStart > preEnd) return null
        
        const node = new TreeNode(pre[preStart])
        if (preStart === preEnd) return node
        
        const postIndex = map[pre[preStart + 1]]
        const leftSubLen = postIndex - postStart + 1
        node.left = _constructFromPrePost(preStart + 1, 
                                          preStart + leftSubLen, 
                                          postStart, 
                                          postIndex)
        
        node.right = _constructFromPrePost(preStart + leftSubLen + 1, 
                                           preEnd, 
                                           postIndex + 1, 
                                           postEnd - 1)        
        return node        
    }
    
    const map = {}
    for (let i = 0; i < post.length; i++) {
        map[post[i]] = i
    }
    
    return _constructFromPrePost(0, pre.length - 1, 0, post.length - 1)
};
```

## 1145. Binary Tree Coloring Game
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} n
 * @param {number} x
 * @return {boolean}
 */
var btreeGameWinningMove = function(root, n, x) {
    const _btreeGameWinningMove = node => {
        if (!node) return 0
        
        const leftCount = _btreeGameWinningMove(node.left)
        const rightCount = _btreeGameWinningMove(node.right)
        
        if (node.val === x) {
            left = leftCount
            right = rightCount
        }
        
        return 1 + leftCount + rightCount
    }
    
    let left = 0
    let right = 0
    _btreeGameWinningMove(root)
    return Math.max(left, right, n - left - right - 1) > n / 2
};
```

## 536. Construct Binary Tree from String
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {string} s
 * @return {TreeNode}
 */
var str2tree = function(s) {
    const _str2tree = t => {
        if (i >= s.length) return null
        
        let num = 0
        let sign = 1
        while (isNum(s[i]) || s[i] === '-') {
            if (s[i] === '-') {
                sign = -1
            } else {
                num *= 10
                num += +s[i]
            }
            
            i++
        }
        
        num *= sign
        
        const node = new TreeNode(num)
        if (s[i] === '(') {
            i++
            node.left = _str2tree()
        }
        
        if (s[i] === '(') {
            i++
            node.right = _str2tree()
        }
        
        i++
        return node
    }
    
    let i = 0
    return _str2tree()
};

const isNum = char => !isNaN(+char)
```

## 562. Longest Line of Consecutive One in Matrix
```javascript
/**
 * @param {number[][]} M
 * @return {number}
 */
var longestLine = function(M) {
    if (!M.length) return 0
    
    const rowLen = M.length
    const colLen = M[0].length
    
    let max = 0
    let prev = new Array(colLen + 2).fill().map(a => new Array(4).fill(0))
    for (let row = 0; row < rowLen; row++) {
        const curr = new Array(colLen + 2).fill().map(a => new Array(4).fill(0))
        for (let col = 1; col < curr.length - 1; col++) {
            if (M[row][col - 1] === 1) {
                // horizontal
                curr[col][0] = 1 + curr[col - 1][0]
                // vertical
                curr[col][1] = 1 + prev[col][1]
                // diagonal
                curr[col][2] = 1 + prev[col + 1][2]
                // anti-diagonal
                curr[col][3] = 1 + prev[col - 1][3]
            }
            
            max = Math.max(max, ...curr[col])
        }
        prev = curr
    }
    
    return max
};
```

## 395. Longest Substring with At Least K Repeating Characters
```javascript
// Divide And Conquer
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var longestSubstring = function(s, k) {
    const _longestSubstring = (start, end) => {
        if (start > end) return 0
        
        const counts = new Array(26).fill(0)
        for (let i = start; i <= end; i++) {
            const index = posFromChar(s[i])
            counts[index]++
        }
        
        let mid = start
        while (mid <= end && counts[posFromChar(s[mid])] >= k) {
            mid++
        }
        
        if (mid > end) {
            return end - start + 1
        }
        
        const left = _longestSubstring(start, mid - 1)
        while (mid <= end && counts[posFromChar(s[mid])] < k) {
            mid++
        }
        const right = _longestSubstring(mid, end)
        return Math.max(left, right)
    }
    
    return _longestSubstring(0, s.length - 1)
};

const posFromChar = char => char.charCodeAt(0) - 'a'.charCodeAt(0)
```

## 1718. Construct the Lexicographically Largest Valid Sequence
```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var constructDistancedSequence = function(n) {
    const _constructDistancedSequence = (i) => {
        if (i === size) return true
        if (result[i] !== 0) return _constructDistancedSequence(i + 1)
        
        for (let int = n; int >= 1; int--) {
            if (used[int]) continue
            
            if (int === 1) {
                result[i] = int
                used[int] = true

                if (_constructDistancedSequence(i + 1))
                    return true
                
                result[i] = 0
                used[int] = false
            } else if (i + int < size && result[i + int] === 0) {
                result[i] = int
                result[i + int] = int
                used[int] = true

                if (_constructDistancedSequence(i + 1))
                    return true

                result[i] = 0
                result[i + int] = 0
                used[int] = false
            }
        }
        
        return false
    }
    
    const size = 1 + (n - 1) * 2
    const result = new Array(size).fill(0)
    const used = new Array(n + 1).fill(false)
    _constructDistancedSequence(0)
    return result
};
```

## 991. Broken Calculator
```javascript
/**
 * @param {number} X
 * @param {number} Y
 * @return {number}
 */
var brokenCalc = function(X, Y) {
    let count = 0
    while (Y > X) {
        count++
        if (Y % 2 === 1) {
            Y++
        } else {
            Y = Math.floor(Y / 2)
        }
    }
    
    return count + X - Y
};
```

## 549. Binary Tree Longest Consecutive Sequence II
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestConsecutive = function(root) {
    const _longestConsecutive = (node, parent) => {
        if (!node) return [0, 0]
        
        const [leftInc, leftDec] = _longestConsecutive(node.left, node)
        const [rightInc, rightDec] = _longestConsecutive(node.right, node)
        max = Math.max(max, leftInc + rightDec + 1, leftDec + rightInc + 1)
        
        if (parent && node.val + 1 === parent.val) {
            return [Math.max(leftInc, rightInc) + 1, 0]
        } else if (parent && node.val - 1 === parent.val) {
            return [0, Math.max(leftDec, rightDec) + 1]
        }
        
        return [0, 0]
    }
    
    let max = 0
    _longestConsecutive(root, null)
    return max
};
```

## 154. Find Minimum in Rotated Sorted Array II
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    let left = 0
    let right = nums.length - 1
    
    while (left < right) {
        let mid = Math.floor((right - left) / 2) + left
        
        if (nums[mid] > nums[right]) {
            left = mid + 1
        } else if (nums[mid] < nums[right]) {
            right = mid
        } else {
            right--
        }
    }
    
    return nums[left]
};
```

## 32. Longest Valid Parentheses
```javascript
// Stack - O(n)
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    const stack = [-1]
    let max = 0
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i)
        } else {
            stack.pop()
            if (!stack.length) {
                stack.push(i)
            } else {
                max = Math.max(max, i - stack[stack.length - 1])
            }
        }
    }
    
    return max
};

// Linear O(1) space
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    let max = 0
    
    let left = 0
    let right = 0
    for (const char of s) {
        char === '(' ? left++ : right++
        
        if (left === right) {
            max = Math.max(max, left + right)
        } else if (left < right) {
            left = 0
            right = 0
        }
    }
    
    left = 0
    right = 0
    for (let i = s.length - 1; i >= 0; i--) {
        const char = s[i]
        char === '(' ? left++ : right++
        
        if (left === right) {
            max = Math.max(max, left + right)
        } else if (left > right) {
            left = 0
            right = 0
        }
    }
    
    return max
};
```

## 1478. Allocate Mailboxes
```javascript
// Time: O(n^3 + k * n^2)
/**
 * @param {number[]} houses
 * @param {number} k
 * @return {number}
 */
var minDistance = function(houses, k) {
    const _minDistance = (startIndex, k) => {
        if (startIndex >= sortedHouses.length && k === 0) return 0
        if (startIndex >= sortedHouses.length || k === 0) return Infinity
        
        if (memo[startIndex][k] !== undefined) {
            return memo[startIndex][k]
        }
        
        let min = Infinity
        for (let endIndex = startIndex; endIndex <= sortedHouses.length - k; endIndex++) {
            min = Math.min(min, dist[startIndex][endIndex] + _minDistance(endIndex + 1, k - 1))
        }
        
        memo[startIndex][k] = min
        return min
    }
    
    const n = houses.length
    const sortedHouses = houses.sort((a, b) => a - b)
    
    // Precompute Dists For Groups - House at Median is always optimal
    const dist = new Array(n).fill().map(a => new Array(n).fill(0))
    for (let endIndex = 1; endIndex < sortedHouses.length; endIndex++) {
        for (let startIndex = 0; startIndex < endIndex; startIndex++) {
            let currDist = 0
            const medianIndex = Math.trunc((endIndex - startIndex) / 2) + startIndex
            for (let currIndex = startIndex; currIndex <= endIndex; currIndex++) {
                currDist += Math.abs(sortedHouses[medianIndex] - sortedHouses[currIndex])
            }
            dist[startIndex][endIndex] = currDist
        }
    }
    
    // DP for K Contiguous Groups
    const memo = new Array(n).fill().map(a => new Array(k))
    return _minDistance(0, k)
};
```

## 296. Best Meeting Point
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minTotalDistance = function(grid) {
    const n = grid.length
    const m = grid[0].length
    
    const rows = []
    for (let row = 0; row < n; row++) {
        for (let col = 0; col < m; col++) {
            if (grid[row][col] === 1) {
                rows.push(row)
            }
        }
    }
    
    const cols = []
    for (let col = 0; col < m; col++) {
        for (let row = 0; row < n; row++) {
            if (grid[row][col] === 1) {
                cols.push(col)
            }
        }
    }
    
    const rowMedian = Math.floor(rows.length / 2)
    let rowSum = 0
    for (const row of rows) {
        rowSum += Math.abs(row - rows[rowMedian])
    }
    
    const colMedian = Math.floor(cols.length / 2)
    let colSum = 0
    for (const col of cols) {
        colSum += Math.abs(col - cols[colMedian])
    }
    
    return rowSum + colSum
};
```

## 857. Minimum Cost to Hire K Workers
```javascript
/**
 * @param {number[]} quality
 * @param {number[]} wage
 * @param {number} K
 * @return {number}
 */
var mincostToHireWorkers = function(quality, wage, K) {
    const workers = []
    for (let i = 0; i < quality.length; i++) {
        workers.push([quality[i], wage[i], wage[i] / quality[i]])
    }
    
    workers.sort((a, b) => a[2] - b[2])
    
    const heap = new Heap([], ((a, b) => a > b))
    let min = Infinity
    let totalQuality = 0
    for (const [q, w, r] of workers) {
        heap.insert(q)
        totalQuality += q
        
        if (heap.size() > K) {
            totalQuality -= heap.remove()
        }
        
        if (heap.size() === K) {
            min = Math.min(min, totalQuality * r)
        }
    }
    
    return min
};

class Heap {
    constructor(elements = [], sort = ((a, b) => { return a < b })) {
        this._elements = elements
        this._sort = sort
        this._heapify()
    }

    _heapify() {
        for (let i = Math.floor(this._elements.length / 2) - 1; 0 <= i; i--) {
          this._siftDown(i);
        }
    }

    _siftUp(index) {
        let childIndex = index
        let parentIndex = this._parentIndex(childIndex)

        while (childIndex > 0 && 
               this._sort(this._elements[childIndex], this._elements[parentIndex])) {
          let temp = this._elements[childIndex]
          this._elements[childIndex] = this._elements[parentIndex]
          this._elements[parentIndex] = temp

          childIndex = parentIndex
          parentIndex = this._parentIndex(childIndex)
        }
    }

    _siftDown(index) {
        let parentIndex = index
        while (true) {
          let leftIndex = this._leftChildIndex(parentIndex)
          let rightIndex = this._rightChildIndex(parentIndex)
          let candidate = parentIndex

          if (leftIndex < this._elements.length && 
              this._sort(this._elements[leftIndex], this._elements[candidate])) {
            candidate = leftIndex
          }

          if (rightIndex < this._elements.length && 
              this._sort(this._elements[rightIndex], this._elements[candidate])) {
            candidate = rightIndex
          }

          if (parentIndex === candidate) {
            return
          }

          let temp = this._elements[parentIndex]
          this._elements[parentIndex] = this._elements[candidate]
          this._elements[candidate] = temp

          parentIndex = candidate
        }   
    }

    _leftChildIndex(parentIndex) {
        return 2 * parentIndex + 1
    }

    _rightChildIndex(parentIndex) {
        return 2 * parentIndex + 2
    }

    _parentIndex(childIndex) {
        return Math.floor((childIndex - 1) / 2)
    }

    insert(element) {
        this._elements.push(element)
        this._siftUp(this._elements.length - 1)
    }

    remove() {
        if (this._elements.length < 1) {
          return null
        }

        let temp = this._elements[0]
        this._elements[0] = this._elements[this._elements.length - 1]
        this._elements[this._elements.length - 1] = temp

        let element = this._elements.pop()
        this._siftDown(0)
        return element
    }

    size() {
        return this._elements.length
    }
    
    peek() {
        return this._elements[0]
    }
}
```

## 381. Insert Delete GetRandom O(1) - Duplicates allowed
```javascript
/**
 * Initialize your data structure here.
 */
var RandomizedCollection = function() {
    this.indexMap = {}
    this.array = []
};

/**
 * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. 
 * @param {number} val
 * @return {boolean}
 */
RandomizedCollection.prototype.insert = function(val) {
    if (this.indexMap[val] === undefined) {
        this.indexMap[val] = new Set()
    }
    
    this.indexMap[val].add(this.array.length)
    this.array.push(val)
    
    return this.indexMap[val].length === 1
};

/**
 * Removes a value from the collection. Returns true if the collection contained the specified element. 
 * @param {number} val
 * @return {boolean}
 */
RandomizedCollection.prototype.remove = function(val) {
    if (!this.hasVal(val)) return false
    
    const removeIndex = this.indexMap[val].keys().next().value
    this.indexMap[val].delete(removeIndex)
    
    const lastVal = this.array[this.array.length - 1]
    this.indexMap[lastVal].add(removeIndex)
    this.indexMap[lastVal].delete(this.array.length - 1)
    
    this.array[removeIndex] = lastVal
    this.array.pop()
    
    return true
};

/**
 * Get a random element from the collection.
 * @return {number}
 */
RandomizedCollection.prototype.getRandom = function() {
    const randomIndex = this.random(0, this.array.length - 1)
    return this.array[randomIndex]
};

RandomizedCollection.prototype.random = function(start, end) {
    return Math.floor(Math.random() * (end - start + 1)) + start
};

RandomizedCollection.prototype.hasVal = function(val) {
    return this.indexMap[val] !== undefined && this.indexMap[val].size
}

/** 
 * Your RandomizedCollection object will be instantiated and called as such:
 * var obj = new RandomizedCollection()
 * var param_1 = obj.insert(val)
 * var param_2 = obj.remove(val)
 * var param_3 = obj.getRandom()
 */
```

## 749. Contain Virus
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var containVirus = function(grid) {    
    let walls = 0
    while (true) {
        const components = getConnectedComponents(grid)
        if (components.length === 0)
            break
        
        // Get region with largest frontier
        let max = null
        for (const component of components) {
            if (max === null || component.frontier.size > max.frontier.size) {
                max = component
            }
        }
        
        walls += max.perimeter
        
        for (const component of components) {
            if (component.frontier.size === max.frontier.size) {
                // Disinfect Max Region
                colorGrid(grid, component.infectedCells, 2)
            } else {
                // Expand Infected Regions
                colorGrid(grid, component.frontier, 1)
            }
        }
    }
    
    return walls
};

const getConnectedComponents = grid => {
    const rowLen = grid.length
    const colLen = grid[0].length
    const visited = new Array(rowLen).fill().map(a => new Array(colLen))
    
    const components = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (grid[row][col] === 1 && !visited[row][col]) {
                components.push(getComponent(grid, row, col, visited))
            }
        }
    }
    
    return components
}

const getComponent = (grid, row, col, visited) => {
    const rowLen = grid.length
    const colLen = grid[0].length
    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    
    const component = { 'frontier': new Set(), 
                        'perimeter': 0, 
                        'infectedCells': new Set() }
    
    const queue = [[row, col]]
    visited[row][col] = true
    
    while (queue.length) {
        const [row, col] = queue.shift()
        component.infectedCells.add(row * colLen + col)
        
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = row + deltaRow
            const nextCol = col + deltaCol
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen ||
                grid[nextRow][nextCol] === 2) continue
            
            if (grid[nextRow][nextCol] === 0) {
                component.frontier.add(nextRow * colLen + nextCol)
                component.perimeter++
                continue
            }
            
            if (visited[nextRow][nextCol]) continue
            visited[nextRow][nextCol] = true
            queue.push([nextRow, nextCol])
        }
    }
    
    return component
}

const colorGrid = (grid, cells, color) => {
    const colLen = grid[0].length
    
    for (const cell of cells) {
        const row = Math.floor(cell / colLen)
        const col = cell % colLen
        
        grid[row][col] = color
    }
}
```

## 488. Zuma Game
```javascript
/**
 * @param {string} board
 * @param {string} hand
 * @return {number}
 */
var findMinStep = function(board, hand) {
    const _findMinStep = board => {
        if (board.length === 0) {
            return 0
        }
        
        if (memo[board] !== undefined) {
            return memo[board]
        }
        
        let maxCount = 6
        for (let i = 0; i < board.length; i++) {
            for (let k = 0; k < 26; k++) {
                if (handCount[k] > 0) {
                    handCount[k]--
                    
                    const ball = String.fromCharCode(k + 'A'.charCodeAt(0))
                    const insertedBoard = board.slice(0, i) + 
                                          String.fromCharCode(k + 'A'.charCodeAt(0)) + 
                                          board.slice(i)
                    
                    const collapsedBoard = collapseBoard(insertedBoard)
                    maxCount = Math.min(maxCount, 1 + _findMinStep(collapsedBoard))
                    
                    handCount[k]++
                }
            }
        }
        
        memo[board] = maxCount
        return memo[board]
    }
    
    const handCount = new Array(26).fill(0)
    for (const ball of hand) {
        const index = ball.charCodeAt(0) - 'A'.charCodeAt(0)
        handCount[index]++
    }
    
    const memo = {}
    const result = _findMinStep(board)
    return result === 6 ? -1 : result
};

const collapseBoard = board => {
    outer : while (true) {
        let start = 0
        for (let end = 1; end <= board.length; end++) {
            if (board[start] === board[end]) {
                continue
            }
            
            if (end - start >= 3) {
                board = board.slice(0, start) + board.slice(end)
                continue outer
            }
            
            start = end
        }
        
        break
    }
    
    return board
}
```

## 1235. Maximum Profit in Job Scheduling
```javascript
/**
 * @param {number[]} startTime
 * @param {number[]} endTime
 * @param {number[]} profit
 * @return {number}
 */
var jobScheduling = function(startTime, endTime, profit) {
    const n = startTime.length
    
    const jobs = []
    for (let i = 0; i < n; i++) {
        jobs.push([startTime[i], endTime[i], profit[i]])
    }
    jobs.sort((a, b) => a[1] - b[1] || a[0] - b[0])
    
    const dp = new Array(n).fill(0)
    dp[0] = jobs[0][2]
    
    for (let i = 1; i < profit.length; i++) {
        const [startTimeI, endTimeI, profitI] = jobs[i]
        dp[i] = dp[i - 1]

        const index = binarySearch(jobs, i, startTimeI)
        dp[i] = Math.max(dp[i], profitI + (dp[index] || 0))
    }
    
    return dp[n - 1]
};

const binarySearch = (arr, endIndex, target) => {
    let left = 0
    let right = endIndex - 1
    
    while (left <= right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (arr[mid][1] <= target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return left - 1
}
```

## 390. Elimination Game
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var lastRemaining = function(n) {
    let left = true
    let remaining = n
    let step = 1
    let head = 1
    
    while (remaining > 1) {
        if (left || remaining & 1) {
            head += step
        }
        
        remaining = Math.floor(remaining / 2)
        step *= 2
        left = !left
    }
    
    return head
};
```

## 8. String to Integer (atoi)
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    if (s.length === 0) {
        return 0
    }
    
    // Skip leading whitespace
    let i = 0
    while (i < s.length && s[i] === ' ') {
        i++
    }
    
    // Check Sign
    let sign = 1
    if (i < s.length && s[i] === '+' || s[i] === '-') {
        sign = s[i] === '+' ? 1 : -1
        i++
    }
    
    // Read in next digit chars
    const MAX_INT = 2 ** 31 - 1
    const MIN_INT = -(2 ** 31)
    const upperBound = Math.trunc(MAX_INT / 10)
    let num = 0
    while (i < s.length && isDigit(s[i])) {
        // Check for overflow
        if (num > upperBound || num === upperBound && +s[i] > 7) {
            return sign === -1 ? MIN_INT : MAX_INT
        }
        
        num *= 10
        num += +s[i]
        i++
    }

    return num * sign
};

const isDigit = char => '0' <= char && char <= '9'
```

## 311. Sparse Matrix Multiplication
```javascript
/**
 * @param {number[][]} mat1
 * @param {number[][]} mat2
 * @return {number[][]}
 */
var multiply = function(mat1, mat2) {
    const sparseMatrixA = new SparseMatrix(mat1, mat1.length, mat1[0].length)
    const sparseMatrixB = new SparseMatrix(mat2, mat2.length, mat2[0].length)
    const sparseMatrixC = sparseMatrixA.multiplyBy(sparseMatrixB)
    return sparseMatrixC.toDense()
};

class SparseMatrix {
    constructor(matrix, rowLen, colLen) {
        this.rowLen = rowLen
        this.colLen = colLen
        
        this.map = {}
        
        if (!matrix.length || !matrix[0].length) return
        
        for (let row = 0; row < this.rowLen; row++) {
            for (let col = 0; col < this.colLen; col++) {
                if (matrix[row][col] === 0) continue
                this.map[`${row}-${col}`] = matrix[row][col]
            }
        }
    }
    
    multiplyBy(matrix) {
        const sparseMatrix = new SparseMatrix([], this.rowLen, matrix.colLen)
        
        for (const [aKey, aVal] of Object.entries(this.map)) {
            const [aRow, aCol] = aKey.split('-')
            
            for (let bCol = 0; bCol < matrix.colLen; bCol++) {
                const bKey = `${aCol}-${bCol}`
                if (matrix.map[bKey] === undefined) continue
                
                const sKey = `${aRow}-${bCol}`
                if (sparseMatrix.map[sKey] === undefined) {
                    sparseMatrix.map[sKey] = 0
                }
                
                sparseMatrix.map[sKey] += aVal * matrix.map[bKey]
            }
        }
        
        return sparseMatrix
    }
    
    toDense() {
        const matrix = new Array(this.rowLen).fill()
                            .map(a => new Array(this.colLen).fill(0))
        
        for (const [key, val] of Object.entries(this.map)) {
            const [row, col] = key.split('-')
            matrix[row][col] = val
        }
        
        return matrix
    }
}
```

## 460. LFU Cache
```javascript
/**
 * @param {number} capacity
 */
var LFUCache = function(capacity) {
    this.capacity = capacity
    this.size = 0
    
    this.minFrequency = 0
    
    this.keyToNodeMap = {}
    this.frequencyToListMap = {}
};

/** 
 * @param {number} key
 * @return {number}
 */
LFUCache.prototype.get = function(key) {
    const node = this.keyToNodeMap[key]
    if (this.capacity === 0 || node === undefined) {
        return -1
    }
    
    const oldFrequency = node.frequency
    const newFrequency = node.frequency + 1
    node.frequency++
    
    // Remove node from old list
    const oldList = this.frequencyToListMap[oldFrequency]
    oldList.remove(node)
    
    // If old list now empty, remove from map
    if (oldList.size === 0) {
        // Update minFrequency if needed
        if (this.minFrequency === oldFrequency) {
            this.minFrequency = newFrequency
        }
        
        delete this.frequencyToListMap[oldFrequency]
    }
    
    // Add node to new list, if list doesn't exist in map add list first
    if (this.frequencyToListMap[newFrequency] === undefined) {
        this.frequencyToListMap[newFrequency] = new DoublyLinkedList()
    }
    
    const newList = this.frequencyToListMap[newFrequency]
    newList.insertAtHead(node)
    
    return node.value
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LFUCache.prototype.put = function(key, value) {
    if (this.capacity === 0) return
    
    if (this.keyToNodeMap[key] !== undefined) {
        const node = this.keyToNodeMap[key]
        node.value = value
        this.get(key)
        return
    }
    
    // if at capacity must delete least recently used from list of min frequecy
    if (this.size === this.capacity) {
        const minList = this.frequencyToListMap[this.minFrequency]
        const lruNode = minList.removeFromTail()
        this.size--
        
        delete this.keyToNodeMap[lruNode.key]
        
        // If min list now empty, remove from map
        if (minList.size === 0) {
            delete this.frequencyToListMap[this.minFrequency]
        }
    }
    
    this.minFrequency = 1
    if (this.frequencyToListMap[this.minFrequency] === undefined) {
        this.frequencyToListMap[this.minFrequency] = new DoublyLinkedList()
    }
    
    const node = new Node(key, value, 1)
    this.keyToNodeMap[key] = node
    
    const minList = this.frequencyToListMap[this.minFrequency]
    minList.insertAtHead(node)
    
    this.size++
};

/** 
 * Your LFUCache object will be instantiated and called as such:
 * var obj = new LFUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */

class DoublyLinkedList {
    constructor() {
        this.head = new Node()
        this.tail = new Node()
        
        this.head.next = this.tail
        this.tail.prev = this.head
        
        this.size = 0
    }
    
    insertAtHead(node) {
        if (!node) return
        
        const head = this.head
        const next = head.next
        
        head.next = node
        
        node.prev = head
        node.next = next
        
        next.prev = node
        
        this.size++
    }
    
    remove(node) {
        if (!node) return
        
        const prev = node.prev
        const next = node.next
        
        prev.next = next
        next.prev = prev
        
        node.next = null
        node.prev = null
        
        this.size--
    }
    
    removeFromTail() {
        if (this.size === 0) return
        const lastNode = this.tail.prev
        this.remove(lastNode)
        return lastNode
    }
}

class Node {
    constructor(key, value, frequency) {
        this.key = key
        this.value = value
        this.frequency = frequency
    }
}
```

## 1740. Find Distance in a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} p
 * @param {number} q
 * @return {number}
 */
var findDistance = function(root, p, q) {
    const dfs = (node, parent) => {
        if (!node) return
        
        node.parent = parent
        
        if (node.val === p) {
            pNode = node
        }
        
        dfs(node.left, node)
        dfs(node.right, node)
    }
    
    let pNode = null
    dfs(root)
    return bfs(pNode, q)
};

const bfs = (startNode, endVal) => {
    const queue = [startNode]
    const visited = new Set()
    let level = 0
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (visited.has(node.val)) {
                continue
            }
            visited.add(node.val)
            
            if (node.val === endVal) {
                return level
            }
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
            if (node.parent) queue.push(node.parent)
        }
        
        level++
    }
    
    return level
}
```

## 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
```javascript
/**
 * @param {number} h
 * @param {number} w
 * @param {number[]} horizontalCuts
 * @param {number[]} verticalCuts
 * @return {number}
 */
var maxArea = function(h, w, horizontalCuts, verticalCuts) {
    const MOD = 10 ** 9 + 7
    const verticalGap = getGap(horizontalCuts, h)
    const horizontalGap = getGap(verticalCuts, w)
    return verticalGap * horizontalGap % MOD
};

const getGap = (arr, size) => {
    arr.sort((a, b) => a - b)
    
    let maxGap = 0
    let prev = 0
    for (let i = 0; i <= arr.length; i++) {
        const gap = (arr[i] || size) - prev
        maxGap = Math.max(maxGap, gap)
        prev = arr[i]
    }
    
    return maxGap
}
```

## 65. Valid Number
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function(s) {
    const processInteger = () => {
        // Check the sign
        if (s[i] === '+' || s[i] === '-') {
            i++
        }
        
        // Process left side of decimal or e
        let digitCount = 0
        while (i < s.length) {
            const char = s[i]
            
            if (isDigit(char)) {
                i++
                digitCount++
                continue
            }
            
            if (char === '.') {
                i++
                return processRightOfDecimal(digitCount)
            }
            
            if (char === 'e' || char === 'E') {
                if (digitCount === 0) {
                    return false
                }

                i++
                return processRightOfScientific()
            }
            
            return false
        }
        
        // Is integer
        return true
    }

    const processRightOfDecimal = (leftOfDecimalDigitCount) => {
        let rightOfDecimalDigitCount = 0
        while (i < s.length) {
            const char = s[i]
            
            if (isDigit(char)) {
                i++
                rightOfDecimalDigitCount++
                continue
            }
            
            if (char === '.') {
                return false
            }

            if (char === 'e' || char === 'E') {
                if (leftOfDecimalDigitCount === 0 && rightOfDecimalDigitCount === 0) {
                    return false
                }
                
                i++
                return processRightOfScientific()
            }
            
            return false
        }
        
        return leftOfDecimalDigitCount || rightOfDecimalDigitCount
    }

    const processRightOfScientific = () => {
        // Check the sign
        if (s[i] === '+' || s[i] === '-') {
            i++
        }
        
        // Process right side of e
        let digitCount = 0
        while (i < s.length) {
            const char = s[i]

            if (isDigit(char)) {
                i++
                digitCount++
                continue
            }
            
            return false
        }
        
        return digitCount > 0
    }
    
    let i = 0
    return processInteger()
};

const isDigit = char => '0123456789'.includes(char)
```

## 166. Fraction to Recurring Decimal
```javascript
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
    if (numerator === 0) return '0'
    
    let sign = ''
    if (numerator < 0 && denominator > 0 || 
        numerator > 0 && denominator < 0) sign = '-'
    
    const result = [sign]
    
    let dividend = Math.abs(numerator)
    let divisor = Math.abs(denominator)
    
    const quotient = Math.trunc(dividend / divisor)
    result.push(quotient)
    
    let remainder = dividend % divisor
    if (remainder === 0) {
        return result.join('')
    }
    
    result.push('.')
    
    const map = {}
    while (remainder !== 0) {
        if (map[remainder] !== undefined) {
            result.splice(map[remainder], 0, '(')
            result.push(')')
            break
        }
        
        map[remainder] = result.length
        remainder *= 10
        
        const quotient = Math.trunc(remainder / divisor)
        result.push(quotient)
        
        remainder %= divisor
    }
    
    return result.join('')
};
```

## 722. Remove Comments
```javascript
/**
 * @param {string[]} source
 * @return {string[]}
 */
var removeComments = function(source) {
    const result = []
    
    let inBlock = false
    let newLine = []
    for (const line of source) {
        let i = 0
        while (i < line.length) {
            if (inBlock) {
                // Mark end of block comment
                if (line[i] === '*' && line[i + 1] === '/') {
                    inBlock = false
                    i += 2
                    continue
                }
                
                // Ignore all chars inside block
                i++
                continue
            }
            
            // If start of line comment then ignore rest of line
            if (line[i] === '/' && line[i + 1] === '/') {
                break
            }
            
            // Mark start of block comment
            if (line[i] === '/' && line[i + 1] === '*') {
                inBlock = true
                i += 2
                continue
            }
            
            // Not in a comment so include char
            newLine.push(line[i])
            i++
        }
        
        /*
            If still in a block comment at the end of the line, we 
            don't want to start a newline because the newline char 
            '\n' is ignored inside a block comment
        */
        if (!inBlock) {
            if (newLine.length) {
                result.push(newLine.join(''))
            }
            
            newLine = []
        }
    }
    
    return result
};
```

## 1732. Find the Highest Altitude
```javascript
/**
 * @param {number[]} gain
 * @return {number}
 */
var largestAltitude = function(gain) {
    let max = 0
    let altitude = 0
    for (const g of gain) {
        altitude += g
        max = Math.max(max, altitude)
    }
    
    return max
};
```

## 1736. Latest Time by Replacing Hidden Digits
```javascript
/**
 * @param {string} time
 * @return {string}
 */
var maximumTime = function(time) {
    time = time.split('')
    
    // Hour
    if (time[0] === '?') {
        time[0] = '0123'.includes(time[1]) || time[1] === '?' ? 2 : 1
    }
    
    if (time[1] === '?') {
        time[1] = time[0] == 2 ? 3 : 9
    }
    
    // Min
    if (time[3] === '?') {
        time[3] = 5
    }
    
    if (time[4] === '?') {
        time[4] = 9
    }
    
    return time.join('')
};
```

## 1741. Find Total Time Spent by Each Employee
```sql
# Write your MySQL query statement below
SELECT event_day AS day, 
       emp_id, 
       SUM(out_time - in_time) AS total_time
FROM Employees
GROUP BY emp_id, event_day
```

## 471. Encode String with Shortest Length
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var encode = function(s) {
    const dp = new Array(s.length).fill().map(a => new Array(s.length).fill(0))
    for (let i = 0; i < s.length; i++) {
        dp[i][i] = s[i]
    }
    
    for (let len = 2; len <= s.length; len++) {
        for (let startIndex = 0; startIndex < s.length - len + 1; startIndex++) {
            const endIndex = startIndex + len - 1
            
            const currS = s.slice(startIndex, endIndex + 1)
            dp[startIndex][endIndex] = currS
            
            if (len <= 4) continue
            
            const prefix = []
            for (let k = startIndex; k < endIndex; k++) {
                // see if we can get a shorter string by cutting and combining left and right
                const combine = dp[startIndex][k] + dp[k + 1][endIndex]
                if (combine.length < dp[startIndex][endIndex].length) {
                    dp[startIndex][endIndex] = combine
                }
                
                // see if we can compress the subtring s[startIndex, endIndex]
                prefix.push(s[k])
                const divides = currS.length / prefix.length
                if (currS.length % prefix.length !== 0) continue
                
                const candidate = prefix.join('').repeat(divides)
                if (candidate === currS) {
                    const res = `${divides}[${dp[startIndex][k]}]`
                    if (res.length < dp[startIndex][endIndex].length) {
                        dp[startIndex][endIndex] = res
                    }
                }
            }
        }
    }
    
    return dp[0][s.length - 1]
};

const isCompressed = str => str[str.length - 1] === ']'

const extract = str => {
    const leftBracket = str.indexOf('[')
    const count = +str.slice(0, leftBracket)
    const contents = str.slice(leftBracket + 1, str.length - 1)
    return [count, contents]
}
```

## 1742. Maximum Number of Balls in a Box
```javascript
/**
 * @param {number} lowLimit
 * @param {number} highLimit
 * @return {number}
 */
var countBalls = function(lowLimit, highLimit) {
    const map = {}
    let max = 0
    for (let num = lowLimit; num <= highLimit; num++) {
        const digitSum = getDigitSum(num)
        map[digitSum] = 1 + (map[digitSum] || 0)
        max = Math.max(max, map[digitSum])
    }
    
    return max
};

const getDigitSum = num => {
    let sum = 0
    
    while (num) {
        const digit = num % 10
        sum += digit
        num = Math.floor(num / 10)
    }
    
    return sum
}
```

## 1743. Restore the Array From Adjacent Pairs
```javascript
/**
 * @param {number[][]} adjacentPairs
 * @return {number[]}
 */
var restoreArray = function(adjacentPairs) {
    const graph = buildGraph(adjacentPairs)
    const leaf = getLeaf(graph)
    return getPath(leaf, graph)
};

const getPath = (leaf, graph) => {
    const _getPath = (node, parent) => {
        path.push(node)
        
        for (const neighbor of graph[node]) {
            if (neighbor === parent) continue
            _getPath(neighbor, node)
        }
    }
    
    const path = []
    _getPath(leaf, null)
    return path
}

const getLeaf = graph => {
    for (const [node, neighbors] of Object.entries(graph)) {
        if (neighbors.length === 1) {
            return +node
        }
    }
}

const buildGraph = edges => {
    const graph = {}
    for (const [u, v] of edges) {
        if (graph[u] === undefined) {
            graph[u] = []
        }

        if (graph[v] === undefined) {
            graph[v] = []
        }

        graph[u].push(v)
        graph[v].push(u)
    }
    return graph
}
```

## 1744. Can You Eat Your Favorite Candy on Your Favorite Day?
```javascript
/**
 * @param {number[]} candiesCount
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var canEat = function(candiesCount, queries) {
    const prefixSums = [0]
    for (const count of candiesCount) {
        prefixSums.push(prefixSums[prefixSums.length - 1] + count)
    }
    
    const result = []
    for (const [type, day, cap] of queries) {
        const maxDay = prefixSums[type + 1] - 1
        const minDay = Math.trunc(prefixSums[type] / cap)
        result.push(minDay <= day && day <= maxDay)
    }
    
    return result
};
```

## 354. Russian Doll Envelopes
```javascript
// O(n^2) Longest Increasing Subsequence
/**
 * @param {number[][]} envelopes
 * @return {number}
 */
var maxEnvelopes = function(envelopes) {
    if (!envelopes.length) return 0
    
    envelopes.sort((a, b) => a[0] - b[0] || a[1] - b[1])
    
    const dp = new Array(envelopes.length + 1).fill(1)
    let max = 1
    for (let i = 1; i < envelopes.length; i++) {
        for (let j = 0; j < i; j++) {
            const [endWidth, endHeight] = envelopes[j]
            const [nextWidth, nextHeight] = envelopes[i]
            
            if (endWidth < nextWidth && endHeight < nextHeight) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
        max = Math.max(max, dp[i])
    }
    return max
};
```

## 1745. Palindrome Partitioning IV
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var checkPartitioning = function(s) {
    const _palindromePartition = (i, k) => {
        if (i >= s.length) return k === 0 ? true : false
        if (k <= 0) return false
        
        if (memo[i][k] !== undefined) {
            return memo[i][k]
        }
        
        let result = false
        for (let j = i; j < s.length; j++) {
            const canPartition = isPalindrome[i][j] && _palindromePartition(j + 1, k - 1)
            if (canPartition) {
                result = true
                break
            }
        }
        
        memo[i][k] = result
        return result
    }
    
    const n = s.length
    const isPalindrome = new Array(n).fill().map(a => new Array(n).fill(false))
    for (let len = 1; len <= n; len++) {
        for (let start = 0; start < n - len + 1; start++) {
            const end = start + len - 1
            if (start === end) {
                isPalindrome[start][end] = true
            } else if (start === end - 1 && s[start] === s[end]) {
                isPalindrome[start][end] = true
            } else if (s[start] === s[end] && isPalindrome[start + 1][end - 1]) {
                isPalindrome[start][end] = true
            }
        }
    }
    
    const memo = new Array(n).fill().map(a => new Array(4))
    return _palindromePartition(0, 3)
};
```

## 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum
```javascript
/**
 * @param {number[]} arr
 * @param {number} target
 * @return {number}
 */
var minSumOfLengths = function(arr, target) {
    const dp = new Array(arr.length)
    let result = Infinity
    
    let currSum = 0
    let minLen = Infinity
    
    let left = 0
    for (let right = 0; right < arr.length; right++) {
        currSum += arr[right]
        
        while (left < right && currSum > target) {
            currSum -= arr[left]
            left++
        }
        
        if (currSum === target) {
            const currLen = right - left + 1
            result = Math.min(result, currLen + (dp[left - 1] || Infinity))
            minLen = Math.min(minLen, currLen)
        }
        
        dp[right] = minLen
    }
    
    return result === Infinity ? -1 : result
};
```

## 833. Find And Replace in String
```javascript
/**
 * @param {string} S
 * @param {number[]} indexes
 * @param {string[]} sources
 * @param {string[]} targets
 * @return {string}
 */
var findReplaceString = function(S, indexes, sources, targets) {
    let groups = []
    for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i]
        const source = sources[i]
        const target = targets[i]
        groups.push([index, source, target])
    }
    
    groups = countingSort(groups, S.length)
    
    let i = 0
    const result = []
    for (const [index, source, target] of groups) {
        while (i < index) {
            result.push(S[i])
            i++
        }
        
        const substr = S.slice(index, index + source.length)
        if (substr === source) {
            result.push(target)
            i += source.length
        }
    }
    
    while (i < S.length) {
        result.push(S[i])
        i++
    }
    
    return result.join('')
};

const countingSort = (arr, n) => {
    const buckets = new Array(n)
    for (const group of arr) {
        const index = group[0]
        if (buckets[index] === undefined) {
            buckets[index] = []
        }
        buckets[index].push(group)
    }
    
    const result = []
    for (let i = 0; i < n; i++) {
        for (let j = 0; buckets[i] && j < buckets[i].length; j++) {
            result.push(buckets[i][j])
        }
    }
    
    return result
}
```

## 1031. Maximum Sum of Two Non-Overlapping Subarrays
```javascript
/**
 * @param {number[]} A
 * @param {number} L
 * @param {number} M
 * @return {number}
 */
var maxSumTwoNoOverlap = function(A, L, M) {
    const maxSumLeft = getMaxSumLeft(A, M)
    const maxSumRight = getMaxSumRight(A, M)
    
    let currSum = 0
    let maxSum = 0
    for (let rightIndex = 0; rightIndex < A.length; rightIndex++) {
        if (rightIndex < L) {
            currSum += A[rightIndex]
            maxSum = currSum + (maxSumRight[rightIndex + 1] || 0)
            continue
        }
        
        const leftIndex = rightIndex - L + 1
        currSum -= A[leftIndex - 1]
        currSum += A[rightIndex]
        
        maxSum = Math.max(maxSum, 
                          currSum + (maxSumLeft[leftIndex - 1] || 0), 
                          currSum + (maxSumRight[rightIndex + 1] || 0))
    }
    
    return maxSum
};

const getMaxSumLeft = (arr, size) => {
    const maxSumLeft = new Array(arr.length).fill(0)
    
    let currSum = 0
    let maxSum = 0
    for (let rightIndex = 0; rightIndex < arr.length; rightIndex++) {
        if (rightIndex < size) {
            currSum += arr[rightIndex]
            
            maxSum = currSum
            maxSumLeft[rightIndex] = maxSum
            continue
        }
        
        const leftIndex = rightIndex - size + 1
        currSum -= arr[leftIndex - 1]
        currSum += arr[rightIndex]
        
        maxSum = Math.max(maxSum, currSum)
        maxSumLeft[rightIndex] = maxSum
    }
    
    return maxSumLeft
}

const getMaxSumRight = (arr, size) => {
    const maxSumRight = new Array(arr.length).fill(0)
    
    let currSum = 0
    let maxSum = 0
    for (let leftIndex = arr.length - 1; leftIndex >= 0; leftIndex--) {
        if (leftIndex > arr.length - size - 1) {
            currSum += arr[leftIndex]
            
            maxSum = currSum
            maxSumRight[leftIndex] = maxSum
            continue
        }
        
        const rightIndex = leftIndex + size - 1
        currSum -= arr[rightIndex + 1]
        currSum += arr[leftIndex]
        
        maxSum = Math.max(maxSum, currSum)
        maxSumRight[leftIndex] = maxSum
    }
    
    return maxSumRight
}
```

## 962. Maximum Width Ramp
```javascript
// Sort
/**
 * @param {number[]} A
 * @return {number}
 */
var maxWidthRamp = function(A) {
    const indices = []
    for (let i = 0; i < A.length; i++) {
        indices.push(i)
    }
    
    indices.sort((a, b) => A[a] - A[b])
    
    let result = 0
    let min = A.length
    for (const index of indices) {
        result = Math.max(result, index - min)
        min = Math.min(min, index)
    }
    
    return result
};

// Binary Search
/**
 * @param {number[]} A
 * @return {number}
 */
var maxWidthRamp = function(A) {
    const stack = []
    let result = 0
    
    for (let i = 0; i < A.length; i++) {
        if (!stack.length || A[i] < A[stack[stack.length - 1]]) {
            stack.push(i)
        } else {
            let left = 0
            let right = stack.length - 1
            
            while (left < right) {
                const mid = Math.floor((right - left) / 2) + left
                if (A[stack[mid]] > A[i]) {
                    left = mid + 1
                } else {
                    right = mid
                }
            }
            
            result = Math.max(result, i - stack[left])
        }
    }
    
    return result
};

// Stack
/**
 * @param {number[]} A
 * @return {number}
 */
var maxWidthRamp = function(A) {
    const stack = []
    let result = 0
    
    for (let i = 0; i < A.length; i++) {
        if (!stack.length || A[stack[stack.length - 1]] > A[i]) {
            stack.push(i)
        }
    }
    
    for (let i = A.length - 1; i >= result; i--) {
        while (stack.length && A[stack[stack.length - 1]] <= A[i]) {
            result = Math.max(result, i - stack.pop())
        }
    }
    
    return result
};
```

## 593. Valid Square
```javascript
/**
 * @param {number[]} p1
 * @param {number[]} p2
 * @param {number[]} p3
 * @param {number[]} p4
 * @return {boolean}
 */
var validSquare = function(p1, p2, p3, p4) {
    const p = [p1, p2, p3, p4]
    const set = new Set()
    for (let i = 0; i < p.length; i++) {
        for (let j = i + 1; j < p.length; j++) {
            set.add(dist(p[i], p[j]))
        }
    }
    
    return !set.has(0) && set.size === 2
};

const dist = (p1, p2) => {
    return (p2[1] - p1[1]) ** 2 + (p2[0] - p1[0]) ** 2
}
```

## 548. Split Array with Equal Sum
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var splitArray = function(nums) {
    const prefixSum = (i, j) => prefixSums[j + 1] - prefixSums[i]
    const prefixSums = [0]
    for (const num of nums) {
        prefixSums.push(prefixSums[prefixSums.length - 1] + num)
    }
    
    for (let middle = 3; middle < nums.length - 3; middle++) {
        const targets = new Set()
        for (let left = 1; left < middle - 1; left++) {
            const p1 = prefixSum(0, left - 1)
            const p2 = prefixSum(left + 1, middle - 1)
            if (p1 === p2) targets.add(p1)
        }
        
        for (let right = middle + 2; right < nums.length - 1; right++) {
            const p1 = prefixSum(middle + 1, right - 1)
            const p2 = prefixSum(right + 1, nums.length - 1)
            if (p1 === p2 && targets.has(p1)) return true
        }
    }
    
    return false
};
```

## 919. Complete Binary Tree Inserter
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 */
var CBTInserter = function(root) {
    this.root = root
    this.treeQueue = []
    
    const queue = [root]
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const node = queue.shift()
            
            if (!node.left || !node.right) {
                this.treeQueue.push(node)
            }
            
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
    }
};

/** 
 * @param {number} v
 * @return {number}
 */
CBTInserter.prototype.insert = function(v) {
    const node = this.treeQueue[0]
    
    if (!node.left) {
        node.left = new TreeNode(v)
        this.treeQueue.push(node.left)
    } else {
        node.right = new TreeNode(v)
        this.treeQueue.push(node.right)
        this.treeQueue.shift()
    }
    
    return node.val
};

/**
 * @return {TreeNode}
 */
CBTInserter.prototype.get_root = function() {
    return this.root
};

/** 
 * Your CBTInserter object will be instantiated and called as such:
 * var obj = new CBTInserter(root)
 * var param_1 = obj.insert(v)
 * var param_2 = obj.get_root()
 */
```

## 678. Valid Parenthesis String
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var checkValidString = function(s) {
    let left = 0
    let leftOrWild = 0
    for (const char of s) {
        if (char === '(') {
            left++
            leftOrWild++
        } else if (char === ')') {
            if (leftOrWild === 0) return false
            leftOrWild--
            left--
        } else {
            leftOrWild++
            left--
        }
        
        left = Math.max(left, 0)
    }
    
    return left === 0
};
```

## 400. Nth Digit
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var findNthDigit = function(n) {
    let digits = 1
    let count = 9
    let start = 1
    
    while (n > digits * count) {
        n -= digits * count
        digits++
        count *= 10
        start *= 10
    }
    
    start += (n - 1) / digits
    return `${start}`[(n - 1) % digits]
};
```

## 275. H-Index II
```javascript
/**
 * @param {number[]} citations
 * @return {number}
 */
var hIndex = function(citations) {
    if (!citations.length || citations[citations.length - 1] === 0) {
        return 0
    }
    
    let left = 0
    let right = citations.length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (citations.length - mid > citations[mid]) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return citations.length - left
};
```

## 992. Subarrays with K Different Integers
```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var subarraysWithKDistinct = function(A, K) {
    return getKMostCount(A, K) - getKMostCount(A, K - 1)
};

var getKMostCount = function(s, k) {
    const map = new Map()
    let result = 0
    let start = 0
    
    for (let i = 0; i < s.length; i++) {
        map.set(s[i], (map.get(s[i]) || 0) + 1)
        
        while (map.size > k) {
            map.set(s[start], map.get(s[start]) - 1)
            if (map.get(s[start]) <= 0) {
                map.delete(s[start])
            }
            start++
        }
        
        result += i - start + 1
    }
    return result
};
```

## 1036. Escape a Large Maze
```javascript
/**
 * @param {number[][]} blocked
 * @param {number[]} source
 * @param {number[]} target
 * @return {boolean}
 */
var isEscapePossible = function(blocked, source, target) {
    if (!blocked.length) return true
    
    const set = new Set(blocked.map(e => e.toString()))
    return bfs(set, source, target) && bfs(set, target, source)
};

const bfs = (blockedSet, source, target) => {
    const b = 10 ** 6
    
    const maxArea = blockedSet.size * (blockedSet.size + 1) / 2
    let area = 0
    
    const visited = new Set()
    visited.add(source.toString())
    
    const queue = [source]
    while (queue.length) {
        const [row, col] = queue.shift()

        if (row === target[0] && col === target[1])
            return true

        if (area > maxArea) return true

        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const nr = row + dx
            const nc = col + dy
            const coor = [nr, nc]

            if (nr < 0 || nc < 0 || nr >= b || nc >= b) continue

            if (visited.has(coor.toString()) || 
                blockedSet.has(coor.toString())) continue
            visited.add(coor.toString())
            
            area++
            queue.push(coor)
        }
    }

    return false
}
```

## 920. Number of Music Playlists
```javascript
// Top Down
/**
 * @param {number} N
 * @param {number} L
 * @param {number} K
 * @return {number}
 */
var numMusicPlaylists = function(N, L, K) {
    const _numMusicPlaylists = (length, distinctNumsCount) => {
        if (length === L) {
            return distinctNumsCount === N
        }
        
        if (memo[length][distinctNumsCount] !== undefined) {
            return memo[length][distinctNumsCount]
        }
        
        // Choose New Song
        const waysToChooseNewSong = _numMusicPlaylists(length + 1, distinctNumsCount + 1) * 
                                    (N - distinctNumsCount) % MOD
        
        // Choose Repeat Song
        const waysToChooseRepeatSong = _numMusicPlaylists(length + 1, distinctNumsCount) * 
                                       Math.max(0, distinctNumsCount - K) % MOD
        
        const count = waysToChooseNewSong + waysToChooseRepeatSong
        memo[length][distinctNumsCount] = count
        return count
    }
    
    const MOD = 10 ** 9 + 7
    const memo = new Array(L + 1).fill().map(a => new Array(N + 1))
    return _numMusicPlaylists(0, 0)
};
```

## 1411. Number of Ways to Paint N  3 Grid
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numOfWays = function(n) {
    const MOD = 10 ** 9 + 7
    let colors2 = 6
    let colors3 = 6
    
    for (let i = 1; i < n; i++) {
        const temp = colors2
        colors2 = (3 * colors2 + 2 * colors3) % MOD
        colors3 = (2 * temp + 2 * colors3) % MOD
    }
    
    return (colors2 + colors3) % MOD
};
```

## 936. Stamping The Sequence
```javascript
/**
 * @param {string} stamp
 * @param {string} target
 * @return {number[]}
 */
var movesToStamp = function(stamp, target) {
    const canReplace = tIndex => {
        for (let i = 0; i < S.length; i++) {
            if (T[tIndex] !== '*' && T[tIndex] !== S[i]) {
                return false
            }
            tIndex++
        }
        return true
    }

    const doReplace = tIndex => {
        let stars = 0
        for (let i = 0; i < S.length; i++) {
            if (T[tIndex] !== '*') {
                T[tIndex] = '*'
                stars++
            }
            tIndex++
        }
        return stars
    }
    
    const S = stamp.split('')
    const T = target.split('')
    const result = []
    const visited = Array(T.length).fill(false)
    let stars = 0
    
    // Go until all chars have been replaced by stars '*'
    while (stars < T.length) {
        let doneReplace = false
        for (let i = 0; i <= T.length - S.length; i++) {
            /*
            Search in reverse order. Instead of adding stamps, remove stamps
            A stamp that is stamped later will cover the earlier ones, so there 
            is a unique Z order for all the stamps, just like elements on a web page.
            
            Visited is used to note the start index of a stamp we already removed.
            */
            if (!visited[i] && canReplace(i)) {
                stars += doReplace(i)
                doneReplace = true
                visited[i] = true
                result.push(i)
            }
            
            // No more stamps to make
            if (stars === T.length) break
        }
        
        // No stamps were made
        if (!doneReplace) return []
    }
    
    return result.reverse()
};
```

## 1040. Moving Stones Until Consecutive II
```javascript
/**
 * @param {number[]} stones
 * @return {number[]}
 */
var numMovesStonesII = function(stones) {
    stones.sort((a, b) => a - b)
    const n = stones.length
    
    const leftMax = stones[n - 2] - stones[0] - 1 - (n - 3)
    const rightMax = stones[n - 1] - stones[1] - 1 - (n - 3)
    const max = Math.max(leftMax, rightMax)
    
    let min = Infinity
    let i = 0
    let j = 0
    let windowSize = Infinity
    let stoneCount = Infinity
    while (j < n) {
        windowSize = stones[j] - stones[i] + 1
        stoneCount = j - i + 1
        
        if (windowSize > n) {
            i++
            continue
        }
        
        /*
        Edges Case:
        [1, 2, 3, 4, 10], the interval [1, 2, 3, 4] is consecutive, 
        but there is only one external stone, you need to put 1 to the position 6, 
        then put 10 to position 5.
        */
        if (windowSize == n - 1 && stoneCount == n - 1) {
            min = Math.min(min, 2)
        } else {
            min = Math.min(min, n - stoneCount)
        }
        
        j++
    }
    
    return [min, max]
};
```

## 1586. Binary Search Tree Iterator II
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 */
var BSTIterator = function(root) {
    this.last = root
    this.stack = []
    this.arr = []
    this.pointer = -1
};

/**
 * @return {boolean}
 */
BSTIterator.prototype.hasNext = function() {
    return this.stack.length || 
           this.last !== null || 
           this.pointer < this.arr.length - 1
};

/**
 * @return {number}
 */
BSTIterator.prototype.next = function() {
    this.pointer++
    
    if (this.pointer === this.arr.length) {        
        while (this.last !== null) {
            this.stack.push(this.last)
            this.last = this.last.left
        }
        
        const curr = this.stack.pop()
        this.last = curr.right
        this.arr.push(curr.val)
    }
    
    return this.arr[this.pointer]
};

/**
 * @return {boolean}
 */
BSTIterator.prototype.hasPrev = function() {
    return this.pointer > 0
};

/**
 * @return {number}
 */
BSTIterator.prototype.prev = function() {
    this.pointer--
    return this.arr[this.pointer]
};

/** 
 * Your BSTIterator object will be instantiated and called as such:
 * var obj = new BSTIterator(root)
 * var param_1 = obj.hasNext()
 * var param_2 = obj.next()
 * var param_3 = obj.hasPrev()
 * var param_4 = obj.prev()
 */
```

## 666. Path Sum IV
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var pathSum = function(nums) {
    const _pathSum = (root, preSum) => {
        const level = Math.floor(root / 10)
        const pos = root % 10
        const left = (level + 1) * 10 + pos * 2 - 1
        const right = (level + 1) * 10 + pos * 2
        
        const currSum = preSum + treeMap[root]
        if (treeMap[left] === undefined && treeMap[right] === undefined) {
            sum += currSum
            return
        }
        
        if (treeMap[left] !== undefined) _pathSum(left, currSum)
        if (treeMap[right] !== undefined) _pathSum(right, currSum)
    }
    
    const treeMap = {}
    for (const num of nums) {
        const key = Math.trunc(num / 10)
        const val = num % 10
        treeMap[key] = val
    }
    
    let sum = 0
    _pathSum(Math.trunc(nums[0] / 10), 0)
    return sum
};
```

## 870. Advantage Shuffle
```javascript
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number[]}
 */
var advantageCount = function(A, B) {
    const sortedA = A.slice().sort((a, b) => a - b)
    const sortedB = B.slice().sort((a, b) => a - b)
    
    const take = {}
    for (let i = sortedB.length - 1; i >= 0; i--) {
        if (sortedB[i] < sortedA[sortedA.length - 1]) {
            if (take[sortedB[i]] === undefined) {
                take[sortedB[i]] = []
            }
            take[sortedB[i]].push(sortedA.pop())
        }
    }

    const result = []
    for (let i = 0; i < B.length; i++) {
        if (take[B[i]] && take[B[i]].length) {
            result.push(take[B[i]].pop())
        } else {
            result.push(sortedA.pop())
        }
    }
    return result
};

/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number[]}
 */
var advantageCount = function(A, B) {
    const result = new Array(A.length)
    const notPlaced = []
    
    const bIndex = B.map((element, index) => [element, index])
    
    A.sort((a, b) => b - a)
    bIndex.sort((a, b) => b[0] - a[0])
    
    let i = 0
    let j = 0
    
    while (i < A.length && j < bIndex.length) {
        if (A[i] > bIndex[j][0]) {
            result[bIndex[j][1]] = A[i]
            i++
            j++
        } else {
            notPlaced.push(bIndex[j])
            j++
        }
    }
    
    for (const [val, index] of notPlaced) {
        result[index] = A[i++]
    }
    
    return result
};
```

## 963. Minimum Area Rectangle II
```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var minAreaFreeRect = function(points) {
    /*
    Four points form a rectangle iff:
    1. diagonals lengths are the same
    2. diagonals cross at centers (midPoints are the same)
    */
    const map = {}
    for (let i = 0; i < points.length; i++) {
        for (let j = i + 1; j < points.length; j++) {
            const p1 = points[i]
            const p2 = points[j]
            if (isEqual(p1, p2)) continue
            
            // calculate diagonal length and mid point
            const diagonalLength = distance(p1, p2)
            const [xMid, yMid] = midPoint(p1, p2)
            
            const key = `${diagonalLength},${xMid},${yMid}`
            if (map[key] === undefined) {
                map[key] = []
            }
            
            map[key].push([p1, p2])            
        }
    }
    
    let min = Infinity
    for (const [key, pairs] of Object.entries(map)) {
        if (pairs.length < 2) continue  
        
        for (let i = 0; i < pairs.length; i++) {
            for (let j = i + 1; j < pairs.length; j++) {
                const [p1, p2] = pairs[i]
                const [p3, p4] = pairs[j]
                
                const area = distance(p1, p3) * distance(p1, p4)
                min = Math.min(min, area)
            }
        }
    }
    
    return min < Infinity ? min : 0
};

const midPoint = (p1, p2) => {
    const [x1, y1] = p1
    const [x2, y2] = p2
    return [(x1 + x2) / 2, (y1 + y2) / 2]
}

const distance = (p1, p2) => {
    const [x1, y1] = p1
    const [x2, y2] = p2
    return Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2)
}

const isEqual = (p1, p2) => {
    const [x1, y1] = p1
    const [x2, y2] = p2
    return x1 === x2 && y1 === y2
}
```

## 1748. Sum of Unique Elements
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var sumOfUnique = function(nums) {
    const map = {}
    for (const num of nums) {
        map[num] = 1 + (map[num] || 0)
    }
    
    let sum = 0
    for (const [key, val] of Object.entries(map)) {
        if (val === 1) {
            sum += +key
        }
    }
    return sum
};
```

## 1053. Previous Permutation With One Swap
```javascript
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var prevPermOpt1 = function(arr) {
    // Get index of first non decreasing element
    let i = arr.length - 2
    while (i >= 0) {
        if (arr[i] > arr[i + 1]) break
        i--
    }
    
    // If made it to the end, arr is already the smallest permutation
    if (i === -1) return arr
    
    /*
    Get index of largest element smaller than arr[i] in
    the non decreasing part of the array.
    */
    let j = arr.length - 1
    while (j > i) {
        if (arr[j] < arr[i]) break
        j--
    }
    
    /*
    If multiple of this element's val, get the 
    index of the one furthest to the left. 
    Example: [3,1,1,3] -> [1,3,1,3]
    */
    while (j > i && arr[j] === arr[j - 1]) {
        j--
    }
    
    swap(arr, i, j)
    return arr
};

const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

## 1648. Sell Diminishing-Valued Colored Balls
```javascript
/**
 * @param {number[]} inventory
 * @param {number} orders
 * @return {number}
 */
var maxProfit = function(inventory, orders) {
    const summationN = n => n * (n + BigInt(1)) / BigInt(2)
    const min = (a, b) => a < b ? a : b
    
    inventory.sort((a, b) => b - a)
    inventory.push(0)
    inventory = inventory.map(num => BigInt(num))
    
    orders = BigInt(orders)
    
    const MOD = BigInt(1e9 + 7)
    const n = inventory.length
    
    let result = BigInt(0)
    let top = inventory[0]
    let i = 1
    while(i < n && orders > 0) {
        while(i < n && inventory[i] === top) {
            i++
        }
                
        const factor = BigInt(i)
        const difference = BigInt(top - inventory[i])
        
        const ordersAvaliable = difference * factor
        const ordersTaken = min(orders, ordersAvaliable)
        
        const sellAll = ordersTaken / factor
        const sellRemaining = ordersTaken % factor
        
        result = (result + ((summationN(top) - summationN(top - sellAll)) * factor) % MOD) % MOD
        result = (result + ((top - sellAll) * sellRemaining) % MOD) % MOD
        
        orders -= ordersTaken
        
        top = inventory[i]
        i++
    }
    
    return result
};
```

## 651. 4 Keys Keyboard
```javascript
/**
 * @param {number} N
 * @return {number}
 */
var maxA = function(N) {
    // 3xN matrix to store info of 3 scenarios at each step
    const dp = new Array(N + 1).fill().map(a => new Array(3).fill(0))
    
    // 2xN matrix to store clipboard info of 2nd & 3rd scenarios
    const clipboard = new Array(N + 1).fill().map(a => new Array(2).fill(0))
    
    for (let i = 1; i <= N; i++) {
        // Scenario 1: key1
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]) + 1
        
        // Scenario 2: key4
        let op1 = -Infinity
        if (i >= 1) {
            // use paste result & clipboard from senario 2
            op1 = dp[i - 1][1] + clipboard[i - 1][0]
        }
        
        // use paste result & clipboard from senario 3
        const op2 = dp[i - 1][2] + clipboard[i - 1][1] 
        if (op1 <= op2) {
            dp[i][1] = op2
            clipboard[i][0] = clipboard[i - 1][1]
        } else {
            dp[i][1] = op1
            clipboard[i][0] = clipboard[i - 1][0]
        }
        
        // Scenario 3: key2 + key3 + key4
        if (i >= 3) {
            // find out largest value 3 steps before
            clipboard[i][1] = Math.max(dp[i - 3][0], dp[i - 3][1], dp[i - 3][2])
            // double it
            dp[i][2] = clipboard[i][1] * 2
        }
    }
    
    // in last step, max among 3 is the result
    return Math.max(dp[N][0], dp[N][1], dp[N][2])
};
```

## 887. Super Egg Drop
```javascript
// Binary Search
/**
 * @param {number} K
 * @param {number} N
 * @return {number}
 */
var superEggDrop = function(K, N) {
    const _superEggDrop = (eggs, floors) => {
        if (floors === 0) return 0
        if (eggs === 1) return floors
        
        if (memo[eggs][floors] !== undefined) {
            return memo[eggs][floors]
        }
        
        let result = floors
        let left = 1
        let right = floors

        while (left < right) {
            const mid = Math.floor((right - left) / 2) + left

            const eggDidBreak = _superEggDrop(eggs - 1, mid - 1)
            const eggDidNotBreak = _superEggDrop(eggs, floors - mid)

            result = Math.min(result, Math.max(eggDidBreak, eggDidNotBreak) + 1)

            if (eggDidBreak === eggDidNotBreak) {
                break
            } else if (eggDidBreak < eggDidNotBreak) {
                left = mid + 1
            } else {
                right = mid
            }
        }
        
        memo[eggs][floors] = result
        return result
    }
    
    const memo = new Array(K + 1).fill().map(a => new Array(N + 1))
    return _superEggDrop(K, N)
};
```

## 1758. Minimum Changes To Make Alternating Binary String
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minOperations = function(s) {
    return Math.min(countWithStart(s, 0), countWithStart(s, 1))
};

const countWithStart = (s, num) => {
    let count = 0
    for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0) {
            count += s[i] != num
        } else {
            count += s[i] != (1 ^ num)
        }
    }
    return count
}
```

## 1757. Recyclable and Low Fat Products
```sql
# Write your MySQL query statement below
SELECT product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y'
```

## 1752. Check if Array Is Sorted and Rotated
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var check = function(nums) {
    // find index before pivot
    let pivotIndex = 0
    while (pivotIndex < nums.length && nums[pivotIndex] <= nums[pivotIndex + 1]) {
        pivotIndex++
    }
    
    // move one forward to pivot index
    pivotIndex++
    
    // if reached end then arr is sorted without rotation
    if (pivotIndex >= nums.length) {
        return true
    }
    
    for (let i = 0; i < nums.length; i++) {
        const nextIndex = (pivotIndex + 1) % nums.length
        if (nums[pivotIndex] > nums[nextIndex]) {
            return false
        }
        
        pivotIndex++
    }
    
    return true
};
```

## 1759. Count Number of Homogenous Substrings
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var countHomogenous = function(s) {
    const MOD = 10 ** 9 + 7
    let count = 0
    
    let left = 0
    for (let right = 0; right < s.length; right++) {
        while (s[left] !== s[right]) {
           left++
        }

        const len = right - left + 1
        count += len
        count %= MOD
    }
        
    return count
};
```

## 1762. Buildings With an Ocean View
```javascript
/**
 * @param {number[]} heights
 * @return {number[]}
 */
var findBuildings = function(heights) {
    const stack = []
    for (let i = 0; i < heights.length; i++) {
        while (stack.length && heights[stack[stack.length - 1]] <= heights[i]) {
            stack.pop()
        }
        stack.push(i)
    }
    
    return stack
};
```

## 2. Add Two Numbers
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    const dummy = new ListNode(NaN)
    let curr = dummy
    let carry = 0
    while (l1 || l2) {
        const l1Val = l1 ? l1.val : 0
        const l2Val = l2 ? l2.val : 0
        
        const sum = l1Val + l2Val + carry
        const digit = sum % 10
        carry = Math.trunc(sum / 10)
        
        curr.next = new ListNode(digit)
        curr = curr.next
        
        if (l1) l1 = l1.next
        if (l2) l2 = l2.next
    }
    
    if (carry > 0) {
        curr.next = new ListNode(carry)
    }
    
    return dummy.next
};
```

## 1763. Longest Nice Substring
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestNiceSubstring = function(s) {
    const _longestNiceSubstring = (left, right) => {
        if (right - left + 1 <= 1) return [-1, -1]
        
        const set = new Set()
        for (let i = left; i <= right; i++) {
            set.add(s[i])
        }
        
        for (let i = left; i <= right; i++) {
            if (set.has(s[i].toUpperCase()) && set.has(s[i].toLowerCase())) {
                continue
            }

            const [s1Left, s1Right] = _longestNiceSubstring(left, i - 1)
            const [s2Left, s2Right] = _longestNiceSubstring(i + 1, right)
            
            const s1Len = s1Right - s1Left + 1
            const s2Len = s2Right - s2Left + 1
            return s1Len < s2Len ? [s2Left, s2Right] : [s1Left, s1Right]
        }

        return [left, right]
    }
    
    const [left, right] = _longestNiceSubstring(0, s.length - 1)
    return s.slice(left, right + 1)
};
```

## 1765. Map of Highest Peak
```javascript
/**
 * @param {number[][]} isWater
 * @return {number[][]}
 */
var highestPeak = function(isWater) {
    const rowLen = isWater.length
    const colLen = isWater[0].length
    
    const result = new Array(rowLen).fill().map(a => new Array(colLen).fill(-1))
    
    const queue = []
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (isWater[row][col] === 1) {
                queue.push([row, col])
                result[row][col] = 0
            }
        }
    }
    
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    let height = 1
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
        const [row, col] = queue.shift()
            for (const [deltaRow, deltaCol] of dirs) {
                const nextRow = row + deltaRow
                const nextCol = col + deltaCol

                if (nextRow < 0 || nextRow >= rowLen || 
                    nextCol < 0 || nextCol >= colLen) continue

                if (result[nextRow][nextCol] !== -1) continue

                result[nextRow][nextCol] = height
                queue.push([nextRow, nextCol])
            }
        }
        height++
    }
    
    return result
};
```

## 1769. Minimum Number of Operations to Move All Balls to Each Box
```javascript
/**
 * @param {string} boxes
 * @return {number[]}
 */
var minOperations = function(boxes) {
    const result = new Array(boxes.length).fill(0)
    
    let leftCount = 0
    let leftMoves = 0
    
    let rightCount = 0
    let rightMoves = 0
    
    let left = 0
    let right = boxes.length - 1
    
    while (left < boxes.length) {
        result[left] += leftMoves
        result[right] += rightMoves
        
        if (boxes[left] === '1') {
            leftCount++
        }

        if (boxes[right] === '1') {
            rightCount++
        }
        
        leftMoves += leftCount
        rightMoves += rightCount
        
        left++
        right--
    }
    
    return result
};
```

## 1768. Merge Strings Alternately
```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {string}
 */
var mergeAlternately = function(word1, word2) {
    const result = []
    
    let i = 0
    let j = 0
    while (i < word1.length && j < word2.length) {
        result.push(word1[i])
        result.push(word2[j])
        i++
        j++
    }
    
    while (i < word1.length) {
        result.push(word1[i])
        i++
    }
    
    while (j < word2.length) {
        result.push(word2[j])
        j++
    }
    
    return result.join('')
};
```

## 1770. Maximum Score from Performing Multiplication Operations
```javascript
/**
 * @param {number[]} nums
 * @param {number[]} multipliers
 * @return {number}
 */
var maximumScore = function(nums, multipliers) {
    const _maximumScore = (i, left) => {
        if (i >= multipliers.length) return 0
        
        if (memo[i][left] !== undefined) {
            return memo[i][left]
        }
        
        const right = nums.length - 1 - (i - left)
        
        const chooseLeft = multipliers[i] * nums[left] + _maximumScore(i + 1, left + 1)
        const chooseRight = multipliers[i] * nums[right] + _maximumScore(i + 1, left)
        
        memo[i][left] = Math.max(chooseLeft, chooseRight)
        return memo[i][left]
    }
    
    const m = multipliers.length
    const memo = new Array(m).fill().map(a => new Array(m))
    return _maximumScore(0, 0)
};
```

## 1650. Lowest Common Ancestor of a Binary Tree III
```javascript
/**
 * // Definition for a Node.
 * function Node(val) {
 *    this.val = val;
 *    this.left = null;
 *    this.right = null;
 *    this.parent = null;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var lowestCommonAncestor = function(p, q) {
    const pCount = getCount(p)
    const qCount = getCount(q)
    
    const diff = Math.abs(pCount - qCount)
    if (pCount < qCount) {
        q = moveForward(q, diff)
    } else {
        p = moveForward(p, diff)
    }
    
    while (p !== q) {
        p = p.parent
        q = q.parent
    }
    
    return p
};

const moveForward = (node, steps) => {
    for (let i = 0; i < steps; i++) {
        node = node.parent
    }
    
    return node
}

const getCount = node => {
    let count = 0
    while (node) {
        node = node.parent
        count++
    }
    return count
}
```

## 1772. Sort Features by Popularity
```javascript
/**
 * @param {string[]} features
 * @param {string[]} responses
 * @return {string[]}
 */
var sortFeatures = function(features, responses) {
    const map = {}
    for (const response of responses) {
        const words = response.split(' ')
        const unique = new Set(words)
        for (const word of unique) {
            map[word] = 1 + (map[word] || 0)
        }
    }
    
    return features.sort((a, b) => {
        const appearanceA = (map[a] || 0)
        const appearanceB = (map[b] || 0)
        return appearanceB - appearanceA
    })
};
```

## 271. Encode and Decode Strings
```javascript
// https://developer.mozilla.org/en-US/docs/Web/API/DOMString/Binary
/**
 * Encodes a list of strings to a single string.
 *
 * @param {string[]} strs
 * @return {string}
 */
var encode = function(strs) {
    const result = []
    
    for (const word of strs) {
        const len = word.length
        result.push(encodeNumber(len))
        result.push(word)
    }
    
    return result.join('')
};

/**
 * Decodes a single string to a list of strings.
 *
 * @param {string} s
 * @return {string[]}
 */
var decode = function(s) {
    const charArr = s.split('')
    const result = []
    let i = 0
    while (i < charArr.length) {
        const len = decodeNumber(charArr[i++])
        const substr = charArr.slice(i, i + len)
        result.push(substr.join(''))
        i += len
    }
    
    return result
};

/**
 * Your functions will be called as such:
 * decode(encode(strs));
 */

const encodeNumber = num => String.fromCharCode(num)
const decodeNumber = str => str.charCodeAt(0)
```

## 689. Maximum Sum of 3 Non-Overlapping Subarrays
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSumOfThreeSubarrays = function(nums, k) {
    const left = []
    let leftSum = 0
    for (let i = 0; i < k; i++) {
        leftSum += nums[i]
        left.push({index: -1, sum: -Infinity})
    }
    
    let leftMax = leftSum
    let leftMaxStart = 0
    left[left.length - 1] = ({index: 0, sum: leftMax})
    
    for (let j = k; j < nums.length; j++) {
        leftSum -= nums[j - k]
        leftSum += nums[j]
        
        if (leftMax < leftSum) {
            leftMax = leftSum
            leftMaxStart = j - k + 1
        }
        
        left.push({index: leftMaxStart, sum: leftMax})
    }

    const right = []
    let rightSum = 0
    for (let i = nums.length - 1; i >= nums.length - k; i--) {
        rightSum += nums[i]
        right.push({index: nums.length, sum: -Infinity})
    }
        
    let rightMax = rightSum
    let rightMaxStart = nums.length - k
    right[right.length - 1] = {index: rightMaxStart, sum: rightMax}
    
    for (let j = nums.length - k - 1; j >= 0; j--) {
        rightSum -= nums[j + k]
        rightSum += nums[j]
        
        if (rightMax < rightSum) {
            rightMax = rightSum
            rightMaxStart = j
        }
        
        if (rightMax === rightSum && rightMaxStart > j) {
            rightMaxStart = j
        }
        
        right.push({index: rightMaxStart, sum: rightMax})
    }
    
    right.reverse()
    
    let max = 0
    let indices = []
    
    let sum = 0
    for (let i = 0; i < k; i++) {
        sum += nums[i]
    }

    for (let j = k; j < nums.length - 1; j++) {
        sum -= nums[j - k]
        sum += nums[j]
        
        const leftBound = j - k
        const rightBound = j + 1

        const currSum = sum + left[leftBound].sum + right[rightBound].sum
        if (currSum > max) {
            max = currSum
            indices = [left[leftBound].index, j - k + 1, right[rightBound].index]
        }
    }
    
    
   return indices
};
```

## 45. Jump Game II
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    if (nums.length <= 1) return 0
    
    let jumps = 1
    let maxReachForCurrJump = nums[0]
    let maxReachForNextJump = nums[0]
    
    for (let i = 1; i < nums.length; i++) {
        if (i > maxReachForCurrJump) {
            jumps++
            maxReachForCurrJump = maxReachForNextJump
        }
        
        maxReachForNextJump = Math.max(maxReachForNextJump, nums[i] + i)
    }
    
    return jumps
};
```

## 1011. Capacity To Ship Packages Within D Days
```javascript
/**
 * @param {number[]} weights
 * @param {number} D
 * @return {number}
 */
var shipWithinDays = function(weights, D) {
    let totalSum = 0
    for (const num of weights) {
        totalSum += num
    }
    
    let left = 1
    let right = totalSum
    
    while (left < right) {
        const mid = Math.floor((right - left) / 2) + left
        
        if (canShip(weights, mid, D)) {
            right = mid
        } else {
            left = mid + 1
        }
    }
    
    return left
};

const canShip = (weights, capacity, D) => {
    let day = 1
    let currWeight = 0
    
    for (const weight of weights) {
        if (weight > capacity || day > D) return false
        
        if (currWeight + weight > capacity) {
            currWeight = 0
            day++
        }
        
        currWeight += weight
    }
    
    return day <= D
}
```

## 911. Online Election
```javascript
/**
 * @param {number[]} persons
 * @param {number[]} times
 */
var TopVotedCandidate = function(persons, times) {
    this.leaders = []
    const votes = {}
    let leader = -1
    for (let i = 0; i < persons.length; i++) {
        votes[persons[i]] = 1 + (votes[persons[i]] || 0)
        if (leader === -1 || votes[persons[i]] >= votes[leader]) {
            leader = persons[i]
        }
        
        this.leaders.push([times[i], leader])
    }
};

/** 
 * @param {number} t
 * @return {number}
 */
TopVotedCandidate.prototype.q = function(t) {
    let left = 0
    let right = this.leaders.length - 1
    
    while (left < right) {
        const mid = Math.floor((right - left + 1) / 2) + left
        const [midTime, midLeader] = this.leaders[mid]
        
        if (midTime <= t) {
            left = mid
        } else {
            right = mid - 1
        }
    }
    
    return this.leaders[right][1]
};

/** 
 * Your TopVotedCandidate object will be instantiated and called as such:
 * var obj = new TopVotedCandidate(persons, times)
 * var param_1 = obj.q(t)
 */
```

## 142. Linked List Cycle II
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if (!head) return null
    
    let slow = head
    let fast = head
    
    while (fast && fast.next) {
        slow = slow.next
        fast = fast.next.next
        
        if (slow === fast) break
    }
    
    if (!fast || !fast.next) return null
    
    slow = head
    
    while (slow !== fast) {
        fast = fast.next
        slow = slow.next
    }
    return slow
};
```

## 1628. Design an Expression Tree With Evaluate Function
```javascript
/**
 * This is the interface for the expression tree Node.
 * You should not remove it, and you can define some classes to implement it.
 */

var Node = function (val) {
    this.val = val
    this.left = null
    this.right = null
};

Node.prototype.evaluate = function () {
    const _evalute = node => {
        if (!node.left && !node.right) {
            return node.val
        }
        
        return eval(+_evalute(node.left), +_evalute(node.right), node.val)
    }
    
    return _evalute(this)
};

/**
 * This is the TreeBuilder class.
 * You can treat it as the driver code that takes the postinfix input 
 * and returns the expression tree represnting it as a Node.
 */

class TreeBuilder{
	/**
     * @param {string[]} s
     * @return {Node}
     */
	buildTree(postfix) {
        const stack = []
        for (let i = 0; i < postfix.length; i++) {
            const node = new Node(postfix[i])
            
            if (!isNumber(postfix[i])) {
                const right = stack.pop()
                const left = stack.pop()
                node.left = left
                node.right = right   
            }
            
            stack.push(node)
        }
        
    	return stack.pop()
	}
    
}

/**
 * Your TreeBuilder object will be instantiated and called as such:
 * var obj = new TreeBuilder();
 * var expTree = obj.buildTree(postfix);
 * var ans = expTree.evaluate();
 */

const isNumber = num => {
    return !isNaN(+num)
}

const eval = (num1, num2, operator) => {
    switch(operator) {
        case '+':
            return num1 + num2
        case '-':
            return num1 - num2
        case '*':
            return num1 * num2
        case '/':
            return num1 / num2
        default:
            throw new Error('Invalid operator')
    }
}
```

## 772. Basic Calculator III
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    // convert to postfix expression
    const postfix = convertToPostfix(s)
    
    // evaluate postfix expression
    return evaluatePostfix(postfix)
};

// Reverse Polish Notation Algo
// 150. Evaluate Reverse Polish Notation
// https://leetcode.com/problems/evaluate-reverse-polish-notation/
const evaluatePostfix = postfix => {
    const stack = []
    
    for (const token of postfix) {
        if (isOperand(token)) {
            stack.push(token)
        } else {
            const right = stack.pop()
            const left = stack.pop()
            stack.push(evaluate(left, right, token))
        }
    }
    
    return stack.pop()
}

// https://www.youtube.com/watch?v=vq-nUF0G4fI&t=918s
const convertToPostfix = infix => {
    const postfix = []
    const stack = []
    
    let num = null
    for (let i = 0; i < infix.length; i++) {
        const token = infix[i]
        
        // Ignore Whitespace
        if (token === ' ') continue
        
        // Handles case where operand is multiple digits
        if (isOperand(token)) {
            if (num === null) num = 0
            
            num *= 10
            num += +token
            continue
        }
        
        // Add operand to postfix before continuing
        if (num !== null) postfix.push(num)
        num = null
        
        if (isOperator(token)) {
            // if uniary '+' then skip
            if (token === '+' && infix[i - 1] === undefined || infix[i - 1] === '(') {
                continue
            }
            
            // if uniary '-' convert to binary operator by inserting 0 on left side
            if (token === '-' && infix[i - 1] === undefined || infix[i - 1] === '(') {
                postfix.push(0)
            }
            
            // remove higher precendence operators from stack first
            while (stack.length && 
                   stack[stack.length - 1] !== '(' && 
                   hasHigherPrecendence(stack[stack.length - 1], token)) {
                postfix.push(stack.pop())
            }
            stack.push(token)
            continue
        }
        
        if (token === '(') {
            stack.push(token)
            continue
        }
        
        // remove all operators up to the next open '(' in stack
        if (token === ')') {
            while (stack.length && stack[stack.length - 1] !== '(') {
                postfix.push(stack.pop())
            }
            stack.pop()
        }
    }
    
    // Add final of expression
    if (num !== null) postfix.push(num)
    num = null
    
    // Add remaining operators to end
    while (stack.length) {
        postfix.push(stack.pop())
    }
    
    return postfix
}

const evaluate = (left, right, op) => {
    switch(op) {
        case '+': return left + right
        case '-': return left - right
        case '*': return left * right
        // integer division should truncate toward zero
        case '/': return Math.trunc(left / right)
    }
}

const isOperator = token => '+-*/'.includes(token)
const isOperand = token => !isNaN(+token)
const hasHigherPrecendence = (op1, op2) => getWeight(op1) >= getWeight(op2)

const getWeight = op => {
    switch(op) {
        case '+': return 1
        case '-': return 1
        case '*': return 2
        case '/': return 2
    }
}
```

## 227. Basic Calculator II
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    // convert to postfix expression
    const postfix = convertToPostfix(s)
    
    // evaluate postfix expression
    return evaluatePostfix(postfix)
};

// Reverse Polish Notation Algo
// 150. Evaluate Reverse Polish Notation
// https://leetcode.com/problems/evaluate-reverse-polish-notation/
const evaluatePostfix = postfix => {
    const stack = []
    
    for (const token of postfix) {
        if (isOperand(token)) {
            stack.push(token)
        } else {
            const right = stack.pop()
            const left = stack.pop()
            stack.push(evaluate(left, right, token))
        }
    }
    
    return stack.pop()
}

// https://www.youtube.com/watch?v=vq-nUF0G4fI&t=918s
const convertToPostfix = infix => {
    const postfix = []
    const stack = []
    
    let num = null
    for (let i = 0; i < infix.length; i++) {
        const token = infix[i]
        
        // Ignore Whitespace
        if (token === ' ') continue
        
        // Handles case where operand is multiple digits
        if (isOperand(token)) {
            if (num === null) num = 0
            
            num *= 10
            num += +token
            continue
        }
        
        // Add operand to postfix before continuing
        if (num !== null) postfix.push(num)
        num = null
        
        if (isOperator(token)) {
            // if uniary '+' then skip
            if (token === '+' && infix[i - 1] === undefined || infix[i - 1] === '(') {
                continue
            }
            
            // if uniary '-' convert to binary operator by inserting 0 on left side
            if (token === '-' && infix[i - 1] === undefined || infix[i - 1] === '(') {
                postfix.push(0)
            }
            
            // remove higher precendence operators from stack first
            while (stack.length && 
                   stack[stack.length - 1] !== '(' && 
                   hasHigherPrecendence(stack[stack.length - 1], token)) {
                postfix.push(stack.pop())
            }
            stack.push(token)
            continue
        }
        
        if (token === '(') {
            stack.push(token)
            continue
        }
        
        // remove all operators up to the next open '(' in stack
        if (token === ')') {
            while (stack.length && stack[stack.length - 1] !== '(') {
                postfix.push(stack.pop())
            }
            stack.pop()
        }
    }
    
    // Add final of expression
    if (num !== null) postfix.push(num)
    num = null
    
    // Add remaining operators to end
    while (stack.length) {
        postfix.push(stack.pop())
    }
    
    return postfix
}

const evaluate = (left, right, op) => {
    switch(op) {
        case '+': return left + right
        case '-': return left - right
        case '*': return left * right
        // integer division should truncate toward zero
        case '/': return Math.trunc(left / right)
    }
}

const isOperator = token => '+-*/'.includes(token)
const isOperand = token => !isNaN(+token)
const hasHigherPrecendence = (op1, op2) => getWeight(op1) >= getWeight(op2)

const getWeight = op => {
    switch(op) {
        case '+': return 1
        case '-': return 1
        case '*': return 2
        case '/': return 2
    }
}
```

## 224. Basic Calculator
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    // convert to postfix expression
    const postfix = convertToPostfix(s)
    
    // evaluate postfix expression
    return evaluatePostfix(postfix)
};

// Reverse Polish Notation Algo
// 150. Evaluate Reverse Polish Notation
// https://leetcode.com/problems/evaluate-reverse-polish-notation/
const evaluatePostfix = postfix => {
    const stack = []
    
    for (const token of postfix) {
        if (isOperand(token)) {
            stack.push(token)
        } else {
            const right = stack.pop()
            const left = stack.pop()
            stack.push(evaluate(left, right, token))
        }
    }
    
    return stack.pop()
}

// https://www.youtube.com/watch?v=vq-nUF0G4fI&t=918s
const convertToPostfix = infix => {
    const postfix = []
    const stack = []
    
    let num = null
    for (let i = 0; i < infix.length; i++) {
        const token = infix[i]
        
        // Ignore Whitespace
        if (token === ' ') continue
        
        // Handles case where operand is multiple digits
        if (isOperand(token)) {
            if (num === null) num = 0
            
            num *= 10
            num += +token
            continue
        }
        
        // Add operand to postfix before continuing
        if (num !== null) postfix.push(num)
        num = null
        
        if (isOperator(token)) {
            // if uniary '+' then skip
            if (token === '+' && infix[i - 1] === undefined || infix[i - 1] === '(') {
                continue
            }
            
            // if uniary '-' convert to binary operator by inserting 0 on left side
            if (token === '-' && infix[i - 1] === undefined || infix[i - 1] === '(') {
                postfix.push(0)
            }
            
            // remove higher precendence operators from stack first
            while (stack.length && 
                   stack[stack.length - 1] !== '(' && 
                   hasHigherPrecendence(stack[stack.length - 1], token)) {
                postfix.push(stack.pop())
            }
            stack.push(token)
            continue
        }
        
        if (token === '(') {
            stack.push(token)
            continue
        }
        
        // remove all operators up to the next open '(' in stack
        if (token === ')') {
            while (stack.length && stack[stack.length - 1] !== '(') {
                postfix.push(stack.pop())
            }
            stack.pop()
        }
    }
    
    // Add final of expression
    if (num !== null) postfix.push(num)
    num = null
    
    // Add remaining operators to end
    while (stack.length) {
        postfix.push(stack.pop())
    }
    
    return postfix
}

const evaluate = (left, right, op) => {
    switch(op) {
        case '+': return left + right
        case '-': return left - right
        case '*': return left * right
        // integer division should truncate toward zero
        case '/': return Math.trunc(left / right)
    }
}

const isOperator = token => '+-*/'.includes(token)
const isOperand = token => !isNaN(+token)
const hasHigherPrecendence = (op1, op2) => getWeight(op1) >= getWeight(op2)

const getWeight = op => {
    switch(op) {
        case '+': return 1
        case '-': return 1
        case '*': return 2
        case '/': return 2
    }
}
```

## 1773. Count Items Matching a Rule
```javascript
/**
 * @param {string[][]} items
 * @param {string} ruleKey
 * @param {string} ruleValue
 * @return {number}
 */
var countMatches = function(items, ruleKey, ruleValue) {
    let count = 0
    
    for (const [type, color, name] of items) {
        if (ruleKey === 'type') {
            count += ruleValue === type
        } else if (ruleKey === 'color') {
            count += ruleValue === color
        } else if (ruleKey === 'name') {
            count += ruleValue === name
        }
    }
    
    return count
};
```

## 1721. Swapping Nodes in a Linked List
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var swapNodes = function(head, k) {
    const length = getLength(head)
    
    let startK = head
    for (let i = 1; i < k; i++) {
        startK = startK.next
    }
    
    let endK = head
    for (let i = 1; i < length - k + 1; i++) {
        endK = endK.next
    }
    
    const temp = startK.val
    startK.val = endK.val
    endK.val = temp
    
    return head
};

const getLength = head => {
    let length = 0
    while (head) {
        head = head.next
        length++
    }
    return length
}
```

## 1660. Correct a Binary Tree
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} from
 * @param {number} to
 * @return {TreeNode}
 */
var correctBinaryTree = function(root) {
    const dfs = (node, level) => {
        if (!node) return
        
        map[node.val] = level
        
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)
    }
    
    const _correctBinaryTree = (node, level) => {
        if (!node) return null
        
        if (node.right && map[node.right.val] === level) {
            return null
        }
        
        node.left = _correctBinaryTree(node.left, level + 1)
        node.right = _correctBinaryTree(node.right, level + 1)
        return node
    }
    
    const map = {}
    dfs(root, 0)
    return _correctBinaryTree(root, 0)
};
```

## 97. Interleaving String
```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function(s1, s2, s3) {
    const _isInterleave = (i, j) => {
        const k = i + j
        
        if (k >= s3.length) {
            return i >= s1.length && j >= s2.length
        }
        
        if (memo[i][j] !== undefined) {
            return memo[i][j]
        }
        
        let result = false
        if (s1[i] === s3[k]) {
            result = result || _isInterleave(i + 1, j)
        }
        
        if (s2[j] === s3[k]) {
            result = result || _isInterleave(i, j + 1)
        }
        
        memo[i][j] = result
        return result
    }
    
    const memo = new Array(s1.length + 1).fill().map(a => new Array(s2.length + 1))
    return _isInterleave(0, 0)
};
```

## 391. Perfect Rectangle
```javascript
/**
 * @param {number[][]} rectangles
 * @return {boolean}
 */
var isRectangleCover = function(rectangles) {
    let x1 = Infinity
    let y1 = Infinity
    
    let x2 = -Infinity
    let y2 = -Infinity
    
    const set = new Set()
    let area = 0
    
    for (const [currX1, currY1, currX2, currY2] of rectangles) {
        
        x1 = Math.min(currX1, x1)
        y1 = Math.min(currY1, y1)
        
        x2 = Math.max(currX2, x2)
        y2 = Math.max(currY2, y2)
        
        area += (currX2 - currX1) * (currY2 - currY1)
        
        const point1Key = currX1 + " " + currY1
        const point2Key = currX1 + " " + currY2
        const point3Key = currX2 + " " + currY2
        const point4Key = currX2 + " " + currY1
        
        // Each point expect the four corners of rectangular hull 
        // must appear on even number of times. We are XORing here using a set
        if (set.has(point1Key)) {
            set.delete(point1Key)
        } else {
            set.add(point1Key)
        }
        
        if (set.has(point2Key)) {
            set.delete(point2Key)
        } else {
            set.add(point2Key)
        }
        
        if (set.has(point3Key)) {
            set.delete(point3Key)
        } else {
            set.add(point3Key)
        }
        
        if (set.has(point4Key)) {
            set.delete(point4Key)
        } else {
            set.add(point4Key)
        }
    }
    
    if (!set.has(x1 + " " + y1) || 
        !set.has(x1 + " " + y2) || 
        !set.has(x2 + " " + y1) || 
        !set.has(x2 + " " + y2) || 
        set.size !== 4) return false // four outer corners should appear once
    
    // area of rectangular hull should be equal to sum of areas of small rectangles
    return area === (x2 - x1) * (y2 - y1)
};
```

## 240. Search a 2D Matrix II
```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
    const m = matrix.length
    const n = matrix[0].length
    
    let row = 0
    let col = n - 1
    
    while (col >= 0 && row < m) {
        if (matrix[row][col] === target) {
            return true
        }
        
        if (matrix[row][col] > target) {
            col--
            continue
        }
        
        row++
    }
    
    return false
};
```

## 987. Vertical Order Traversal of a Binary Tree
```javascript
// DFS
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var verticalTraversal = function(root) {
    const _verticalTraversal = (node, row, col) => {
        if (!node) return
        
        if (!map[col]) map[col] = []
        map[col].push([row, node.val])
        
        min = Math.min(min, col)
        max = Math.max(max, col)
        
        _verticalTraversal(node.left, row + 1, col - 1)
        _verticalTraversal(node.right, row + 1, col + 1)
    }
    
    let min = Infinity
    let max = -Infinity
    const map = {}
    _verticalTraversal(root, 0, 0)
    
    const result = []
    for (let i = min; i <= max; i++) {
        const sorted = map[i].sort((a, b) => a[0] - b[0] || a[1] - b[1]).map(a => a[1])
        result.push(sorted)
    }
    return result
};
```

## 287. Find the Duplicate Number
```javascript
// Time: O(n), Space: O(1) - Modify
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
    for (const num of nums) {
        const index = Math.abs(num)
        if (nums[index] < 0) return index
        nums[index] *= -1
    }
};

// Time: O(n), Space: O(1) - Linked List Cycle
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
    let fast = nums[0]
    let slow = nums[0]
    
    while (true) {
        fast = nums[nums[fast]]
        slow = nums[slow]
        
        if (fast === slow) break
    }
    
    slow = nums[0]
    
    while (fast !== slow) {
        fast = nums[fast]
        slow = nums[slow]
    }
    
    return slow
};
```

## 109. Convert Sorted List to Binary Search Tree
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {ListNode} head
 * @return {TreeNode}
 */
var sortedListToBST = function(head) {
    const _sortedListToBST = (left, right) => {
        if (left > right) return null
        
        const mid = Math.floor((right - left) / 2) + left
        const node = new TreeNode(arr[mid])
        node.left = _sortedListToBST(left, mid - 1)
        node.right = _sortedListToBST(mid + 1, right)
        return node
    }
    
    const arr = []
    let node = head
    while (node) {
        arr.push(node.val)
        node = node.next
    }
    
    return _sortedListToBST(0, arr.length - 1)
};
```

## 813. Largest Sum of Averages
```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var largestSumOfAverages = function(A, K) {
    const _largestSumOfAverages = (index, group) => {
        if (index >= A.length) return 0
        if (group >= K) return -Infinity
        
        if (memo[index][group] !== undefined) {
            return memo[index][group]
        }
        
        let max = 0
        let groupSum = 0
        for (let i = index; i < A.length; i++) {
            groupSum += A[i]
            
            const totalSum = _largestSumOfAverages(i + 1, group + 1)
            max = Math.max(max, totalSum + groupSum / (i - index + 1))
        }
        
        memo[index][group] = max
        return max
    }
    
    const memo = new Array(A.length).fill().map(a => new Array(K))
    return _largestSumOfAverages(0, 0)
};
```

## 646. Maximum Length of Pair Chain
```javascript
/**
 * @param {number[][]} pairs
 * @return {number}
 */
var findLongestChain = function(pairs) {
    pairs.sort((a, b) => a[1] - b[1])
    
    let count = 0
    let bound = -Infinity
    for (const [start, end] of pairs) {
        if (bound < start) {
            bound = end
            count++
        }
    }
    
    return count
};
```

## 18. 4Sum
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a, b) => a - b)
    
    const result = []
    
    for (let i = 0; i < nums.length; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue
        
        for (let j = i + 1; j < nums.length; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue
            
            let left = j + 1
            let right = nums.length - 1
            
            while (left < right) {
                const sum = nums[i] + nums[j] + nums[left] + nums[right]
                
                if (sum === target) {
                    result.push([nums[i], nums[j], nums[left], nums[right]])
                    
                    while (left < right && nums[left] === nums[left + 1]) {
                        left++
                    }
                    left++
                    
                    while (left < right && nums[right] === nums[right - 1]) {
                        right--
                    }
                    right--
                    
                } else if (sum < target) {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    
    return result
};
```

## 726. Number of Atoms
```javascript
/**
 * @param {string} formula
 * @return {string}
 */
var countOfAtoms = function(formula) {
    const _countOfAtoms = () => {
        if (i >= formula.length) return {}
        
        const map = {}
        let element = []
        let count = 0
        
        while (i < formula.length) {
            const char = formula[i]
            
            if (char === '(') {
                i++
                const nestedMap = _countOfAtoms()
                for (const [key, val] of Object.entries(nestedMap)) {
                    map[key] = val + (map[key] || 0)
                }
                continue
            }
            
            if (char === ')') {
                const elementStr = element.join('')
                if (elementStr.length) {
                    map[elementStr] = (count || 1) + (map[elementStr] || 0)
                }
                
                i++
                
                // add multipler to map
                let multiplier = 0
                while (isDigit(formula[i])) {
                    multiplier *= 10
                    multiplier += +formula[i]
                    i++
                }
                
                if (multiplier > 1) {
                    for (const key of Object.keys(map)) {
                        map[key] *= multiplier
                    }
                }
                
                return map
            }
            
            if (isDigit(char)) {
                count *= 10
                count += +char
                i++
                continue
            }
            
            if (char === char.toUpperCase()) {
                i++
                const elementStr = element.join('')
                if (elementStr.length) {
                    map[elementStr] = (count || 1) + (map[elementStr] || 0)
                }
                
                element = []
                count = 0
                
                element.push(char)
                continue
            }
            
            if (char === char.toLowerCase()) {
                element.push(char)
                i++
                continue
            }
        }
        
        const elementStr = element.join('')
        if (elementStr.length) {
            map[elementStr] = (count || 1) + (map[elementStr] || 0)
        }
        
        return map
    }
    
    let i = 0
    
    const result = []
    const elements = Object.entries(_countOfAtoms())
    elements.sort((a, b) => a[0].localeCompare(b[0]))
    for (const [element, count] of elements) {
        result.push(element)
        result.push(count > 1 ? count : '')
    }
    
    return result.join('')
};

const isDigit = char => '0' <= char && char <= '9'
```

## 214. Shortest Palindrome
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
    const reversedS = s.split('').reverse().join('')
    const concatS = s + '#' + reversedS
    const lpsTable = getLPSTable(concatS)
    const suffixLength = lpsTable[concatS.length - 1]
    return reversedS.slice(0, s.length - suffixLength) + s
};

const getLPSTable = s => {
    const lpsTable = new Array(s.length).fill(0)
    let len = 0
    let i = 1
    
    while (i < s.length) {
        if (s[i] === s[len]) {
            lpsTable[i] = len + 1
            i++
            len++
            continue
        }
        
        if (len === 0) {
            i++
            continue
        }
        
        len = lpsTable[len - 1]
    }
    
    return lpsTable
}
```

## 301. Remove Invalid Parentheses
```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function(s) {
    const [left, right] = leftRightCount(s)
    const queue = [[s, 0, left, right]]
    const visited = new Set([`${s}-${0}-${left}-${right}`])
    let level = 0
    const result = []
    let foundMin = false
    
    while (queue.length) {
        const size = queue.length
        for (let i = 0; i < size; i++) {
            const [str, start, left, right] = queue.shift()

            if (left === 0 && right === 0 && isValid(str)) {
                foundMin = true
                result.push(str)
                continue
            }
            
            for (const [neighbor, i, nLeft, nRight] of getNeighbors(str, start, left, right)) {
                if (visited.has(`${neighbor}-${i}-${nLeft}-${nRight}`)) continue
                visited.add(`${neighbor}-${i}-${nLeft}-${nRight}`)
                queue.push([neighbor, i, nLeft, nRight])
            }   
        }
        
        if (foundMin) break
        level++
    }
    
    return result
};

const getNeighbors = (str, start, left, right) => {
    const neighbors = []
    for (let i = start; i < str.length; i++) {
        if (str[i] === '(' && left <= 0) continue
        if (str[i] === ')' && right <= 0) continue
        if (i > 0 && str[i] === str[i - 1]) continue
        
        if (str[i] === '(') {
            neighbors.push([str.slice(0, i) + str.slice(i + 1), start, left - 1, right])
        } else if (str[i] === ')') {
            neighbors.push([str.slice(0, i) + str.slice(i + 1), start, left, right - 1])
        }
    }
    return neighbors
}

const isValid = str => {
    let balance = 0
    for (const char of str) {
        if (char === '(') {
            balance++
        } else if (char === ')') {
            balance--
        }
        
        if (balance < 0) return false
    }
    
    return balance === 0
}

const leftRightCount = (str) => {
    let left = 0
    let right = 0
    
    for (const char of str) {
        if (char === '(') {
            left++
        } else if (char === ')') {
            if (left === 0) {
                right++
            } else {
                left--
            }
        }
    }
    
    return [left, right]
}
```

## 611. Valid Triangle Number
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangleNumber = function(nums) {
    nums.sort((a, b) => a - b)
    
    let count = 0
    for (let i = 0; i < nums.length - 2; i++) {
        let k = i + 2
        for (let j = i + 1; j < nums.length - 1; j++) {
            while (k < nums.length && nums[i] + nums[j] > nums[k]) {
                k++
            }
            
            if (j < k) {
                count += k - j - 1
            }
        }
    }
    
    return count
};
```

## 1583. Count Unhappy Friends
```javascript
/**
 * @param {number} n
 * @param {number[][]} preferences
 * @param {number[][]} pairs
 * @return {number}
 */
var unhappyFriends = function(n, preferences, pairs) {
    const preferenceMap = {}
    for (const [x, y] of pairs) {
        preferenceMap[x] = new Set()
        for (const preference of preferences[x]) {
            if (preference === y) break
            preferenceMap[x].add(preference)
        }
        
        preferenceMap[y] = new Set()
        for (const preference of preferences[y]) {
            if (preference === x) break
            preferenceMap[y].add(preference)
        }
    }
    
    let count = 0
    for (const x of Object.keys(preferenceMap)) {
        for (const y of preferenceMap[x]) {
            if (preferenceMap[y].has(+x)) {
                count++
                break
            }
        }
    }
    
    return count
};
```

## 329. Longest Increasing Path in a Matrix
```javascript
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
    const dfs = (row, col) => {
        if (memo[row][col] !== undefined) {
            return memo[row][col]
        }
        
        let max = 1
        for (const [deltaRow, deltaCol] of dirs) {
            const nextRow = deltaRow + row
            const nextCol = deltaCol + col
            
            if (nextRow < 0 || nextRow >= rowLen || 
                nextCol < 0 || nextCol >= colLen) {
                continue
            }
            
            if (matrix[nextRow][nextCol] <= matrix[row][col]) continue
            
            max = Math.max(max, 1 + dfs(nextRow, nextCol))
        }
        
        memo[row][col] = max
        return max
    }
    
    const dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
    const rowLen = matrix.length
    const colLen = matrix[0].length
    
    const memo = new Array(rowLen).fill().map(a => new Array(colLen))
    let max = 0
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (memo[row][col] === undefined) {
                dfs(row, col)
            }
            
            max = Math.max(max, memo[row][col])
        }
    }
    
    return max
};
```

## 397. Integer Replacement
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var integerReplacement = function(n) {
    const _integerReplacement = (n, steps) => {
        if (n < 1) return Infinity
        
        if (n === 1) {
            return steps
        }
        
        memo[`${n}-${steps}`] = Infinity
        if (n % 2 === 0) {
            memo[`${n}-${steps}`] = _integerReplacement(Math.floor(n / 2), steps + 1)
        } else {
            memo[`${n}-${steps}`] = Math.min(_integerReplacement(n + 1, steps + 1), 
                                             _integerReplacement(n - 1, steps + 1))
        }
        
        return memo[`${n}-${steps}`]
    }
    
    const memo = {}
    return _integerReplacement(n, 0)
};
```

## 1429. First Unique Number
```javascript
/**
 * @param {number[]} nums
 */
var FirstUnique = function(nums) {
    this.queue = new DoublyLinkedList()
    this.valueToNodeMap = {}
    
    for (const num of nums) {
        this.add(num)
    }
};

/**
 * @return {number}
 */
FirstUnique.prototype.showFirstUnique = function() {
    const node = this.queue.first()
    return node ? node.value : -1
};

/** 
 * @param {number} value
 * @return {void}
 */
FirstUnique.prototype.add = function(value) {
    if (this.valueToNodeMap[value] === undefined) {
        const node = new Node(value)
        this.valueToNodeMap[value] = node
        this.queue.insertAtTail(node)
        return
    }
    
    if (this.valueToNodeMap[value] === null) {
        return
    }
    
    const node = this.valueToNodeMap[value]
    this.queue.remove(node)
    this.valueToNodeMap[value] = null
};

/** 
 * Your FirstUnique object will be instantiated and called as such:
 * var obj = new FirstUnique(nums)
 * var param_1 = obj.showFirstUnique()
 * obj.add(value)
 */

class DoublyLinkedList {
    constructor() {
        this.head = new Node()
        this.tail = new Node()
        
        this.head.next = this.tail
        this.tail.prev = this.head
        
        this.size = 0
    }
    
    insertAtTail(node) {
        const tail = this.tail
        const prev = tail.prev
        
        prev.next = node
        node.prev = prev
        
        node.next = tail
        tail.prev = node
        
        this.size++
    }
    
    first() {
        if (this.size === 0) {
            return null
        }
        
        return this.head.next
    }
    
    remove(node) {
        const prev = node.prev
        const next = node.next
        
        prev.next = next
        next.prev = prev
        
        node.prev = null
        node.next = null
        
        this.size--
    }
}

class Node {
    constructor(value) {
        this.value = value
    }
}
```

## 532. K-diff Pairs in an Array
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findPairs = function(nums, k) {
    const counts = {}
    for (const num of nums) {
        counts[num] = 1 + (counts[num] || 0)
    }
    
    let pairs = 0
    for (const [key, count] of Object.entries(counts)) {
        const num = +key
        
        if (k === 0) {
            if (count >= 2) {
                pairs++
            }
        } else if (counts[num + k]) {
            pairs++
        }
    }

    return pairs
};
```

## 1105. Filling Bookcase Shelves
```javascript
/**
 * @param {number[][]} books
 * @param {number} shelf_width
 * @return {number}
 */
var minHeightShelves = function(books, shelf_width) {
    const _minHeightShelves = start => {
        if (start >= books.length) {
            return 0
        }
        
        if (memo[start] !== undefined) {
            return memo[start]
        }
        
        let min = Infinity
        let levelWidth = 0
        let maxBookHeight = 0
        
        for (let i = start; i < books.length; i++) {
            const [bookWidth, bookHeight] = books[i]
            
            if (levelWidth + bookWidth > shelf_width) break
            levelWidth += bookWidth
            
            maxBookHeight = Math.max(maxBookHeight, bookHeight)
            
            min = Math.min(min, maxBookHeight + _minHeightShelves(i + 1))
        }
        
        memo[start] = min
        return min
    }
    
    const memo = new Array(books.length)
    return _minHeightShelves(0)
};
```

## 547. Number of Provinces
```javascript
/**
 * @param {number[][]} isConnected
 * @return {number}
 */
var findCircleNum = function(isConnected) {
    const n = isConnected.length
    const unionFind = new UnionFind(n)
    
    for (let cityA = 0; cityA < n; cityA++) {
        for (let cityB = cityA + 1; cityB < n; cityB++) {
            if (isConnected[cityA][cityB]) {
                unionFind.union(cityA, cityB)
            }
        }   
    }
    
    return unionFind.numOfComponents
};

class UnionFind {
    constructor(n) {
        this.sizes = []
        this.parents = []
        for (let i = 0; i < n; i++) {
            this.sizes.push(1)
            this.parents.push(i)
        }
        
        this.numOfComponents = n
    }
    
    union(a, b) {
        const parentA = this.find(a)
        const parentB = this.find(b)
        
        if (parentA === parentB) return
        
        if (this.sizes[parentA] < this.sizes[parentB]) {
            this.parents[parentA] = parentB
            this.sizes[parentB] += this.sizes[parentA]
        } else {
            this.parents[parentB] = parentA
            this.sizes[parentA] += this.sizes[parentB]
        }
        
        this.numOfComponents--
    }
    
    find(a) {
        let root = a
        while (root !== this.parents[root]) {
            root = this.parents[root]
        }
        
        while (root !== a) {
            const next = this.parents[a]
            this.parents[a] = root
            a = next
        }
        
        return root
    }
}
```

## 7. Reverse Integer
```javascript
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    const upperBound = Math.trunc((2 ** 31 - 1) / 10)
    const lowerBound = Math.trunc(-(2 ** 31) / 10)
    
    let reversedNum = 0
    
    while (x) {
        const digit = x % 10
        
        if (reversedNum > upperBound || reversedNum === upperBound && digit > 7) {
            return 0
        } else if (reversedNum < lowerBound || reversedNum === lowerBound && digit < -8) {
            return 0
        }
        
        reversedNum *= 10
        reversedNum += digit
        
        x = Math.trunc(x / 10)
   }
    
    return reversedNum
};
```

## 1588. Sum of All Odd Length Subarrays
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var sumOddLengthSubarrays = function(arr) {
    const prefixSum = [0]
    for (const num of arr) {
        const sum = prefixSum[prefixSum.length - 1] + num
        prefixSum.push(sum)
    }
    
    let sum = 0
    for (let i = 0; i < arr.length; i++) {
        for (let j = i; j < arr.length; j += 2) {
            sum += prefixSum[j + 1] - prefixSum[i]
        }
    }
    
    return sum
};
```