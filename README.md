# swift-algorithms







### Algorithms:



```swift
let unsolvedAlgorithms = ["3Sum",
                     "Accounts Merge",
                     "Add Binary",
                     "Add Strings",
                     "Add and Search Word - Data structure design",
                     "Alien Dictionary",
                     "Backspace String Compare",
                     "Balanced Binary Tree",
                     "Baseball Game",
                     "Basic Calculator II",
                     "Basic Calculator III",
                     "Basic Calculator",
                     "Battleships in a Board",
                     "Best Time to Buy and Sell Stock II",
                     "Best Time to Buy and Sell Stock III",
                     "Best Time to Buy and Sell Stock IV",
                     "Best Time to Buy and Sell Stock",
                     "Binary Search Tree Iterator",
                     "Binary Tree Level Order Traversal",
                     "Binary Tree Longest Consecutive Sequence II",
                     "Binary Tree Maximum Path Sum",
                     "Binary Tree Paths",
                     "Binary Tree Right Side View",
                     "Binary Tree Upside Down",
                     "Binary Tree Vertical Order Traversal",
                     "Binary Tree Zigzag Level Order Traversal",
                     "Binary Tree from Preorder and Inorder Traversal",
                     "Bricks Falling When Hit",
                     "Bucket Sort",
                     "Bulls and Cows",
                     "Burst Balloons",
                     "Bus Routes",
                     "Can I Win",
                     "Can Place Flowers",
                     "Candy",
                     "Cheapest Flights Within K Stops",
                     "Circular Array Loop",
                     "Climbing Stairs",
                     "Clone Graph",
                     "Closest Leaf in a Binary Tree",
                     "Coin Change 2",
                     "Combination Sum",
                     "Construct",
                     "Container With Most Water",
                     "Continuous Subarray Sum",
                     "Convert Binary Search Tree to Sorted Doubly Linked List",
                     "Convert Sorted Array to Binary Search Tree",
                     "Convert Sorted List to Binary Search Tree",
                     "Copy List with Random Pointer",
                     "Count Complete Tree Nodes",
                     "Count Different Palindromic Subsequences",
                     "Count Primes",
                     "Count and Say",
                     "Count of Smaller Numbers After Self",
                     "Counting Sort",
                     "Course Schedule II",
                     "Course Schedule",
                     "Cracking the Safe",
                     "Custom Sort String",
                     "Daily Temperatures",
                     "Decode String",
                     "Decode Ways  Decode Ways  Design Circular Queue",
                     "Design Hit Counter",
                     "Design Search Autocomplete System",
                     "Design Snake Game",
                     "Design Tic-Tac-Toe",
                     "Diagonal Traverse",
                     "Diameter of Binary Tree",
                     "Different Ways to Add Parentheses",
                     "Distinct Subsequences",
                     "Divide Two Integers",
                     "Edit Distance",
                     "Encode and Decode Strings",
                     "Encode and Decode TinyURL",
                     "Evaluate Division",
                     "Evaluate Reverse Polish Notation",
                     "Excel Sheet Column Number",
                     "Excel Sheet Column Title",
                     "Exclusive Time of Functions",
                     "Expression Add Operators",
                     "Fibonacci Iterative",
                     "Fibonacci Recursive",
                     "Find All Anagrams in a String",
                     "Find All Numbers Disappeared in an Array",
                     "Find Anagram Mappings",
                     "Find And Replace in String",
                     "Find Duplicate Subtrees",
                     "Find First and Last Position of Element in Sorted Array",
                     "Find K Closest Elements",
                     "Find Largest Value in Each Tree Row",
                     "Find Leaves of Binary Tree",
                     "Find Median from Data Stream",
                     "Find Minimum in Rotated Sorted Array",
                     "Find Peak Element",
                     "Find Pivot Index",
                     "Find the Celebrity",
                     "Find the Duplicate Number",
                     "First Bad Version",
                     "First Missing Positive",
                     "First Unique Character in a String",
                     "Flatten Binary Tree to Linked List",
                     "Flatten Nested List Iterator",
                     "Flipping an Image",
                     "Flood Fill",
                     "Fraction to Recurring Decimal",
                     "Friends Of Appropriate Ages",
                     "Frog Jump",
                     "Game of Life",
                     "Gas Station", 
                     "Generate Parentheses",
                     "Gray Code",
                     "Group Anagrams",
                     "Group Shifted Strings",
                     "Guess Number Higher or Lower II",
                     "Guess Number Higher or Lower",
                     "Guess the Word",
                     "H-Index",
                     "Hamming Distance",
                     "Hand of Straights",
                     "Heap Sort",
                     "House Robber",
                     "How to detect a common superview",
                     "Image Overlap",
                     "Implement Magic Dictionary",
                     "Implement Trie (Prefix Tree)",
                     "Implement strStr()",
                     "Increasing Subsequences",
                     "Increasing Triplet Subsequence",
                     "Insert Delete GetRandom O(1) - Duplicates allowed",
                     "Insert Delete GetRandom O(1)",
                     "Insert Interval",
                     "Insert into a Cyclic Sorted List",
                     
                     "Intersection of Two Arrays II",
                     
                     "Intersection of Two Linked Lists",
                     "Is Graph Bipartite?",
                     "Is Subsequence",
                     "Island Perimeter",
                     "Isomorphic Strings",
                     "Judge Route Circle",
                     "K Empty Slots",
                     "Knight Probability in Chessboard",
                     "Kth Largest Element in an Array",
                     "Kth Smallest Element in a Sorted Matrix",
                     "LRU Cache",
                     "Largest Number",
                     "Largest Rectangle in Histogram",
                     "Largest Sum Contiguous Subarray",
                     "Letter Combinations of a Phone Number",
                     "License Key Formatting",
                     "Linked List Components",
                     "Linked List Cycle",
                     "Logger Rate Limiter",
                     "Longest Absolute File Path",
                     "Longest Consecutive Sequence",
                     "Longest Increasing Path in a Matrix",
                     "Longest Increasing Subsequence",
                     "Longest Palindromic Substring",
                     "Longest Substring Without Repeating Characters",
                     "Longest Substring with At Least K Repeating Characters",
                     "Longest Substring with At Most K Distinct Characters",
                     "Longest Substring with At Most Two Distinct Characters",
                     "Longest Univalue Path",
                     "Longest Valid Parentheses",
                     "Longest Word in Dictionary through Deleting",
                     "Longest Word in Dictionary",
                     "Lowest Common Ancestor of a Binary Search Tree",
                     "Lowest Common Ancestor of a Binary Tree",
                     "Majority Element II  Max Chunks To Make Sorted",
                     "Majority Element",
                     "Max Consecutive Ones II",
                     "Max Increase to Keep City Skyline",
                     "Max Points on a Line",
                     "Max Stack",
                     "Maximal Rectangle",
                     "Maximal Square",
                     "Maximize Distance to Closest Person",
                     "Maximum Depth of Binary Tree",
                     "Maximum Product Subarray",
                     "Maximum Product of Three Numbers",
                     "Maximum Size Subarray Sum Equals k",
                     "Maximum Subarray",
                     "Maximum Sum of 3 Non-Overlapping Subarrays",
                     "Maximum Vacation Days",
                     "Maximum Width of Binary Tree",
                     "Maximum XOR of Two Numbers in an Array",
                     "Median of Two Sorted Arrays",
                     "Meeting Rooms II",
                     "Meeting Rooms",
                     "Merge Intervals",
                     "Merge Sorted Array",
                     "Merge Two Binary Trees",
                     "Merge Two Sorted Lists",
                     "Merge k Sorted Lists",
                     "Min Cost Climbing Stairs",
                     "Min Stack",
                     "Minesweeper",
                     "Minimize Max Distance to Gas Station",
                     "Minimum Cost to Hire K Workers",
                     "Minimum Depth of Binary Tree",
                     "Minimum Height Trees",
                     "Minimum Path Sum",
                     "Minimum Size Subarray Sum",
                     "Minimum Window Substring",
                     "Mirror Reflection",
                     "Missing Number",
                     "Missing Ranges",
                     "Most Common Word",
                     "Move Zeroes",
                     "Moving Average from Data Stream",
                     "Multiply Strings",
                     "My Calendar I",
                     "My Calendar II",
                     "My Calendar III",
                     "N-Queens II",
                     "N-Queens",
                     "Nested List Weight Sum II",
                     "Nested List Weight Sum",
                     "Next Closest Time",
                     "Next Greater Element III",
                     "Next Permutation",
                     "Number of 1 Bits",
                     "Number of Boomerangs",
                     "Number of Islands II",
                     "Number of Islands",
                     "Number of Lines To Write String",
                     "One Edit Distance",
                     "Optimal Account Balancing",
                     "Paint House",
                     "Palindrome Linked List",
                     "Palindrome Number",
                     "Palindrome Pairs",
                     "Palindromic Substrings",
                     "Parse Lisp Expression",
                     "Partition to K Equal Sum Subsets",
                     "Pascal's Triangle II",
                     "Pascal's Triangle",
                     "Path Sum II",
                     "Path Sum III",
                     "Peak Index in a Mountain Array",
                     "Perfect Squares",
                     "Perfect squares up to number",
                     "Permutation in String",
                     "Permutations II",
                     "Permutations",
                     "Plus One Linked List",
                     "Plus One",
                     "Populating Next Right Pointers in Each Node",
                     "Possible Bipartition",
                     "Pow(x, n)",
                     "Power of Three",
                     "Power of Two",
                     "Predict the Winner",
                     "Prefix and Suffix Search",
                     "Product of Array Except Self",
                     "Queue Reconstruction by Height",
                     "Race Car",
                     "Random Pick Index",
                     "Random Pick with Weight",
                     "Range Module",
                     "Range Sum Query - Mutable",
                     "Range Sum Query 2D - Immutable",
                     "Range Sum Query 2D - Mutable",
                     "Read N Characters Given Read4 II - Call multiple times",
                     "Read N Characters Given Read4",
                     "Rearrange String k Distance Apart",
                     "Recover Binary Search Tree",
                     "Rectangle Area II",
                     "Redundant Connection II",
                     "Redundant Connection",
                     "Regular Expression Matching",
                     "Remove Comments",
                     "Remove Duplicate Letters",
                     "Remove Duplicates from Sorted Array",
                     "Remove Invalid Parentheses",
                     "Remove Nth Node From End of List",
                     "Reorder List",
                     "Reorganize String",
                     "Repeated DNA Sequences",
                     "Repeated String Match",
                     "Repeated Substring Pattern",
                     "Reverse Integer",
                     "Reverse Nodes in k-Group",
                     "Reverse Pairs",
                     "Reverse Vowels of a String",
                     "Robot Room Cleaner",
                     "Rotate Array",
                     "Rotate Image",
                     "Search Insert Position",
                     "Search a 2D Matrix II",
                     "Search in Rotated Sorted Array II",
                     "Search in Rotated Sorted Array",
                     "Second Highest Salary",
                     "Second Minimum Node In a Binary Tree",
                     "Sentence Screen Fitting",
                     "Sentence Similarity II",
                     "Sentence Similarity",
                     "Serialize and Deserialize BST",
                     "Serialize and Deserialize Binary Tree",
                     "Serialize and Deserialize N-ary Tree",
                     "Set Matrix Zeroes",
                     "Shell Sort",
                     "Shortest Distance from All Buildings",
                     "Shortest Subarray with Sum at Least K",
                     "Shortest Word Distance II",
                     "Shortest Word Distance",
                     "Shuffle an Array",
                     "Single Element in a Sorted Array",
                     "Single Number",
                     "Sliding Window Maximum",
                     "Sort Colors  Sort Transformed Array",
                     "Sort Transformed Array",
                     "Sparse Matrix Multiplication",
                     "Spiral Matrix",
                     "Split Array With Same Average",
                     "Split BST",
                     "Sqrt(x)",
                     "String to Integer (atoi)",
                     "Strobogrammatic Number II",
                     "Strobogrammatic Number",
                     "Subarray Sum Equals K",
                     "Subsets",
                     "Substring with Concatenation of All Words",
                     "Subtree of Another Tree",
                     "Sudoku Solver",
                     "Sum Root to Leaf Numbers",
                     "Sum of Square Numbers",
                     "Sum of Two Integers",
                     "Summary Ranges",
                     "Surrounded Regions",
                     "Swap Nodes in Pairs",
                     "Symmetric Tree",
                     "Task Scheduler",
                     "Text Justification",
                     "The Maze",
                     "The Skyline Problem",
                     "Toeplitz Matrix",
                     "Top K Frequent Elements",
                     "Top K Frequent Words",
                     "Trapping Rain Water",
                     "Triangle",
                     "UTF-8 Validation",
                     "Ugly Number II",
                     "Unique Morse Code Words",
                     "Unique Paths",
                     "Unique Word Abbreviation",
                     "Valid Anagram",
                     "Valid Number",
                     "Valid Palindrome II",
                     "Valid Palindrome",
                     "Valid Parentheses",
                     "Valid Perfect Square",
                     "Valid Sudoku",
                     "Validate Binary Search Tree",
                     "Validate IP Address",
                     "Walls and Gates",
                     "Wiggle Sort II",
                     "Wiggle Sort",
                     "Wildcard Matching",
                     "Word Break II",
                     "Word Break",
                     "Word Ladder II",
                     "Word Ladder",
                     "Word Search II",
                     "Shell Sort",
                     "Word Search",
                     "Zigzag Iterator"
                     ]

let y = ["Add Two Numbers II",
"Integer to English Words",
"Integer to Roman",
"Intersection of Two Arrays",
"Valid Parentheses",
"Two Sum II - Input array is sorted",
"Two Sum III - Data structure design",
"Two Sum IV - Input is a BST",
"Find of perfect squares between two numbers",
"Reverse Linked List",
]


let solvedAlgorithms = ["Add Two Numbers",
                        "Binary Search - Iterative",
                        "Binary Search - Recursive",
                        "Bubble Sort",
                        "Fibonnaci - Iterative",
                        "Fibonnaci - Recursive",
                        "FizzBuzz",
                        "Insertion Sort",
                        "Merge Sort",
                        "Quick Sort",
                        "Radix Sort",
                        "Selection Sort",
                        "Shuffle Array",
                        "Two Sum - Sorted",
                        "Two Sum - Unsorted",
                        "Jewels and Stones",
                        "Roman to Integer",
                        "Lowest Common Ancestor of a Binary Search Tree"
                        ]

import Darwin

extension Collection where Index == Int {
  func randomElements(to number: Int) -> [Element] {
    var result: [Element] = []
    var index: [Int: Int] = [:]
    while result.count < number {
      let randomIndex = Int(arc4random_uniform(UInt32(endIndex)))
      if index[randomIndex] == nil {
        let randomElement = self[randomIndex]
        index[randomIndex] = randomIndex
        result.append(randomElement)
      }
    }
    return result
  }
}

extension MutableCollection where Index == Int {
  mutating func shuffle() {
    guard count > 1 else { return }
    
    for index in indices {
      let randomIndex = Int(arc4random_uniform(UInt32(endIndex)))
      swapAt(index, randomIndex)
    }
  }
}

func problems() -> [String] {
  var algorithms = unsolvedAlgorithms.randomElements(to: 1) + solvedAlgorithms.randomElements(to: 4)
  algorithms.shuffle()
  return algorithms
}

print(problems())




```

## number of jewels
```swift

class Solution {
  func numJewelsInStones(_ J: String, _ S: String) -> Int {
    let jewels = S.filter { J.contains($0) }
    return jewels.count
  }
}



//why is unicode scalar solution faster?

class Solution {
    func numJewelsInStones(_ J: String, _ S: String) -> Int {
        return S.unicodeScalars.filter { J.unicodeScalars.contains($0) }.count
    }
}

extension Sequence {
  func count(where predicate: (Element) -> Bool) -> Int {
    var count = 0
    for element in self {
      if predicate(element) {
        count += 1
      }
    }
    return count
  }
}

class Solution {
  func numJewelsInStones<T: Sequence>(_ J: T, _ S: T) -> Int where T.Iterator.Element: Equatable  {
    return S.count(where: { J.contains($0) })
  }
}

extension Sequence {
  func count(where predicate: (Element) -> Bool) -> Int {
    return filter { predicate($0) }.count
  }
}

class Solution {
  func numJewelsInStones<T: Sequence>(_ J: T, _ S: T) -> Int where T.Iterator.Element: Equatable  {
    return S.count(where: { J.contains($0) })
  }
}

Solution().numJewelsInStones("aA", "aAAbbbb")


extension Sequence {
  func count(where predicate: (Element) -> Bool) -> Int {
    return filter { predicate($0) }.count
  }
}

class Solution {
  func numJewelsInStones<T: Sequence>(_ J: T, _ S: T) -> Int where T.Iterator.Element: Equatable  {
    return S.count(where: J.contains)
  }
}

Solution().numJewelsInStones("aA", "aAAbbbb")


Time Complexity: O(J\text{.length} + S\text{.length}))O(J.length+S.length)). The O(J\text{.length})O(J.length) part comes from creating J. The O(S\text{.length})O(S.length) part comes from searching S.

Space Complexity: O(J\text{.length})O(J.length).



extension Sequence {
  func count(where predicate: (Element) -> Bool) -> Int {
    return filter { predicate($0) }.count
  }
}

class Solution {
  func numJewelsInStones(_ J: String, _ S: String) -> Int {
    let jSet = Set(J)
    return S.count(where: jSet.contains)
  }
}

// using a set will be faster because the init is O(n) but subseqent contains calls will be O(1)
// where using an array, each contains call will be O(n)


```



two sum sorted -- two pointer approach 
time O(n)
space - O(1) because it's always two pointers

two sum unsorted -- hash approach
time O(n)
space - O(n) becasue of the hash table

if we had an unsorted array and wanted to optimize for space and not speed then we would do an inplace sort then we would do the two pointer approach.





while a true inplace sort is not possible in swift, making a new array could be a quick operation
especially if we set reservecapacity so it didn't have to keep making new arrays assuming we know the input size. We don't need to rely on geometric growth here.




## roman to int 
```swift 
class Solution {
  func romanToInt(_ s: String) -> Int {
    var accumulator = 0

    for index in 0..<s.count {
      var romanValue = value(for: s[index])

      let nextIndex = index + 1
      if nextIndex < s.count, value(for: s[nextIndex]) > value(for: s[index]) {
        romanValue *= -1
      }
      accumulator += romanValue
    }
    return accumulator
  }

  private static let romanValues: [Character: Int] = ["I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000]

  private func value(for character: Character) -> Int {
    return Solution.romanValues[character] ?? 0
  }
}

extension String {
  subscript (offset: Int) -> Character {
    return self[index(startIndex, offsetBy: offset)]
  }
}

Solution().romanToInt("XXVIIIXDDM")

// Switch statement is faster than a dictionary lookup
// Switch is faster because of wrapping and unwrapping values from the dictionary slows it down
```

# Completed

https://www.youtube.com/watch?v=p3vVYNngyxs


https://www.youtube.com/watch?v=pDyh9VOMWgI




https://stackoverflow.com/questions/22666535/shared-ancestor-between-two-views


https://medium.com/journey-of-one-thousand-apps/finding-the-first-common-superview-in-swift-4abac8a87d84
https://medium.com/journey-of-one-thousand-apps/data-structures-35b968bcedf5
https://medium.com/journey-of-one-thousand-apps/building-with-python-requests-d9260b26e7ab

https://medium.com/journey-of-one-thousand-apps/building-a-hash-data-structure-in-swift-e9b2733d9e20

https://medium.com/journey-of-one-thousand-apps/data-structures-in-the-real-world-508f5968545a

https://medium.com/journey-of-one-thousand-apps/background-thread-and-main-dispatch-50f19b000d8
https://medium.com/journey-of-one-thousand-apps/testing-asynchronous-code-in-swift-2142901dbd4f
https://medium.com/journey-of-one-thousand-apps/complexity-and-big-o-notation-in-swift-478a67ba20e7
https://stackoverflow.com/questions/43230994/common-parent-view-in-swift




https://www.youtube.com/user/tusharroy2525/videos




## Implement strStr()

Knuth–Morris–Pratt(KMP) Pattern Matching(Substring search)
https://www.youtube.com/watch?v=GTJr8OvyEVQ
// O(m + n)
m = length of haystack
n = length of needle






https://www.youtube.com/watch?v=WIoZuhAC1p4


##two sum

extension Collection where Element == Int {
  func twoSum(for target: Element) -> (Element, Element)? {
    guard count > 1 else { return nil }
    
    var elementsSeen = Set<Int>()
    elementsSeen.reserveCapacity(Int(count))
    
    for element in self {
      print(elementsSeen)
      let compliment = target - element
      if elementsSeen.contains(compliment) {
        return (compliment, element)
      } else {
        elementsSeen.insert(element)
      }
    }
    
    return nil
  }
}

var a = [1, 5, 4, 8, 66, 4, 12, 3, 2, 1, 6, 7, 8, 99, 0]
print(a.twoSum(for: 100))

we can reserve capacity because we don't need a geometric growth strategy. we already know the maximum amount of numbers possible is equal to the count of the collection so we can just reserve capacity for the size of the collection




## Add Two Numbers
// Time complexity : O(\max(m, n))O(max(m,n)). Assume that mm and nn represents the length of l1l1 and l2l2 respectively, the algorithm above iterates at most \max(m, n)max(m,n) times.
// Space complexity : O(\max(m, n))O(max(m,n)). The length of the new list is at most \max(m,n) + 1max(m,n)+1.
```swift
func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
  var currentL1Node = l1
  var currentL2Node = l2
  
  let head = ListNode(0)
  var current = head
  var carry = 0
  
  while currentL1Node != nil || currentL2Node != nil {
    let l1NodeValue = currentL1Node?.val ?? 0
    let l2NodeValue = currentL2Node?.val ?? 0

    let total = l1NodeValue + l2NodeValue + carry
    carry = total / 10
    current.next = ListNode(total % 10)
    current = current.next!
    currentL1Node = currentL1Node?.next
    currentL2Node = currentL2Node?.next
  }
  
  if carry > 0 {
    current.next = ListNode(carry)
  }
  return head.next
}
```


## Bubble Sort
Best - O(n)
Worst - O(n^2)
Space - O(1)

```swift
extension MutableCollection where Self: BidirectionalCollection, Element: Comparable, Index: Strideable, Index.Stride: SignedInteger {
  mutating func bubbleSort() {
    guard count > 1 else { return }
    
    for endingIndex in indices.reversed() {
      var noSwaps = true
      for currentIndex in startIndex..<endingIndex {
        let nextIndex = index(after: currentIndex)
        if self[currentIndex] > self[nextIndex] {
          swapAt(currentIndex, nextIndex)
          noSwaps = false
        }
      }
      if noSwaps { return }
    }
  }
}

var a = [6, 3, 8, 7, 5, 4, 2, 9, 8, 5, 4, 2]
a.bubbleSort()
```


## Insertion Sort
Best - O(n)
Worst - O(n^2)
Space - O(1)

```swift
extension MutableCollection where Self: BidirectionalCollection, Element: Comparable, Index: Strideable, Index.Stride: SignedInteger {
  mutating func insertionSort() {
    guard count > 1 else { return }
    
    for currentIndex in index(after: startIndex)..<endIndex {
      for shiftingIndex in (index(after: startIndex)...currentIndex).reversed() {
        let previousIndex = index(before: shiftingIndex)
        if self[previousIndex] > self[shiftingIndex] {
          swapAt(previousIndex, shiftingIndex)
        } else {
          break
        }
      }
    }
  }
}

var b = [6, 3, 8, 7, 5, 4, 2, 9, 8, 5, 4, 2]
b.insertionSort()
```

## Selection Sort
Best - O(n^2)
Worst - O(n^2)
Space - O(1)

```swift
extension MutableCollection where Self: BidirectionalCollection, Element: Comparable, Index: Strideable, Index.Stride: SignedInteger {
  mutating func selectionSort() {
    guard count > 1 else { return }
    
    for currentIndex in startIndex..<index(before: endIndex) {
      var lowestIndex = currentIndex
      for swapIndex in index(after: currentIndex)..<endIndex {
        if self[swapIndex] < self[lowestIndex] {
          lowestIndex = swapIndex
        }
      }
      swapAt(lowestIndex, currentIndex)
    }
  }
}

var c = [6, 3, 8, 7, 5, 4, 2, 9, 8, 5, 4, 2]
c.selectionSort()
```

## Merge Sort
Best - O(n log n)
Worst - O(n log n)
Space - O(n log n)

```swift
public func mergeSort<Element: Comparable>(_ array: [Element]) -> [Element] {
  guard array.count > 1 else { return array }
  let middleIndex = array.count / 2
  let left = mergeSort(Array(array[..<middleIndex]))
  let right = mergeSort(Array(array[middleIndex...]))
  return merge(left, right)
}

private func merge<Element: Comparable>(_ left: [Element], _ right: [Element]) -> [Element] {
  var result = [Element]()
  var leftIndex = 0
  var rightIndex = 0
  
  while left.count > leftIndex && right.count > rightIndex {
    let leftElement = left[leftIndex]
    let rightElement = right[rightIndex]
    
    if leftElement > rightElement {
      result.append(rightElement)
      rightIndex += 1
    } else if leftElement < rightElement {
      result.append(leftElement)
      leftIndex += 1
    } else {
      result.append(leftElement)
      result.append(rightElement)
      leftIndex += 1
      rightIndex += 1
    }
  }
  
  if left.count > leftIndex {
    result.append(contentsOf: left[leftIndex...])
  }
  
  if right.count > rightIndex {
    result.append(contentsOf: right[rightIndex...])
  }
  
  return result
}

var d = [6, 3, 8, 7, 5, 4, 2, 9, 8, 5, 4, 2]
mergeSort(d)
```

## Radix Sort
Best - O(nk)
Worst - O(nk)
Space - O(n + k)

```swift
extension Array where Element == Int {
  mutating func radixSort() {
    guard count > 1 else { return }
    
    var done = false
    var digits = 1
    let radix = 10
    
    while !done {
      done = true
      var buckets: [[Int]] = .init(repeating: [], count: radix)
      
      for number in self {
        let remainingPart = number / digits
        let digit = remainingPart % radix
        buckets[digit].append(number)
        
        if remainingPart > 0 {
          done = false
        }
      }
      
      self = buckets.flatMap { $0 }
      digits *= 10
    }
  }
}

var a = [1, 4, 3, 5, 6, 7, 8, 5, 4, 3, 2, 8, 7]
a.radixSort()
```

## Quick Sort
Best - O(n log n)
Worst - O(n^2)
Space - O(1)

```swift
import Foundation

public func quickSort<Element: Comparable>(_ array: inout [Element]) {
  quickSort(&array, array.startIndex, array.index(before: array.endIndex))
}

private func quickSort<Element: Comparable>(_ array: inout [Element], _ low: Int, _ high: Int) {
  guard low < high else { return }
  
  let randomIndex = random(low, high)
  array.swapAt(randomIndex, high)
  
  let partitionIndex = partition(&array, low, high)
  quickSort(&array, low, array.index(before: partitionIndex))
  quickSort(&array, array.index(after: partitionIndex), high)
}

private func partition<Element: Comparable>(_ array: inout [Element], _ low: Int, _ high: Int) -> Int {
  let partitionElement = array[high]
  var lowIndex = low
  
  for currentIndex in low..<high {
    if array[currentIndex] <= partitionElement {
      array.swapAt(currentIndex, lowIndex)
      lowIndex += 1
    }
  }
  
  array.swapAt(lowIndex, high)
  return lowIndex
}

private func random(_ min: Int, _ max: Int) -> Int {
  return min + Int(arc4random_uniform(UInt32(max - min) + 1))
}

var a = [5, 3, 2, 7, 6, 8, 7, 3, 2, 1, 3, 4, 6, 8]
quickSort(&a)
```

## Binary Search (Recursive)
Best - O(log n)
Worst - O(log n)
Space - O(log n)

```swift

```

## Binary Search (Iterative)
Best - O(log n)
Worst - O(log n)
Space - O(1)

```swift

```

## Two Sum (Sorted Array Guaranteed)

```swift
func twoSum(_ array: [Int], _ sum: Int) -> Bool {
  var lowIndex = 0
  var highIndex = array.count - 1
  
  while lowIndex < highIndex {
    let sumOfItems = array[lowIndex] + array[highIndex]
    if sumOfItems == sum {
      return true
    } else if sumOfItems > sum {
      highIndex -= 1
    } else if sumOfItems < sum {
      lowIndex += 1
    }
  }
  return false
}

extension RandomAccessCollection where Element == Int {
  func twoSum(for sum: Int) -> (Int, Int)? {
    guard count > 1 else { return nil }
    
    var left = startIndex
    var right = index(before: endIndex)
    
    while left < right {
      let value = self[left] + self[right]
      
      if value == sum {
        return (self[left], self[right])
      } else if value > sum {
        right = index(before: right)
      } else {
        left = index(after: left)
      }
    }
    return nil
  }
}
```


## Two Sum (Sorted Array Not Guaranteed)

```swift
func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
  var dict = [Int: Int]()
  
  for (index, num) in nums.enumerated() {
    let complement = target - num
    
    if let complementIndex = dict[complement] {
      return [complementIndex, index]
    }
    
    dict[num] = index
  }
  return []
}

extension RandomAccessCollection where Element == Int {
  func twoSum(for target: Int) -> (Int, Int)? {
    guard count > 1 else { return nil }
    var numbersSeen = Set<Int>()
    
    for num in self {
      let complement = target - num
      if numbersSeen.contains(complement) {
        return (complement, num)
      } else {
        numbersSeen.insert(num)
      }
    }
    
    return nil
  }
}
```

## Two Sum - Input is a Binary Search Tree


## FizzBuzz
```swift
struct FizzBuzz: Sequence, IteratorProtocol {
  var count = 1
  
  mutating func next() -> String? {
    defer { count += 1 }
    return value(for: count)
  }
  
  private func value(for number: Int) -> String {
    if number.divisible(by: 15) { return "FizzBuzz" }
    if number.divisible(by: 3) { return "Fizz" }
    if number.divisible(by: 5) { return "Buzz" }
    return "\(number)"
  }
}

extension Int {
  func divisible(by denominator: Int) -> Bool {
    return self % denominator == 0
  }
}

for value in FizzBuzz().prefix(15) {
  print(value)
}

```


## Fibonacci
```swift
struct Fibonacci: Sequence, IteratorProtocol {
  var state = (0, 1)
  
  mutating func next() -> Int? {
    let upcomingNumber = state.0
    state = (state.1, state.0 + state.1)
    return upcomingNumber
  }
}


for num in Fibonacci().prefix(10) {
  print(num)
}
```

## Most Common Element in an array

```swift
var a = [1, 1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 2, 3, 4, 1, 2, 3, 3, 3, 4, 5]


func mostFrequent<T: Hashable>(array: [T]) -> (value: T, count: Int)? {
  
  let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }
  
  if let (value, count) = counts.max(by: { $0.1 < $1.1 }) {
    return (value, count)
  }
  
  // array was empty
  return nil
}

if let result = mostFrequent(array: a) {
  print("\(result.value) occurs \(result.count) times")
}


```


## Shuffle Array in place